var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
import require$$1$7, { app, ipcMain, BrowserWindow } from "electron";
import require$$4$2, { fileURLToPath } from "url";
import require$$1$2 from "fs";
import require$$1$1 from "path";
import require$$2$1 from "os";
import require$$1$3 from "crypto";
import require$$0$3 from "events";
import require$$2$2 from "net";
import require$$0$1 from "buffer";
import require$$1$4 from "string_decoder";
import require$$0$2 from "zlib";
import require$$9 from "tls";
import require$$0$4 from "stream";
import require$$1$5 from "tty";
import require$$1$6 from "util";
import require$$0$5 from "constants";
import require$$5$1 from "assert";
import require$$1$8 from "child_process";
import require$$4$3 from "http";
import require$$1$9 from "https";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var main$3 = { exports: {} };
const version$1 = "16.4.7";
const require$$4$1 = {
  version: version$1
};
var hasRequiredMain$3;
function requireMain$3() {
  if (hasRequiredMain$3) return main$3.exports;
  hasRequiredMain$3 = 1;
  const fs2 = require$$1$2;
  const path = require$$1$1;
  const os = require$$2$1;
  const crypto = require$$1$3;
  const packageJson2 = require$$4$1;
  const version2 = packageJson2.version;
  const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse2(src2) {
    const obj = {};
    let lines = src2.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0; i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error2) {
        if (i + 1 >= length) {
          throw error2;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _log(message) {
    console.log(`[dotenv@${version2}][INFO] ${message}`);
  }
  function _warn(message) {
    console.log(`[dotenv@${version2}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version2}][DEBUG] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error2) {
      if (error2.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error2;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs2.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs2.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath2) {
    return envPath2[0] === "~" ? path.join(os.homedir(), envPath2.slice(1)) : envPath2;
  }
  function _configVault(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs2.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error2) {
      const isRange = error2 instanceof RangeError;
      const invalidKeyLength = error2.message === "Invalid key length";
      const decryptionFailed = error2.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error2;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  const DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse: parse2,
    populate
  };
  main$3.exports.configDotenv = DotenvModule.configDotenv;
  main$3.exports._configVault = DotenvModule._configVault;
  main$3.exports._parseVault = DotenvModule._parseVault;
  main$3.exports.config = DotenvModule.config;
  main$3.exports.decrypt = DotenvModule.decrypt;
  main$3.exports.parse = DotenvModule.parse;
  main$3.exports.populate = DotenvModule.populate;
  main$3.exports = DotenvModule;
  return main$3.exports;
}
var mainExports$1 = requireMain$3();
var promise = {};
var checkNode = {};
const version = "3.4.0";
const engines = { "node": ">= 14" };
const require$$8 = {
  version,
  engines
};
var hasRequiredCheckNode;
function requireCheckNode() {
  if (hasRequiredCheckNode) return checkNode;
  hasRequiredCheckNode = 1;
  const hasMinVersion = function(nodeVersionStr, connectorRequirement2) {
    const versNode = nodeVersionStr.split(".");
    const versReq = connectorRequirement2.split(".");
    const majorNode = Number(versNode[0]);
    const majorReq = Number(versReq[0]);
    if (majorNode > majorReq) return true;
    if (majorNode < majorReq) return false;
    if (versReq.length === 1) return true;
    const minorNode = Number(versNode[1]);
    const minorReq = Number(versReq[1]);
    return minorNode >= minorReq;
  };
  checkNode.hasMinVersion = hasMinVersion;
  const requirement = require$$8.engines.node;
  const connectorRequirement = requirement.replace(">=", "").trim();
  const currentNodeVersion = process.version.replace("v", "");
  if (!hasMinVersion(currentNodeVersion, connectorRequirement)) {
    console.error(`please upgrade node: mariadb requires at least version ${connectorRequirement}`);
    process.exit(1);
  }
  return checkNode;
}
var denque;
var hasRequiredDenque;
function requireDenque() {
  if (hasRequiredDenque) return denque;
  hasRequiredDenque = 1;
  function Denque(array, options) {
    var options = options || {};
    this._capacity = options.capacity;
    this._head = 0;
    this._tail = 0;
    if (Array.isArray(array)) {
      this._fromArray(array);
    } else {
      this._capacityMask = 3;
      this._list = new Array(4);
    }
  }
  Denque.prototype.peekAt = function peekAt(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var len = this.size();
    if (i >= len || i < -len) return void 0;
    if (i < 0) i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail) return void 0;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail) return 0;
    if (this._head < this._tail) return this._tail - this._head;
    else return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (arguments.length === 0) return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head) this._growArray();
    if (this._capacity && this.size() > this._capacity) this.pop();
    if (this._head < this._tail) return this._tail - this._head;
    else return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail) return void 0;
    var item = this._list[head];
    this._list[head] = void 0;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2) this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (arguments.length === 0) return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail) return this._tail - this._head;
    else return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head) return void 0;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = void 0;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2) this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail) return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size) return void 0;
    if (i < 0) i += size;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index < size / 2) {
      for (k = index; k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size - 1 - index; k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index, count) {
    var i = index;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail) return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size || count < 1) return void 0;
    if (i < 0) i += size;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size) count = size - i;
    var k;
    removed = new Array(count);
    for (k = 0; k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index + count === size) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (index === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (i < size / 2) {
      this._head = this._head + index + count + len & this._capacityMask;
      for (k = index; k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
      if (index < 0) this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size - (count + index); k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2) this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index, count) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var size = this.size();
    if (i < 0) i += size;
    if (i > size) return void 0;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size || i < size / 2) {
        temp = new Array(i);
        for (k = 0; k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i; k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size - (i + count));
        var leng = temp.length;
        for (k = 0; k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0; k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._list = new Array(this._list.length);
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array) {
    var length = array.length;
    var capacity = this._nextPowerOf2(length);
    this._list = new Array(capacity);
    this._capacityMask = capacity - 1;
    this._tail = length;
    for (var i = 0; i < length; i++) this._list[i] = array[i];
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
    var src2 = this._list;
    var capacity = src2.length;
    var length = this.length;
    size = size | length;
    if (size == length && this._head < this._tail) {
      return this._list.slice(this._head, this._tail);
    }
    var dest = new Array(size);
    var k = 0;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head; i < capacity; i++) dest[k++] = src2[i];
      for (i = 0; i < this._tail; i++) dest[k++] = src2[i];
    } else {
      for (i = this._head; i < this._tail; i++) dest[k++] = src2[i];
    }
    return dest;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head != 0) {
      var newList = this._copyArray(true, this._list.length << 1);
      this._tail = this._list.length;
      this._head = 0;
      this._list = newList;
    } else {
      this._tail = this._list.length;
      this._list.length <<= 1;
    }
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
    var log2 = Math.log(num) / Math.log(2);
    var nextPow2 = 1 << log2 + 1;
    return Math.max(nextPow2, 4);
  };
  denque = Denque;
  return denque;
}
var errors = { exports: {} };
var errorCode = {};
var hasRequiredErrorCode;
function requireErrorCode() {
  if (hasRequiredErrorCode) return errorCode;
  hasRequiredErrorCode = 1;
  let codes = {};
  codes[120] = "HA_ERR_KEY_NOT_FOUND";
  codes[121] = "HA_ERR_FOUND_DUPP_KEY";
  codes[122] = "HA_ERR_INTERNAL_ERROR";
  codes[123] = "HA_ERR_RECORD_CHANGED";
  codes[124] = "HA_ERR_WRONG_INDEX";
  codes[126] = "HA_ERR_CRASHED";
  codes[127] = "HA_ERR_WRONG_IN_RECORD";
  codes[128] = "HA_ERR_OUT_OF_MEM";
  codes[130] = "HA_ERR_NOT_A_TABLE";
  codes[131] = "HA_ERR_WRONG_COMMAND";
  codes[132] = "HA_ERR_OLD_FILE";
  codes[133] = "HA_ERR_NO_ACTIVE_RECORD";
  codes[134] = "HA_ERR_RECORD_DELETED";
  codes[135] = "HA_ERR_RECORD_FILE_FULL";
  codes[136] = "HA_ERR_INDEX_FILE_FULL";
  codes[137] = "HA_ERR_END_OF_FILE";
  codes[138] = "HA_ERR_UNSUPPORTED";
  codes[139] = "HA_ERR_TO_BIG_ROW";
  codes[140] = "HA_WRONG_CREATE_OPTION";
  codes[141] = "HA_ERR_FOUND_DUPP_UNIQUE";
  codes[142] = "HA_ERR_UNKNOWN_CHARSET";
  codes[143] = "HA_ERR_WRONG_MRG_TABLE_DEF";
  codes[144] = "HA_ERR_CRASHED_ON_REPAIR";
  codes[145] = "HA_ERR_CRASHED_ON_USAGE";
  codes[146] = "HA_ERR_LOCK_WAIT_TIMEOUT";
  codes[147] = "HA_ERR_LOCK_TABLE_FULL";
  codes[148] = "HA_ERR_READ_ONLY_TRANSACTION";
  codes[149] = "HA_ERR_LOCK_DEADLOCK";
  codes[150] = "HA_ERR_CANNOT_ADD_FOREIGN";
  codes[151] = "HA_ERR_NO_REFERENCED_ROW";
  codes[152] = "HA_ERR_ROW_IS_REFERENCED";
  codes[153] = "HA_ERR_NO_SAVEPOINT";
  codes[154] = "HA_ERR_NON_UNIQUE_BLOCK_SIZE";
  codes[155] = "HA_ERR_NO_SUCH_TABLE";
  codes[156] = "HA_ERR_TABLE_EXIST";
  codes[157] = "HA_ERR_NO_CONNECTION";
  codes[158] = "HA_ERR_NULL_IN_SPATIAL";
  codes[159] = "HA_ERR_TABLE_DEF_CHANGED";
  codes[160] = "HA_ERR_NO_PARTITION_FOUND";
  codes[161] = "HA_ERR_RBR_LOGGING_FAILED";
  codes[162] = "HA_ERR_DROP_INDEX_FK";
  codes[163] = "HA_ERR_FOREIGN_DUPLICATE_KEY";
  codes[164] = "HA_ERR_TABLE_NEEDS_UPGRADE";
  codes[165] = "HA_ERR_TABLE_READONLY";
  codes[166] = "HA_ERR_AUTOINC_READ_FAILED";
  codes[167] = "HA_ERR_AUTOINC_ERANGE";
  codes[168] = "HA_ERR_GENERIC";
  codes[169] = "HA_ERR_RECORD_IS_THE_SAME";
  codes[170] = "HA_ERR_LOGGING_IMPOSSIBLE";
  codes[171] = "HA_ERR_CORRUPT_EVENT";
  codes[172] = "HA_ERR_NEW_FILE";
  codes[173] = "HA_ERR_ROWS_EVENT_APPLY";
  codes[174] = "HA_ERR_INITIALIZATION";
  codes[175] = "HA_ERR_FILE_TOO_SHORT";
  codes[176] = "HA_ERR_WRONG_CRC";
  codes[177] = "HA_ERR_TOO_MANY_CONCURRENT_TRXS";
  codes[178] = "HA_ERR_NOT_IN_LOCK_PARTITIONS";
  codes[179] = "HA_ERR_INDEX_COL_TOO_LONG";
  codes[180] = "HA_ERR_INDEX_CORRUPT";
  codes[181] = "HA_ERR_UNDO_REC_TOO_BIG";
  codes[182] = "HA_FTS_INVALID_DOCID";
  codes[184] = "HA_ERR_TABLESPACE_EXISTS";
  codes[185] = "HA_ERR_TOO_MANY_FIELDS";
  codes[186] = "HA_ERR_ROW_IN_WRONG_PARTITION";
  codes[187] = "HA_ERR_ROW_NOT_VISIBLE";
  codes[188] = "HA_ERR_ABORTED_BY_USER";
  codes[189] = "HA_ERR_DISK_FULL";
  codes[190] = "HA_ERR_INCOMPATIBLE_DEFINITION";
  codes[191] = "HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE";
  codes[192] = "HA_ERR_DECRYPTION_FAILED";
  codes[193] = "HA_ERR_FK_DEPTH_EXCEEDED";
  codes[194] = "HA_ERR_TABLESPACE_MISSING";
  codes[195] = "HA_ERR_SEQUENCE_INVALID_DATA";
  codes[196] = "HA_ERR_SEQUENCE_RUN_OUT";
  codes[197] = "HA_ERR_COMMIT_ERROR";
  codes[198] = "HA_ERR_PARTITION_LIST";
  codes[1e3] = "ER_HASHCHK";
  codes[1001] = "ER_NISAMCHK";
  codes[1002] = "ER_NO";
  codes[1003] = "ER_YES";
  codes[1004] = "ER_CANT_CREATE_FILE";
  codes[1005] = "ER_CANT_CREATE_TABLE";
  codes[1006] = "ER_CANT_CREATE_DB";
  codes[1007] = "ER_DB_CREATE_EXISTS";
  codes[1008] = "ER_DB_DROP_EXISTS";
  codes[1009] = "ER_DB_DROP_DELETE";
  codes[1010] = "ER_DB_DROP_RMDIR";
  codes[1011] = "ER_CANT_DELETE_FILE";
  codes[1012] = "ER_CANT_FIND_SYSTEM_REC";
  codes[1013] = "ER_CANT_GET_STAT";
  codes[1014] = "ER_CANT_GET_WD";
  codes[1015] = "ER_CANT_LOCK";
  codes[1016] = "ER_CANT_OPEN_FILE";
  codes[1017] = "ER_FILE_NOT_FOUND";
  codes[1018] = "ER_CANT_READ_DIR";
  codes[1019] = "ER_CANT_SET_WD";
  codes[1020] = "ER_CHECKREAD";
  codes[1021] = "ER_DISK_FULL";
  codes[1022] = "ER_DUP_KEY";
  codes[1023] = "ER_ERROR_ON_CLOSE";
  codes[1024] = "ER_ERROR_ON_READ";
  codes[1025] = "ER_ERROR_ON_RENAME";
  codes[1026] = "ER_ERROR_ON_WRITE";
  codes[1027] = "ER_FILE_USED";
  codes[1028] = "ER_FILSORT_ABORT";
  codes[1029] = "ER_FORM_NOT_FOUND";
  codes[1030] = "ER_GET_ERRNO";
  codes[1031] = "ER_ILLEGAL_HA";
  codes[1032] = "ER_KEY_NOT_FOUND";
  codes[1033] = "ER_NOT_FORM_FILE";
  codes[1034] = "ER_NOT_KEYFILE";
  codes[1035] = "ER_OLD_KEYFILE";
  codes[1036] = "ER_OPEN_AS_READONLY";
  codes[1037] = "ER_OUTOFMEMORY";
  codes[1038] = "ER_OUT_OF_SORTMEMORY";
  codes[1039] = "ER_UNEXPECTED_EOF";
  codes[1040] = "ER_CON_COUNT_ERROR";
  codes[1041] = "ER_OUT_OF_RESOURCES";
  codes[1042] = "ER_BAD_HOST_ERROR";
  codes[1043] = "ER_HANDSHAKE_ERROR";
  codes[1044] = "ER_DBACCESS_DENIED_ERROR";
  codes[1045] = "ER_ACCESS_DENIED_ERROR";
  codes[1046] = "ER_NO_DB_ERROR";
  codes[1047] = "ER_UNKNOWN_COM_ERROR";
  codes[1048] = "ER_BAD_NULL_ERROR";
  codes[1049] = "ER_BAD_DB_ERROR";
  codes[1050] = "ER_TABLE_EXISTS_ERROR";
  codes[1051] = "ER_BAD_TABLE_ERROR";
  codes[1052] = "ER_NON_UNIQ_ERROR";
  codes[1053] = "ER_SERVER_SHUTDOWN";
  codes[1054] = "ER_BAD_FIELD_ERROR";
  codes[1055] = "ER_WRONG_FIELD_WITH_GROUP";
  codes[1056] = "ER_WRONG_GROUP_FIELD";
  codes[1057] = "ER_WRONG_SUM_SELECT";
  codes[1058] = "ER_WRONG_VALUE_COUNT";
  codes[1059] = "ER_TOO_LONG_IDENT";
  codes[1060] = "ER_DUP_FIELDNAME";
  codes[1061] = "ER_DUP_KEYNAME";
  codes[1062] = "ER_DUP_ENTRY";
  codes[1063] = "ER_WRONG_FIELD_SPEC";
  codes[1064] = "ER_PARSE_ERROR";
  codes[1065] = "ER_EMPTY_QUERY";
  codes[1066] = "ER_NONUNIQ_TABLE";
  codes[1067] = "ER_INVALID_DEFAULT";
  codes[1068] = "ER_MULTIPLE_PRI_KEY";
  codes[1069] = "ER_TOO_MANY_KEYS";
  codes[1070] = "ER_TOO_MANY_KEY_PARTS";
  codes[1071] = "ER_TOO_LONG_KEY";
  codes[1072] = "ER_KEY_COLUMN_DOES_NOT_EXIST";
  codes[1073] = "ER_BLOB_USED_AS_KEY";
  codes[1074] = "ER_TOO_BIG_FIELDLENGTH";
  codes[1075] = "ER_WRONG_AUTO_KEY";
  codes[1076] = "ER_BINLOG_CANT_DELETE_GTID_DOMAIN";
  codes[1077] = "ER_NORMAL_SHUTDOWN";
  codes[1078] = "ER_GOT_SIGNAL";
  codes[1079] = "ER_SHUTDOWN_COMPLETE";
  codes[1080] = "ER_FORCING_CLOSE";
  codes[1081] = "ER_IPSOCK_ERROR";
  codes[1082] = "ER_NO_SUCH_INDEX";
  codes[1083] = "ER_WRONG_FIELD_TERMINATORS";
  codes[1084] = "ER_BLOBS_AND_NO_TERMINATED";
  codes[1085] = "ER_TEXTFILE_NOT_READABLE";
  codes[1086] = "ER_FILE_EXISTS_ERROR";
  codes[1087] = "ER_LOAD_INFO";
  codes[1088] = "ER_ALTER_INFO";
  codes[1089] = "ER_WRONG_SUB_KEY";
  codes[1090] = "ER_CANT_REMOVE_ALL_FIELDS";
  codes[1091] = "ER_CANT_DROP_FIELD_OR_KEY";
  codes[1092] = "ER_INSERT_INFO";
  codes[1093] = "ER_UPDATE_TABLE_USED";
  codes[1094] = "ER_NO_SUCH_THREAD";
  codes[1095] = "ER_KILL_DENIED_ERROR";
  codes[1096] = "ER_NO_TABLES_USED";
  codes[1097] = "ER_TOO_BIG_SET";
  codes[1098] = "ER_NO_UNIQUE_LOGFILE";
  codes[1099] = "ER_TABLE_NOT_LOCKED_FOR_WRITE";
  codes[1100] = "ER_TABLE_NOT_LOCKED";
  codes[1101] = "ER_UNUSED_17";
  codes[1102] = "ER_WRONG_DB_NAME";
  codes[1103] = "ER_WRONG_TABLE_NAME";
  codes[1104] = "ER_TOO_BIG_SELECT";
  codes[1105] = "ER_UNKNOWN_ERROR";
  codes[1106] = "ER_UNKNOWN_PROCEDURE";
  codes[1107] = "ER_WRONG_PARAMCOUNT_TO_PROCEDURE";
  codes[1108] = "ER_WRONG_PARAMETERS_TO_PROCEDURE";
  codes[1109] = "ER_UNKNOWN_TABLE";
  codes[1110] = "ER_FIELD_SPECIFIED_TWICE";
  codes[1111] = "ER_INVALID_GROUP_FUNC_USE";
  codes[1112] = "ER_UNSUPPORTED_EXTENSION";
  codes[1113] = "ER_TABLE_MUST_HAVE_COLUMNS";
  codes[1114] = "ER_RECORD_FILE_FULL";
  codes[1115] = "ER_UNKNOWN_CHARACTER_SET";
  codes[1116] = "ER_TOO_MANY_TABLES";
  codes[1117] = "ER_TOO_MANY_FIELDS";
  codes[1118] = "ER_TOO_BIG_ROWSIZE";
  codes[1119] = "ER_STACK_OVERRUN";
  codes[1120] = "ER_WRONG_OUTER_JOIN";
  codes[1121] = "ER_NULL_COLUMN_IN_INDEX";
  codes[1122] = "ER_CANT_FIND_UDF";
  codes[1123] = "ER_CANT_INITIALIZE_UDF";
  codes[1124] = "ER_UDF_NO_PATHS";
  codes[1125] = "ER_UDF_EXISTS";
  codes[1126] = "ER_CANT_OPEN_LIBRARY";
  codes[1127] = "ER_CANT_FIND_DL_ENTRY";
  codes[1128] = "ER_FUNCTION_NOT_DEFINED";
  codes[1129] = "ER_HOST_IS_BLOCKED";
  codes[1130] = "ER_HOST_NOT_PRIVILEGED";
  codes[1131] = "ER_PASSWORD_ANONYMOUS_USER";
  codes[1132] = "ER_PASSWORD_NOT_ALLOWED";
  codes[1133] = "ER_PASSWORD_NO_MATCH";
  codes[1134] = "ER_UPDATE_INFO";
  codes[1135] = "ER_CANT_CREATE_THREAD";
  codes[1136] = "ER_WRONG_VALUE_COUNT_ON_ROW";
  codes[1137] = "ER_CANT_REOPEN_TABLE";
  codes[1138] = "ER_INVALID_USE_OF_NULL";
  codes[1139] = "ER_REGEXP_ERROR";
  codes[1140] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS";
  codes[1141] = "ER_NONEXISTING_GRANT";
  codes[1142] = "ER_TABLEACCESS_DENIED_ERROR";
  codes[1143] = "ER_COLUMNACCESS_DENIED_ERROR";
  codes[1144] = "ER_ILLEGAL_GRANT_FOR_TABLE";
  codes[1145] = "ER_GRANT_WRONG_HOST_OR_USER";
  codes[1146] = "ER_NO_SUCH_TABLE";
  codes[1147] = "ER_NONEXISTING_TABLE_GRANT";
  codes[1148] = "ER_NOT_ALLOWED_COMMAND";
  codes[1149] = "ER_SYNTAX_ERROR";
  codes[1150] = "ER_DELAYED_CANT_CHANGE_LOCK";
  codes[1151] = "ER_TOO_MANY_DELAYED_THREADS";
  codes[1152] = "ER_ABORTING_CONNECTION";
  codes[1153] = "ER_NET_PACKET_TOO_LARGE";
  codes[1154] = "ER_NET_READ_ERROR_FROM_PIPE";
  codes[1155] = "ER_NET_FCNTL_ERROR";
  codes[1156] = "ER_NET_PACKETS_OUT_OF_ORDER";
  codes[1157] = "ER_NET_UNCOMPRESS_ERROR";
  codes[1158] = "ER_NET_READ_ERROR";
  codes[1159] = "ER_NET_READ_INTERRUPTED";
  codes[1160] = "ER_NET_ERROR_ON_WRITE";
  codes[1161] = "ER_NET_WRITE_INTERRUPTED";
  codes[1162] = "ER_TOO_LONG_STRING";
  codes[1163] = "ER_TABLE_CANT_HANDLE_BLOB";
  codes[1164] = "ER_TABLE_CANT_HANDLE_AUTO_INCREMENT";
  codes[1165] = "ER_DELAYED_INSERT_TABLE_LOCKED";
  codes[1166] = "ER_WRONG_COLUMN_NAME";
  codes[1167] = "ER_WRONG_KEY_COLUMN";
  codes[1168] = "ER_WRONG_MRG_TABLE";
  codes[1169] = "ER_DUP_UNIQUE";
  codes[1170] = "ER_BLOB_KEY_WITHOUT_LENGTH";
  codes[1171] = "ER_PRIMARY_CANT_HAVE_NULL";
  codes[1172] = "ER_TOO_MANY_ROWS";
  codes[1173] = "ER_REQUIRES_PRIMARY_KEY";
  codes[1174] = "ER_NO_RAID_COMPILED";
  codes[1175] = "ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE";
  codes[1176] = "ER_KEY_DOES_NOT_EXISTS";
  codes[1177] = "ER_CHECK_NO_SUCH_TABLE";
  codes[1178] = "ER_CHECK_NOT_IMPLEMENTED";
  codes[1179] = "ER_CANT_DO_THIS_DURING_AN_TRANSACTION";
  codes[1180] = "ER_ERROR_DURING_COMMIT";
  codes[1181] = "ER_ERROR_DURING_ROLLBACK";
  codes[1182] = "ER_ERROR_DURING_FLUSH_LOGS";
  codes[1183] = "ER_ERROR_DURING_CHECKPOINT";
  codes[1184] = "ER_NEW_ABORTING_CONNECTION";
  codes[1185] = "ER_UNUSED_10";
  codes[1186] = "ER_FLUSH_MASTER_BINLOG_CLOSED";
  codes[1187] = "ER_INDEX_REBUILD";
  codes[1188] = "ER_MASTER";
  codes[1189] = "ER_MASTER_NET_READ";
  codes[1190] = "ER_MASTER_NET_WRITE";
  codes[1191] = "ER_FT_MATCHING_KEY_NOT_FOUND";
  codes[1192] = "ER_LOCK_OR_ACTIVE_TRANSACTION";
  codes[1193] = "ER_UNKNOWN_SYSTEM_VARIABLE";
  codes[1194] = "ER_CRASHED_ON_USAGE";
  codes[1195] = "ER_CRASHED_ON_REPAIR";
  codes[1196] = "ER_WARNING_NOT_COMPLETE_ROLLBACK";
  codes[1197] = "ER_TRANS_CACHE_FULL";
  codes[1198] = "ER_SLAVE_MUST_STOP";
  codes[1199] = "ER_SLAVE_NOT_RUNNING";
  codes[1200] = "ER_BAD_SLAVE";
  codes[1201] = "ER_MASTER_INFO";
  codes[1202] = "ER_SLAVE_THREAD";
  codes[1203] = "ER_TOO_MANY_USER_CONNECTIONS";
  codes[1204] = "ER_SET_CONSTANTS_ONLY";
  codes[1205] = "ER_LOCK_WAIT_TIMEOUT";
  codes[1206] = "ER_LOCK_TABLE_FULL";
  codes[1207] = "ER_READ_ONLY_TRANSACTION";
  codes[1208] = "ER_DROP_DB_WITH_READ_LOCK";
  codes[1209] = "ER_CREATE_DB_WITH_READ_LOCK";
  codes[1210] = "ER_WRONG_ARGUMENTS";
  codes[1211] = "ER_NO_PERMISSION_TO_CREATE_USER";
  codes[1212] = "ER_UNION_TABLES_IN_DIFFERENT_DIR";
  codes[1213] = "ER_LOCK_DEADLOCK";
  codes[1214] = "ER_TABLE_CANT_HANDLE_FT";
  codes[1215] = "ER_CANNOT_ADD_FOREIGN";
  codes[1216] = "ER_NO_REFERENCED_ROW";
  codes[1217] = "ER_ROW_IS_REFERENCED";
  codes[1218] = "ER_CONNECT_TO_MASTER";
  codes[1219] = "ER_QUERY_ON_MASTER";
  codes[1220] = "ER_ERROR_WHEN_EXECUTING_COMMAND";
  codes[1221] = "ER_WRONG_USAGE";
  codes[1222] = "ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT";
  codes[1223] = "ER_CANT_UPDATE_WITH_READLOCK";
  codes[1224] = "ER_MIXING_NOT_ALLOWED";
  codes[1225] = "ER_DUP_ARGUMENT";
  codes[1226] = "ER_USER_LIMIT_REACHED";
  codes[1227] = "ER_SPECIFIC_ACCESS_DENIED_ERROR";
  codes[1228] = "ER_LOCAL_VARIABLE";
  codes[1229] = "ER_GLOBAL_VARIABLE";
  codes[1230] = "ER_NO_DEFAULT";
  codes[1231] = "ER_WRONG_VALUE_FOR_VAR";
  codes[1232] = "ER_WRONG_TYPE_FOR_VAR";
  codes[1233] = "ER_VAR_CANT_BE_READ";
  codes[1234] = "ER_CANT_USE_OPTION_HERE";
  codes[1235] = "ER_NOT_SUPPORTED_YET";
  codes[1236] = "ER_MASTER_FATAL_ERROR_READING_BINLOG";
  codes[1237] = "ER_SLAVE_IGNORED_TABLE";
  codes[1238] = "ER_INCORRECT_GLOBAL_LOCAL_VAR";
  codes[1239] = "ER_WRONG_FK_DEF";
  codes[1240] = "ER_KEY_REF_DO_NOT_MATCH_TABLE_REF";
  codes[1241] = "ER_OPERAND_COLUMNS";
  codes[1242] = "ER_SUBQUERY_NO_1_ROW";
  codes[1243] = "ER_UNKNOWN_STMT_HANDLER";
  codes[1244] = "ER_CORRUPT_HELP_DB";
  codes[1245] = "ER_CYCLIC_REFERENCE";
  codes[1246] = "ER_AUTO_CONVERT";
  codes[1247] = "ER_ILLEGAL_REFERENCE";
  codes[1248] = "ER_DERIVED_MUST_HAVE_ALIAS";
  codes[1249] = "ER_SELECT_REDUCED";
  codes[1250] = "ER_TABLENAME_NOT_ALLOWED_HERE";
  codes[1251] = "ER_NOT_SUPPORTED_AUTH_MODE";
  codes[1252] = "ER_SPATIAL_CANT_HAVE_NULL";
  codes[1253] = "ER_COLLATION_CHARSET_MISMATCH";
  codes[1254] = "ER_SLAVE_WAS_RUNNING";
  codes[1255] = "ER_SLAVE_WAS_NOT_RUNNING";
  codes[1256] = "ER_TOO_BIG_FOR_UNCOMPRESS";
  codes[1257] = "ER_ZLIB_Z_MEM_ERROR";
  codes[1258] = "ER_ZLIB_Z_BUF_ERROR";
  codes[1259] = "ER_ZLIB_Z_DATA_ERROR";
  codes[1260] = "ER_CUT_VALUE_GROUP_CONCAT";
  codes[1261] = "ER_WARN_TOO_FEW_RECORDS";
  codes[1262] = "ER_WARN_TOO_MANY_RECORDS";
  codes[1263] = "ER_WARN_NULL_TO_NOTNULL";
  codes[1264] = "ER_WARN_DATA_OUT_OF_RANGE";
  codes[1265] = "WARN_DATA_TRUNCATED";
  codes[1266] = "ER_WARN_USING_OTHER_HANDLER";
  codes[1267] = "ER_CANT_AGGREGATE_2COLLATIONS";
  codes[1268] = "ER_DROP_USER";
  codes[1269] = "ER_REVOKE_GRANTS";
  codes[1270] = "ER_CANT_AGGREGATE_3COLLATIONS";
  codes[1271] = "ER_CANT_AGGREGATE_NCOLLATIONS";
  codes[1272] = "ER_VARIABLE_IS_NOT_STRUCT";
  codes[1273] = "ER_UNKNOWN_COLLATION";
  codes[1274] = "ER_SLAVE_IGNORED_SSL_PARAMS";
  codes[1275] = "ER_SERVER_IS_IN_SECURE_AUTH_MODE";
  codes[1276] = "ER_WARN_FIELD_RESOLVED";
  codes[1277] = "ER_BAD_SLAVE_UNTIL_COND";
  codes[1278] = "ER_MISSING_SKIP_SLAVE";
  codes[1279] = "ER_UNTIL_COND_IGNORED";
  codes[1280] = "ER_WRONG_NAME_FOR_INDEX";
  codes[1281] = "ER_WRONG_NAME_FOR_CATALOG";
  codes[1282] = "ER_WARN_QC_RESIZE";
  codes[1283] = "ER_BAD_FT_COLUMN";
  codes[1284] = "ER_UNKNOWN_KEY_CACHE";
  codes[1285] = "ER_WARN_HOSTNAME_WONT_WORK";
  codes[1286] = "ER_UNKNOWN_STORAGE_ENGINE";
  codes[1287] = "ER_WARN_DEPRECATED_SYNTAX";
  codes[1288] = "ER_NON_UPDATABLE_TABLE";
  codes[1289] = "ER_FEATURE_DISABLED";
  codes[1290] = "ER_OPTION_PREVENTS_STATEMENT";
  codes[1291] = "ER_DUPLICATED_VALUE_IN_TYPE";
  codes[1292] = "ER_TRUNCATED_WRONG_VALUE";
  codes[1293] = "ER_TOO_MUCH_AUTO_TIMESTAMP_COLS";
  codes[1294] = "ER_INVALID_ON_UPDATE";
  codes[1295] = "ER_UNSUPPORTED_PS";
  codes[1296] = "ER_GET_ERRMSG";
  codes[1297] = "ER_GET_TEMPORARY_ERRMSG";
  codes[1298] = "ER_UNKNOWN_TIME_ZONE";
  codes[1299] = "ER_WARN_INVALID_TIMESTAMP";
  codes[1300] = "ER_INVALID_CHARACTER_STRING";
  codes[1301] = "ER_WARN_ALLOWED_PACKET_OVERFLOWED";
  codes[1302] = "ER_CONFLICTING_DECLARATIONS";
  codes[1303] = "ER_SP_NO_RECURSIVE_CREATE";
  codes[1304] = "ER_SP_ALREADY_EXISTS";
  codes[1305] = "ER_SP_DOES_NOT_EXIST";
  codes[1306] = "ER_SP_DROP_FAILED";
  codes[1307] = "ER_SP_STORE_FAILED";
  codes[1308] = "ER_SP_LILABEL_MISMATCH";
  codes[1309] = "ER_SP_LABEL_REDEFINE";
  codes[1310] = "ER_SP_LABEL_MISMATCH";
  codes[1311] = "ER_SP_UNINIT_VAR";
  codes[1312] = "ER_SP_BADSELECT";
  codes[1313] = "ER_SP_BADRETURN";
  codes[1314] = "ER_SP_BADSTATEMENT";
  codes[1315] = "ER_UPDATE_LOG_DEPRECATED_IGNORED";
  codes[1316] = "ER_UPDATE_LOG_DEPRECATED_TRANSLATED";
  codes[1317] = "ER_QUERY_INTERRUPTED";
  codes[1318] = "ER_SP_WRONG_NO_OF_ARGS";
  codes[1319] = "ER_SP_COND_MISMATCH";
  codes[1320] = "ER_SP_NORETURN";
  codes[1321] = "ER_SP_NORETURNEND";
  codes[1322] = "ER_SP_BAD_CURSOR_QUERY";
  codes[1323] = "ER_SP_BAD_CURSOR_SELECT";
  codes[1324] = "ER_SP_CURSOR_MISMATCH";
  codes[1325] = "ER_SP_CURSOR_ALREADY_OPEN";
  codes[1326] = "ER_SP_CURSOR_NOT_OPEN";
  codes[1327] = "ER_SP_UNDECLARED_VAR";
  codes[1328] = "ER_SP_WRONG_NO_OF_FETCH_ARGS";
  codes[1329] = "ER_SP_FETCH_NO_DATA";
  codes[1330] = "ER_SP_DUP_PARAM";
  codes[1331] = "ER_SP_DUP_VAR";
  codes[1332] = "ER_SP_DUP_COND";
  codes[1333] = "ER_SP_DUP_CURS";
  codes[1334] = "ER_SP_CANT_ALTER";
  codes[1335] = "ER_SP_SUBSELECT_NYI";
  codes[1336] = "ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG";
  codes[1337] = "ER_SP_VARCOND_AFTER_CURSHNDLR";
  codes[1338] = "ER_SP_CURSOR_AFTER_HANDLER";
  codes[1339] = "ER_SP_CASE_NOT_FOUND";
  codes[1340] = "ER_FPARSER_TOO_BIG_FILE";
  codes[1341] = "ER_FPARSER_BAD_HEADER";
  codes[1342] = "ER_FPARSER_EOF_IN_COMMENT";
  codes[1343] = "ER_FPARSER_ERROR_IN_PARAMETER";
  codes[1344] = "ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER";
  codes[1345] = "ER_VIEW_NO_EXPLAIN";
  codes[1346] = "ER_FRM_UNKNOWN_TYPE";
  codes[1347] = "ER_WRONG_OBJECT";
  codes[1348] = "ER_NONUPDATEABLE_COLUMN";
  codes[1349] = "ER_VIEW_SELECT_DERIVED";
  codes[1350] = "ER_VIEW_SELECT_CLAUSE";
  codes[1351] = "ER_VIEW_SELECT_VARIABLE";
  codes[1352] = "ER_VIEW_SELECT_TMPTABLE";
  codes[1353] = "ER_VIEW_WRONG_LIST";
  codes[1354] = "ER_WARN_VIEW_MERGE";
  codes[1355] = "ER_WARN_VIEW_WITHOUT_KEY";
  codes[1356] = "ER_VIEW_INVALID";
  codes[1357] = "ER_SP_NO_DROP_SP";
  codes[1358] = "ER_SP_GOTO_IN_HNDLR";
  codes[1359] = "ER_TRG_ALREADY_EXISTS";
  codes[1360] = "ER_TRG_DOES_NOT_EXIST";
  codes[1361] = "ER_TRG_ON_VIEW_OR_TEMP_TABLE";
  codes[1362] = "ER_TRG_CANT_CHANGE_ROW";
  codes[1363] = "ER_TRG_NO_SUCH_ROW_IN_TRG";
  codes[1364] = "ER_NO_DEFAULT_FOR_FIELD";
  codes[1365] = "ER_DIVISION_BY_ZERO";
  codes[1366] = "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD";
  codes[1367] = "ER_ILLEGAL_VALUE_FOR_TYPE";
  codes[1368] = "ER_VIEW_NONUPD_CHECK";
  codes[1369] = "ER_VIEW_CHECK_FAILED";
  codes[1370] = "ER_PROCACCESS_DENIED_ERROR";
  codes[1371] = "ER_RELAY_LOG_FAIL";
  codes[1372] = "ER_PASSWD_LENGTH";
  codes[1373] = "ER_UNKNOWN_TARGET_BINLOG";
  codes[1374] = "ER_IO_ERR_LOG_INDEX_READ";
  codes[1375] = "ER_BINLOG_PURGE_PROHIBITED";
  codes[1376] = "ER_FSEEK_FAIL";
  codes[1377] = "ER_BINLOG_PURGE_FATAL_ERR";
  codes[1378] = "ER_LOG_IN_USE";
  codes[1379] = "ER_LOG_PURGE_UNKNOWN_ERR";
  codes[1380] = "ER_RELAY_LOG_INIT";
  codes[1381] = "ER_NO_BINARY_LOGGING";
  codes[1382] = "ER_RESERVED_SYNTAX";
  codes[1383] = "ER_WSAS_FAILED";
  codes[1384] = "ER_DIFF_GROUPS_PROC";
  codes[1385] = "ER_NO_GROUP_FOR_PROC";
  codes[1386] = "ER_ORDER_WITH_PROC";
  codes[1387] = "ER_LOGGING_PROHIBIT_CHANGING_OF";
  codes[1388] = "ER_NO_FILE_MAPPING";
  codes[1389] = "ER_WRONG_MAGIC";
  codes[1390] = "ER_PS_MANY_PARAM";
  codes[1391] = "ER_KEY_PART_0";
  codes[1392] = "ER_VIEW_CHECKSUM";
  codes[1393] = "ER_VIEW_MULTIUPDATE";
  codes[1394] = "ER_VIEW_NO_INSERT_FIELD_LIST";
  codes[1395] = "ER_VIEW_DELETE_MERGE_VIEW";
  codes[1396] = "ER_CANNOT_USER";
  codes[1397] = "ER_XAER_NOTA";
  codes[1398] = "ER_XAER_INVAL";
  codes[1399] = "ER_XAER_RMFAIL";
  codes[1400] = "ER_XAER_OUTSIDE";
  codes[1401] = "ER_XAER_RMERR";
  codes[1402] = "ER_XA_RBROLLBACK";
  codes[1403] = "ER_NONEXISTING_PROC_GRANT";
  codes[1404] = "ER_PROC_AUTO_GRANT_FAIL";
  codes[1405] = "ER_PROC_AUTO_REVOKE_FAIL";
  codes[1406] = "ER_DATA_TOO_LONG";
  codes[1407] = "ER_SP_BAD_SQLSTATE";
  codes[1408] = "ER_STARTUP";
  codes[1409] = "ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR";
  codes[1410] = "ER_CANT_CREATE_USER_WITH_GRANT";
  codes[1411] = "ER_WRONG_VALUE_FOR_TYPE";
  codes[1412] = "ER_TABLE_DEF_CHANGED";
  codes[1413] = "ER_SP_DUP_HANDLER";
  codes[1414] = "ER_SP_NOT_VAR_ARG";
  codes[1415] = "ER_SP_NO_RETSET";
  codes[1416] = "ER_CANT_CREATE_GEOMETRY_OBJECT";
  codes[1417] = "ER_FAILED_ROUTINE_BREAK_BINLOG";
  codes[1418] = "ER_BINLOG_UNSAFE_ROUTINE";
  codes[1419] = "ER_BINLOG_CREATE_ROUTINE_NEED_SUPER";
  codes[1420] = "ER_EXEC_STMT_WITH_OPEN_CURSOR";
  codes[1421] = "ER_STMT_HAS_NO_OPEN_CURSOR";
  codes[1422] = "ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG";
  codes[1423] = "ER_NO_DEFAULT_FOR_VIEW_FIELD";
  codes[1424] = "ER_SP_NO_RECURSION";
  codes[1425] = "ER_TOO_BIG_SCALE";
  codes[1426] = "ER_TOO_BIG_PRECISION";
  codes[1427] = "ER_M_BIGGER_THAN_D";
  codes[1428] = "ER_WRONG_LOCK_OF_SYSTEM_TABLE";
  codes[1429] = "ER_CONNECT_TO_FOREIGN_DATA_SOURCE";
  codes[1430] = "ER_QUERY_ON_FOREIGN_DATA_SOURCE";
  codes[1431] = "ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST";
  codes[1432] = "ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE";
  codes[1433] = "ER_FOREIGN_DATA_STRING_INVALID";
  codes[1434] = "ER_CANT_CREATE_FEDERATED_TABLE";
  codes[1435] = "ER_TRG_IN_WRONG_SCHEMA";
  codes[1436] = "ER_STACK_OVERRUN_NEED_MORE";
  codes[1437] = "ER_TOO_LONG_BODY";
  codes[1438] = "ER_WARN_CANT_DROP_DEFAULT_KEYCACHE";
  codes[1439] = "ER_TOO_BIG_DISPLAYWIDTH";
  codes[1440] = "ER_XAER_DUPID";
  codes[1441] = "ER_DATETIME_FUNCTION_OVERFLOW";
  codes[1442] = "ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG";
  codes[1443] = "ER_VIEW_PREVENT_UPDATE";
  codes[1444] = "ER_PS_NO_RECURSION";
  codes[1445] = "ER_SP_CANT_SET_AUTOCOMMIT";
  codes[1446] = "ER_MALFORMED_DEFINER";
  codes[1447] = "ER_VIEW_FRM_NO_USER";
  codes[1448] = "ER_VIEW_OTHER_USER";
  codes[1449] = "ER_NO_SUCH_USER";
  codes[1450] = "ER_FORBID_SCHEMA_CHANGE";
  codes[1451] = "ER_ROW_IS_REFERENCED_2";
  codes[1452] = "ER_NO_REFERENCED_ROW_2";
  codes[1453] = "ER_SP_BAD_VAR_SHADOW";
  codes[1454] = "ER_TRG_NO_DEFINER";
  codes[1455] = "ER_OLD_FILE_FORMAT";
  codes[1456] = "ER_SP_RECURSION_LIMIT";
  codes[1457] = "ER_SP_PROC_TABLE_CORRUPT";
  codes[1458] = "ER_SP_WRONG_NAME";
  codes[1459] = "ER_TABLE_NEEDS_UPGRADE";
  codes[1460] = "ER_SP_NO_AGGREGATE";
  codes[1461] = "ER_MAX_PREPARED_STMT_COUNT_REACHED";
  codes[1462] = "ER_VIEW_RECURSIVE";
  codes[1463] = "ER_NON_GROUPING_FIELD_USED";
  codes[1464] = "ER_TABLE_CANT_HANDLE_SPKEYS";
  codes[1465] = "ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA";
  codes[1466] = "ER_REMOVED_SPACES";
  codes[1467] = "ER_AUTOINC_READ_FAILED";
  codes[1468] = "ER_USERNAME";
  codes[1469] = "ER_HOSTNAME";
  codes[1470] = "ER_WRONG_STRING_LENGTH";
  codes[1471] = "ER_NON_INSERTABLE_TABLE";
  codes[1472] = "ER_ADMIN_WRONG_MRG_TABLE";
  codes[1473] = "ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT";
  codes[1474] = "ER_NAME_BECOMES_EMPTY";
  codes[1475] = "ER_AMBIGUOUS_FIELD_TERM";
  codes[1476] = "ER_FOREIGN_SERVER_EXISTS";
  codes[1477] = "ER_FOREIGN_SERVER_DOESNT_EXIST";
  codes[1478] = "ER_ILLEGAL_HA_CREATE_OPTION";
  codes[1479] = "ER_PARTITION_REQUIRES_VALUES_ERROR";
  codes[1480] = "ER_PARTITION_WRONG_VALUES_ERROR";
  codes[1481] = "ER_PARTITION_MAXVALUE_ERROR";
  codes[1482] = "ER_PARTITION_SUBPARTITION_ERROR";
  codes[1483] = "ER_PARTITION_SUBPART_MIX_ERROR";
  codes[1484] = "ER_PARTITION_WRONG_NO_PART_ERROR";
  codes[1485] = "ER_PARTITION_WRONG_NO_SUBPART_ERROR";
  codes[1486] = "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR";
  codes[1487] = "ER_NOT_CONSTANT_EXPRESSION";
  codes[1488] = "ER_FIELD_NOT_FOUND_PART_ERROR";
  codes[1489] = "ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR";
  codes[1490] = "ER_INCONSISTENT_PARTITION_INFO_ERROR";
  codes[1491] = "ER_PARTITION_FUNC_NOT_ALLOWED_ERROR";
  codes[1492] = "ER_PARTITIONS_MUST_BE_DEFINED_ERROR";
  codes[1493] = "ER_RANGE_NOT_INCREASING_ERROR";
  codes[1494] = "ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR";
  codes[1495] = "ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR";
  codes[1496] = "ER_PARTITION_ENTRY_ERROR";
  codes[1497] = "ER_MIX_HANDLER_ERROR";
  codes[1498] = "ER_PARTITION_NOT_DEFINED_ERROR";
  codes[1499] = "ER_TOO_MANY_PARTITIONS_ERROR";
  codes[1500] = "ER_SUBPARTITION_ERROR";
  codes[1501] = "ER_CANT_CREATE_HANDLER_FILE";
  codes[1502] = "ER_BLOB_FIELD_IN_PART_FUNC_ERROR";
  codes[1503] = "ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF";
  codes[1504] = "ER_NO_PARTS_ERROR";
  codes[1505] = "ER_PARTITION_MGMT_ON_NONPARTITIONED";
  codes[1506] = "ER_FEATURE_NOT_SUPPORTED_WITH_PARTITIONING";
  codes[1507] = "ER_PARTITION_DOES_NOT_EXIST";
  codes[1508] = "ER_DROP_LAST_PARTITION";
  codes[1509] = "ER_COALESCE_ONLY_ON_HASH_PARTITION";
  codes[1510] = "ER_REORG_HASH_ONLY_ON_SAME_NO";
  codes[1511] = "ER_REORG_NO_PARAM_ERROR";
  codes[1512] = "ER_ONLY_ON_RANGE_LIST_PARTITION";
  codes[1513] = "ER_ADD_PARTITION_SUBPART_ERROR";
  codes[1514] = "ER_ADD_PARTITION_NO_NEW_PARTITION";
  codes[1515] = "ER_COALESCE_PARTITION_NO_PARTITION";
  codes[1516] = "ER_REORG_PARTITION_NOT_EXIST";
  codes[1517] = "ER_SAME_NAME_PARTITION";
  codes[1518] = "ER_NO_BINLOG_ERROR";
  codes[1519] = "ER_CONSECUTIVE_REORG_PARTITIONS";
  codes[1520] = "ER_REORG_OUTSIDE_RANGE";
  codes[1521] = "ER_PARTITION_FUNCTION_FAILURE";
  codes[1522] = "ER_PART_STATE_ERROR";
  codes[1523] = "ER_LIMITED_PART_RANGE";
  codes[1524] = "ER_PLUGIN_IS_NOT_LOADED";
  codes[1525] = "ER_WRONG_VALUE";
  codes[1526] = "ER_NO_PARTITION_FOR_GIVEN_VALUE";
  codes[1527] = "ER_FILEGROUP_OPTION_ONLY_ONCE";
  codes[1528] = "ER_CREATE_FILEGROUP_FAILED";
  codes[1529] = "ER_DROP_FILEGROUP_FAILED";
  codes[1530] = "ER_TABLESPACE_AUTO_EXTEND_ERROR";
  codes[1531] = "ER_WRONG_SIZE_NUMBER";
  codes[1532] = "ER_SIZE_OVERFLOW_ERROR";
  codes[1533] = "ER_ALTER_FILEGROUP_FAILED";
  codes[1534] = "ER_BINLOG_ROW_LOGGING_FAILED";
  codes[1535] = "ER_BINLOG_ROW_WRONG_TABLE_DEF";
  codes[1536] = "ER_BINLOG_ROW_RBR_TO_SBR";
  codes[1537] = "ER_EVENT_ALREADY_EXISTS";
  codes[1538] = "ER_EVENT_STORE_FAILED";
  codes[1539] = "ER_EVENT_DOES_NOT_EXIST";
  codes[1540] = "ER_EVENT_CANT_ALTER";
  codes[1541] = "ER_EVENT_DROP_FAILED";
  codes[1542] = "ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG";
  codes[1543] = "ER_EVENT_ENDS_BEFORE_STARTS";
  codes[1544] = "ER_EVENT_EXEC_TIME_IN_THE_PAST";
  codes[1545] = "ER_EVENT_OPEN_TABLE_FAILED";
  codes[1546] = "ER_EVENT_NEITHER_M_EXPR_NOR_M_AT";
  codes[1547] = "ER_UNUSED_2";
  codes[1548] = "ER_UNUSED_3";
  codes[1549] = "ER_EVENT_CANNOT_DELETE";
  codes[1550] = "ER_EVENT_COMPILE_ERROR";
  codes[1551] = "ER_EVENT_SAME_NAME";
  codes[1552] = "ER_EVENT_DATA_TOO_LONG";
  codes[1553] = "ER_DROP_INDEX_FK";
  codes[1554] = "ER_WARN_DEPRECATED_SYNTAX_WITH_VER";
  codes[1555] = "ER_CANT_WRITE_LOCK_LOG_TABLE";
  codes[1556] = "ER_CANT_LOCK_LOG_TABLE";
  codes[1557] = "ER_UNUSED_4";
  codes[1558] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE";
  codes[1559] = "ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR";
  codes[1560] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT";
  codes[1561] = "ER_UNUSED_13";
  codes[1562] = "ER_PARTITION_NO_TEMPORARY";
  codes[1563] = "ER_PARTITION_CONST_DOMAIN_ERROR";
  codes[1564] = "ER_PARTITION_FUNCTION_IS_NOT_ALLOWED";
  codes[1565] = "ER_DDL_LOG_ERROR";
  codes[1566] = "ER_NULL_IN_VALUES_LESS_THAN";
  codes[1567] = "ER_WRONG_PARTITION_NAME";
  codes[1568] = "ER_CANT_CHANGE_TX_CHARACTERISTICS";
  codes[1569] = "ER_DUP_ENTRY_AUTOINCREMENT_CASE";
  codes[1570] = "ER_EVENT_MODIFY_QUEUE_ERROR";
  codes[1571] = "ER_EVENT_SET_VAR_ERROR";
  codes[1572] = "ER_PARTITION_MERGE_ERROR";
  codes[1573] = "ER_CANT_ACTIVATE_LOG";
  codes[1574] = "ER_RBR_NOT_AVAILABLE";
  codes[1575] = "ER_BASE64_DECODE_ERROR";
  codes[1576] = "ER_EVENT_RECURSION_FORBIDDEN";
  codes[1577] = "ER_EVENTS_DB_ERROR";
  codes[1578] = "ER_ONLY_INTEGERS_ALLOWED";
  codes[1579] = "ER_UNSUPORTED_LOG_ENGINE";
  codes[1580] = "ER_BAD_LOG_STATEMENT";
  codes[1581] = "ER_CANT_RENAME_LOG_TABLE";
  codes[1582] = "ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT";
  codes[1583] = "ER_WRONG_PARAMETERS_TO_NATIVE_FCT";
  codes[1584] = "ER_WRONG_PARAMETERS_TO_STORED_FCT";
  codes[1585] = "ER_NATIVE_FCT_NAME_COLLISION";
  codes[1586] = "ER_DUP_ENTRY_WITH_KEY_NAME";
  codes[1587] = "ER_BINLOG_PURGE_EMFILE";
  codes[1588] = "ER_EVENT_CANNOT_CREATE_IN_THE_PAST";
  codes[1589] = "ER_EVENT_CANNOT_ALTER_IN_THE_PAST";
  codes[1590] = "ER_SLAVE_INCIDENT";
  codes[1591] = "ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT";
  codes[1592] = "ER_BINLOG_UNSAFE_STATEMENT";
  codes[1593] = "ER_SLAVE_FATAL_ERROR";
  codes[1594] = "ER_SLAVE_RELAY_LOG_READ_FAILURE";
  codes[1595] = "ER_SLAVE_RELAY_LOG_WRITE_FAILURE";
  codes[1596] = "ER_SLAVE_CREATE_EVENT_FAILURE";
  codes[1597] = "ER_SLAVE_MASTER_COM_FAILURE";
  codes[1598] = "ER_BINLOG_LOGGING_IMPOSSIBLE";
  codes[1599] = "ER_VIEW_NO_CREATION_CTX";
  codes[1600] = "ER_VIEW_INVALID_CREATION_CTX";
  codes[1601] = "ER_SR_INVALID_CREATION_CTX";
  codes[1602] = "ER_TRG_CORRUPTED_FILE";
  codes[1603] = "ER_TRG_NO_CREATION_CTX";
  codes[1604] = "ER_TRG_INVALID_CREATION_CTX";
  codes[1605] = "ER_EVENT_INVALID_CREATION_CTX";
  codes[1606] = "ER_TRG_CANT_OPEN_TABLE";
  codes[1607] = "ER_CANT_CREATE_SROUTINE";
  codes[1608] = "ER_UNUSED_11";
  codes[1609] = "ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT";
  codes[1610] = "ER_SLAVE_CORRUPT_EVENT";
  codes[1611] = "ER_LOAD_DATA_INVALID_COLUMN";
  codes[1612] = "ER_LOG_PURGE_NO_FILE";
  codes[1613] = "ER_XA_RBTIMEOUT";
  codes[1614] = "ER_XA_RBDEADLOCK";
  codes[1615] = "ER_NEED_REPREPARE";
  codes[1616] = "ER_DELAYED_NOT_SUPPORTED";
  codes[1617] = "WARN_NO_MASTER_INFO";
  codes[1618] = "WARN_OPTION_IGNORED";
  codes[1619] = "ER_PLUGIN_DELETE_BUILTIN";
  codes[1620] = "WARN_PLUGIN_BUSY";
  codes[1621] = "ER_VARIABLE_IS_READONLY";
  codes[1622] = "ER_WARN_ENGINE_TRANSACTION_ROLLBACK";
  codes[1623] = "ER_SLAVE_HEARTBEAT_FAILURE";
  codes[1624] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE";
  codes[1625] = "ER_UNUSED_14";
  codes[1626] = "ER_CONFLICT_FN_PARSE_ERROR";
  codes[1627] = "ER_EXCEPTIONS_WRITE_ERROR";
  codes[1628] = "ER_TOO_LONG_TABLE_COMMENT";
  codes[1629] = "ER_TOO_LONG_FIELD_COMMENT";
  codes[1630] = "ER_FUNC_INEXISTENT_NAME_COLLISION";
  codes[1631] = "ER_DATABASE_NAME";
  codes[1632] = "ER_TABLE_NAME";
  codes[1633] = "ER_PARTITION_NAME";
  codes[1634] = "ER_SUBPARTITION_NAME";
  codes[1635] = "ER_TEMPORARY_NAME";
  codes[1636] = "ER_RENAMED_NAME";
  codes[1637] = "ER_TOO_MANY_CONCURRENT_TRXS";
  codes[1638] = "WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED";
  codes[1639] = "ER_DEBUG_SYNC_TIMEOUT";
  codes[1640] = "ER_DEBUG_SYNC_HIT_LIMIT";
  codes[1641] = "ER_DUP_SIGNAL_SET";
  codes[1642] = "ER_SIGNAL_WARN";
  codes[1643] = "ER_SIGNAL_NOT_FOUND";
  codes[1644] = "ER_SIGNAL_EXCEPTION";
  codes[1645] = "ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER";
  codes[1646] = "ER_SIGNAL_BAD_CONDITION_TYPE";
  codes[1647] = "WARN_COND_ITEM_TRUNCATED";
  codes[1648] = "ER_COND_ITEM_TOO_LONG";
  codes[1649] = "ER_UNKNOWN_LOCALE";
  codes[1650] = "ER_SLAVE_IGNORE_SERVER_IDS";
  codes[1651] = "ER_QUERY_CACHE_DISABLED";
  codes[1652] = "ER_SAME_NAME_PARTITION_FIELD";
  codes[1653] = "ER_PARTITION_COLUMN_LIST_ERROR";
  codes[1654] = "ER_WRONG_TYPE_COLUMN_VALUE_ERROR";
  codes[1655] = "ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR";
  codes[1656] = "ER_MAXVALUE_IN_VALUES_IN";
  codes[1657] = "ER_TOO_MANY_VALUES_ERROR";
  codes[1658] = "ER_ROW_SINGLE_PARTITION_FIELD_ERROR";
  codes[1659] = "ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD";
  codes[1660] = "ER_PARTITION_FIELDS_TOO_LONG";
  codes[1661] = "ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE";
  codes[1662] = "ER_BINLOG_ROW_MODE_AND_STMT_ENGINE";
  codes[1663] = "ER_BINLOG_UNSAFE_AND_STMT_ENGINE";
  codes[1664] = "ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE";
  codes[1665] = "ER_BINLOG_STMT_MODE_AND_ROW_ENGINE";
  codes[1666] = "ER_BINLOG_ROW_INJECTION_AND_STMT_MODE";
  codes[1667] = "ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
  codes[1668] = "ER_BINLOG_UNSAFE_LIMIT";
  codes[1669] = "ER_BINLOG_UNSAFE_INSERT_DELAYED";
  codes[1670] = "ER_BINLOG_UNSAFE_SYSTEM_TABLE";
  codes[1671] = "ER_BINLOG_UNSAFE_AUTOINC_COLUMNS";
  codes[1672] = "ER_BINLOG_UNSAFE_UDF";
  codes[1673] = "ER_BINLOG_UNSAFE_SYSTEM_VARIABLE";
  codes[1674] = "ER_BINLOG_UNSAFE_SYSTEM_FUNCTION";
  codes[1675] = "ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS";
  codes[1676] = "ER_MESSAGE_AND_STATEMENT";
  codes[1677] = "ER_SLAVE_CONVERSION_FAILED";
  codes[1678] = "ER_SLAVE_CANT_CREATE_CONVERSION";
  codes[1679] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT";
  codes[1680] = "ER_PATH_LENGTH";
  codes[1681] = "ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT";
  codes[1682] = "ER_WRONG_NATIVE_TABLE_STRUCTURE";
  codes[1683] = "ER_WRONG_PERFSCHEMA_USAGE";
  codes[1684] = "ER_WARN_I_S_SKIPPED_TABLE";
  codes[1685] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT";
  codes[1686] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT";
  codes[1687] = "ER_SPATIAL_MUST_HAVE_GEOM_COL";
  codes[1688] = "ER_TOO_LONG_INDEX_COMMENT";
  codes[1689] = "ER_LOCK_ABORTED";
  codes[1690] = "ER_DATA_OUT_OF_RANGE";
  codes[1691] = "ER_WRONG_SPVAR_TYPE_IN_LIMIT";
  codes[1692] = "ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
  codes[1693] = "ER_BINLOG_UNSAFE_MIXED_STATEMENT";
  codes[1694] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN";
  codes[1695] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN";
  codes[1696] = "ER_FAILED_READ_FROM_PAR_FILE";
  codes[1697] = "ER_VALUES_IS_NOT_INT_TYPE_ERROR";
  codes[1698] = "ER_ACCESS_DENIED_NO_PASSWORD_ERROR";
  codes[1699] = "ER_SET_PASSWORD_AUTH_PLUGIN";
  codes[1700] = "ER_GRANT_PLUGIN_USER_EXISTS";
  codes[1701] = "ER_TRUNCATE_ILLEGAL_FK";
  codes[1702] = "ER_PLUGIN_IS_PERMANENT";
  codes[1703] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN";
  codes[1704] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX";
  codes[1705] = "ER_STMT_CACHE_FULL";
  codes[1706] = "ER_MULTI_UPDATE_KEY_CONFLICT";
  codes[1707] = "ER_TABLE_NEEDS_REBUILD";
  codes[1708] = "WARN_OPTION_BELOW_LIMIT";
  codes[1709] = "ER_INDEX_COLUMN_TOO_LONG";
  codes[1710] = "ER_ERROR_IN_TRIGGER_BODY";
  codes[1711] = "ER_ERROR_IN_UNKNOWN_TRIGGER_BODY";
  codes[1712] = "ER_INDEX_CORRUPT";
  codes[1713] = "ER_UNDO_RECORD_TOO_BIG";
  codes[1714] = "ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT";
  codes[1715] = "ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE";
  codes[1716] = "ER_BINLOG_UNSAFE_REPLACE_SELECT";
  codes[1717] = "ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT";
  codes[1718] = "ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT";
  codes[1719] = "ER_BINLOG_UNSAFE_UPDATE_IGNORE";
  codes[1720] = "ER_UNUSED_15";
  codes[1721] = "ER_UNUSED_16";
  codes[1722] = "ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT";
  codes[1723] = "ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC";
  codes[1724] = "ER_BINLOG_UNSAFE_INSERT_TWO_KEYS";
  codes[1725] = "ER_UNUSED_28";
  codes[1726] = "ER_VERS_NOT_ALLOWED";
  codes[1727] = "ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST";
  codes[1728] = "ER_CANNOT_LOAD_FROM_TABLE_V2";
  codes[1729] = "ER_MASTER_DELAY_VALUE_OUT_OF_RANGE";
  codes[1730] = "ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT";
  codes[1731] = "ER_PARTITION_EXCHANGE_DIFFERENT_OPTION";
  codes[1732] = "ER_PARTITION_EXCHANGE_PART_TABLE";
  codes[1733] = "ER_PARTITION_EXCHANGE_TEMP_TABLE";
  codes[1734] = "ER_PARTITION_INSTEAD_OF_SUBPARTITION";
  codes[1735] = "ER_UNKNOWN_PARTITION";
  codes[1736] = "ER_TABLES_DIFFERENT_METADATA";
  codes[1737] = "ER_ROW_DOES_NOT_MATCH_PARTITION";
  codes[1738] = "ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX";
  codes[1739] = "ER_WARN_INDEX_NOT_APPLICABLE";
  codes[1740] = "ER_PARTITION_EXCHANGE_FOREIGN_KEY";
  codes[1741] = "ER_NO_SUCH_KEY_VALUE";
  codes[1742] = "ER_VALUE_TOO_LONG";
  codes[1743] = "ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE";
  codes[1744] = "ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE";
  codes[1745] = "ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX";
  codes[1746] = "ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT";
  codes[1747] = "ER_PARTITION_CLAUSE_ON_NONPARTITIONED";
  codes[1748] = "ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET";
  codes[1749] = "ER_UNUSED_5";
  codes[1750] = "ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE";
  codes[1751] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE";
  codes[1752] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE";
  codes[1753] = "ER_MTS_FEATURE_IS_NOT_SUPPORTED";
  codes[1754] = "ER_MTS_UPDATED_DBS_GREATER_MAX";
  codes[1755] = "ER_MTS_CANT_PARALLEL";
  codes[1756] = "ER_MTS_INCONSISTENT_DATA";
  codes[1757] = "ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING";
  codes[1758] = "ER_DA_INVALID_CONDITION_NUMBER";
  codes[1759] = "ER_INSECURE_PLAIN_TEXT";
  codes[1760] = "ER_INSECURE_CHANGE_MASTER";
  codes[1761] = "ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO";
  codes[1762] = "ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO";
  codes[1763] = "ER_SQLTHREAD_WITH_SECURE_SLAVE";
  codes[1764] = "ER_TABLE_HAS_NO_FT";
  codes[1765] = "ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER";
  codes[1766] = "ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION";
  codes[1767] = "ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST";
  codes[1768] = "ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION_WHEN_GTID_NEXT_LIST_IS_NULL";
  codes[1769] = "ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION";
  codes[1770] = "ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL";
  codes[1771] = "ER_SKIPPING_LOGGED_TRANSACTION";
  codes[1772] = "ER_MALFORMED_GTID_SET_SPECIFICATION";
  codes[1773] = "ER_MALFORMED_GTID_SET_ENCODING";
  codes[1774] = "ER_MALFORMED_GTID_SPECIFICATION";
  codes[1775] = "ER_GNO_EXHAUSTED";
  codes[1776] = "ER_BAD_SLAVE_AUTO_POSITION";
  codes[1777] = "ER_AUTO_POSITION_REQUIRES_GTID_MODE_ON";
  codes[1778] = "ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET";
  codes[1779] = "ER_GTID_MODE_2_OR_3_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON";
  codes[1780] = "ER_GTID_MODE_REQUIRES_BINLOG";
  codes[1781] = "ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF";
  codes[1782] = "ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON";
  codes[1783] = "ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF";
  codes[1784] = "ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF";
  codes[1785] = "ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE";
  codes[1786] = "ER_GTID_UNSAFE_CREATE_SELECT";
  codes[1787] = "ER_GTID_UNSAFE_CREATE_DROP_TEMPORARY_TABLE_IN_TRANSACTION";
  codes[1788] = "ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME";
  codes[1789] = "ER_MASTER_HAS_PURGED_REQUIRED_GTIDS";
  codes[1790] = "ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID";
  codes[1791] = "ER_UNKNOWN_EXPLAIN_FORMAT";
  codes[1792] = "ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION";
  codes[1793] = "ER_TOO_LONG_TABLE_PARTITION_COMMENT";
  codes[1794] = "ER_SLAVE_CONFIGURATION";
  codes[1795] = "ER_INNODB_FT_LIMIT";
  codes[1796] = "ER_INNODB_NO_FT_TEMP_TABLE";
  codes[1797] = "ER_INNODB_FT_WRONG_DOCID_COLUMN";
  codes[1798] = "ER_INNODB_FT_WRONG_DOCID_INDEX";
  codes[1799] = "ER_INNODB_ONLINE_LOG_TOO_BIG";
  codes[1800] = "ER_UNKNOWN_ALTER_ALGORITHM";
  codes[1801] = "ER_UNKNOWN_ALTER_LOCK";
  codes[1802] = "ER_MTS_CHANGE_MASTER_CANT_RUN_WITH_GAPS";
  codes[1803] = "ER_MTS_RECOVERY_FAILURE";
  codes[1804] = "ER_MTS_RESET_WORKERS";
  codes[1805] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2";
  codes[1806] = "ER_SLAVE_SILENT_RETRY_TRANSACTION";
  codes[1807] = "ER_UNUSED_22";
  codes[1808] = "ER_TABLE_SCHEMA_MISMATCH";
  codes[1809] = "ER_TABLE_IN_SYSTEM_TABLESPACE";
  codes[1810] = "ER_IO_READ_ERROR";
  codes[1811] = "ER_IO_WRITE_ERROR";
  codes[1812] = "ER_TABLESPACE_MISSING";
  codes[1813] = "ER_TABLESPACE_EXISTS";
  codes[1814] = "ER_TABLESPACE_DISCARDED";
  codes[1815] = "ER_INTERNAL_ERROR";
  codes[1816] = "ER_INNODB_IMPORT_ERROR";
  codes[1817] = "ER_INNODB_INDEX_CORRUPT";
  codes[1818] = "ER_INVALID_YEAR_COLUMN_LENGTH";
  codes[1819] = "ER_NOT_VALID_PASSWORD";
  codes[1820] = "ER_MUST_CHANGE_PASSWORD";
  codes[1821] = "ER_FK_NO_INDEX_CHILD";
  codes[1822] = "ER_FK_NO_INDEX_PARENT";
  codes[1823] = "ER_FK_FAIL_ADD_SYSTEM";
  codes[1824] = "ER_FK_CANNOT_OPEN_PARENT";
  codes[1825] = "ER_FK_INCORRECT_OPTION";
  codes[1826] = "ER_DUP_CONSTRAINT_NAME";
  codes[1827] = "ER_PASSWORD_FORMAT";
  codes[1828] = "ER_FK_COLUMN_CANNOT_DROP";
  codes[1829] = "ER_FK_COLUMN_CANNOT_DROP_CHILD";
  codes[1830] = "ER_FK_COLUMN_NOT_NULL";
  codes[1831] = "ER_DUP_INDEX";
  codes[1832] = "ER_FK_COLUMN_CANNOT_CHANGE";
  codes[1833] = "ER_FK_COLUMN_CANNOT_CHANGE_CHILD";
  codes[1834] = "ER_FK_CANNOT_DELETE_PARENT";
  codes[1835] = "ER_MALFORMED_PACKET";
  codes[1836] = "ER_READ_ONLY_MODE";
  codes[1837] = "ER_GTID_NEXT_TYPE_UNDEFINED_GROUP";
  codes[1838] = "ER_VARIABLE_NOT_SETTABLE_IN_SP";
  codes[1839] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF";
  codes[1840] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY";
  codes[1841] = "ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY";
  codes[1842] = "ER_GTID_PURGED_WAS_CHANGED";
  codes[1843] = "ER_GTID_EXECUTED_WAS_CHANGED";
  codes[1844] = "ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES";
  codes[1845] = "ER_ALTER_OPERATION_NOT_SUPPORTED";
  codes[1846] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON";
  codes[1847] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY";
  codes[1848] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION";
  codes[1849] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME";
  codes[1850] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE";
  codes[1851] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK";
  codes[1852] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_IGNORE";
  codes[1853] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK";
  codes[1854] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC";
  codes[1855] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS";
  codes[1856] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS";
  codes[1857] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS";
  codes[1858] = "ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE";
  codes[1859] = "ER_DUP_UNKNOWN_IN_INDEX";
  codes[1860] = "ER_IDENT_CAUSES_TOO_LONG_PATH";
  codes[1861] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL";
  codes[1862] = "ER_MUST_CHANGE_PASSWORD_LOGIN";
  codes[1863] = "ER_ROW_IN_WRONG_PARTITION";
  codes[1864] = "ER_MTS_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX";
  codes[1865] = "ER_INNODB_NO_FT_USES_PARSER";
  codes[1866] = "ER_BINLOG_LOGICAL_CORRUPTION";
  codes[1867] = "ER_WARN_PURGE_LOG_IN_USE";
  codes[1868] = "ER_WARN_PURGE_LOG_IS_ACTIVE";
  codes[1869] = "ER_AUTO_INCREMENT_CONFLICT";
  codes[1870] = "WARN_ON_BLOCKHOLE_IN_RBR";
  codes[1871] = "ER_SLAVE_MI_INIT_REPOSITORY";
  codes[1872] = "ER_SLAVE_RLI_INIT_REPOSITORY";
  codes[1873] = "ER_ACCESS_DENIED_CHANGE_USER_ERROR";
  codes[1874] = "ER_INNODB_READ_ONLY";
  codes[1875] = "ER_STOP_SLAVE_SQL_THREAD_TIMEOUT";
  codes[1876] = "ER_STOP_SLAVE_IO_THREAD_TIMEOUT";
  codes[1877] = "ER_TABLE_CORRUPT";
  codes[1878] = "ER_TEMP_FILE_WRITE_FAILURE";
  codes[1879] = "ER_INNODB_FT_AUX_NOT_HEX_ID";
  codes[1880] = "ER_LAST_MYSQL_ERROR_MESSAGE";
  codes[1900] = "ER_UNUSED_18";
  codes[1901] = "ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED";
  codes[1902] = "ER_UNUSED_19";
  codes[1903] = "ER_PRIMARY_KEY_BASED_ON_GENERATED_COLUMN";
  codes[1904] = "ER_KEY_BASED_ON_GENERATED_VIRTUAL_COLUMN";
  codes[1905] = "ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN";
  codes[1906] = "ER_WARNING_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN";
  codes[1907] = "ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN";
  codes[1908] = "ER_UNUSED_20";
  codes[1909] = "ER_UNUSED_21";
  codes[1910] = "ER_UNSUPPORTED_ENGINE_FOR_GENERATED_COLUMNS";
  codes[1911] = "ER_UNKNOWN_OPTION";
  codes[1912] = "ER_BAD_OPTION_VALUE";
  codes[1913] = "ER_UNUSED_6";
  codes[1914] = "ER_UNUSED_7";
  codes[1915] = "ER_UNUSED_8";
  codes[1916] = "ER_DATA_OVERFLOW";
  codes[1917] = "ER_DATA_TRUNCATED";
  codes[1918] = "ER_BAD_DATA";
  codes[1919] = "ER_DYN_COL_WRONG_FORMAT";
  codes[1920] = "ER_DYN_COL_IMPLEMENTATION_LIMIT";
  codes[1921] = "ER_DYN_COL_DATA";
  codes[1922] = "ER_DYN_COL_WRONG_CHARSET";
  codes[1923] = "ER_ILLEGAL_SUBQUERY_OPTIMIZER_SWITCHES";
  codes[1924] = "ER_QUERY_CACHE_IS_DISABLED";
  codes[1925] = "ER_QUERY_CACHE_IS_GLOBALY_DISABLED";
  codes[1926] = "ER_VIEW_ORDERBY_IGNORED";
  codes[1927] = "ER_CONNECTION_KILLED";
  codes[1928] = "ER_UNUSED_12";
  codes[1929] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SKIP_REPLICATION";
  codes[1930] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SKIP_REPLICATION";
  codes[1931] = "ER_QUERY_EXCEEDED_ROWS_EXAMINED_LIMIT";
  codes[1932] = "ER_NO_SUCH_TABLE_IN_ENGINE";
  codes[1933] = "ER_TARGET_NOT_EXPLAINABLE";
  codes[1934] = "ER_CONNECTION_ALREADY_EXISTS";
  codes[1935] = "ER_MASTER_LOG_PREFIX";
  codes[1936] = "ER_CANT_START_STOP_SLAVE";
  codes[1937] = "ER_SLAVE_STARTED";
  codes[1938] = "ER_SLAVE_STOPPED";
  codes[1939] = "ER_SQL_DISCOVER_ERROR";
  codes[1940] = "ER_FAILED_GTID_STATE_INIT";
  codes[1941] = "ER_INCORRECT_GTID_STATE";
  codes[1942] = "ER_CANNOT_UPDATE_GTID_STATE";
  codes[1943] = "ER_DUPLICATE_GTID_DOMAIN";
  codes[1944] = "ER_GTID_OPEN_TABLE_FAILED";
  codes[1945] = "ER_GTID_POSITION_NOT_FOUND_IN_BINLOG";
  codes[1946] = "ER_CANNOT_LOAD_SLAVE_GTID_STATE";
  codes[1947] = "ER_MASTER_GTID_POS_CONFLICTS_WITH_BINLOG";
  codes[1948] = "ER_MASTER_GTID_POS_MISSING_DOMAIN";
  codes[1949] = "ER_UNTIL_REQUIRES_USING_GTID";
  codes[1950] = "ER_GTID_STRICT_OUT_OF_ORDER";
  codes[1951] = "ER_GTID_START_FROM_BINLOG_HOLE";
  codes[1952] = "ER_SLAVE_UNEXPECTED_MASTER_SWITCH";
  codes[1953] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO";
  codes[1954] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO";
  codes[1955] = "ER_GTID_POSITION_NOT_FOUND_IN_BINLOG2";
  codes[1956] = "ER_BINLOG_MUST_BE_EMPTY";
  codes[1957] = "ER_NO_SUCH_QUERY";
  codes[1958] = "ER_BAD_BASE64_DATA";
  codes[1959] = "ER_INVALID_ROLE";
  codes[1960] = "ER_INVALID_CURRENT_USER";
  codes[1961] = "ER_CANNOT_GRANT_ROLE";
  codes[1962] = "ER_CANNOT_REVOKE_ROLE";
  codes[1963] = "ER_CHANGE_SLAVE_PARALLEL_THREADS_ACTIVE";
  codes[1964] = "ER_PRIOR_COMMIT_FAILED";
  codes[1965] = "ER_IT_IS_A_VIEW";
  codes[1966] = "ER_SLAVE_SKIP_NOT_IN_GTID";
  codes[1967] = "ER_TABLE_DEFINITION_TOO_BIG";
  codes[1968] = "ER_PLUGIN_INSTALLED";
  codes[1969] = "ER_STATEMENT_TIMEOUT";
  codes[1970] = "ER_SUBQUERIES_NOT_SUPPORTED";
  codes[1971] = "ER_SET_STATEMENT_NOT_SUPPORTED";
  codes[1972] = "ER_UNUSED_9";
  codes[1973] = "ER_USER_CREATE_EXISTS";
  codes[1974] = "ER_USER_DROP_EXISTS";
  codes[1975] = "ER_ROLE_CREATE_EXISTS";
  codes[1976] = "ER_ROLE_DROP_EXISTS";
  codes[1977] = "ER_CANNOT_CONVERT_CHARACTER";
  codes[1978] = "ER_INVALID_DEFAULT_VALUE_FOR_FIELD";
  codes[1979] = "ER_KILL_QUERY_DENIED_ERROR";
  codes[1980] = "ER_NO_EIS_FOR_FIELD";
  codes[1981] = "ER_WARN_AGGFUNC_DEPENDENCE";
  codes[1982] = "WARN_INNODB_PARTITION_OPTION_IGNORED";
  codes[3e3] = "ER_FILE_CORRUPT";
  codes[3001] = "ER_ERROR_ON_MASTER";
  codes[3002] = "ER_INCONSISTENT_ERROR";
  codes[3003] = "ER_STORAGE_ENGINE_NOT_LOADED";
  codes[3004] = "ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER";
  codes[3005] = "ER_WARN_LEGACY_SYNTAX_CONVERTED";
  codes[3006] = "ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN";
  codes[3007] = "ER_CANNOT_DISCARD_TEMPORARY_TABLE";
  codes[3008] = "ER_FK_DEPTH_EXCEEDED";
  codes[3009] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2";
  codes[3010] = "ER_WARN_TRIGGER_DOESNT_HAVE_CREATED";
  codes[3011] = "ER_REFERENCED_TRG_DOES_NOT_EXIST_MYSQL";
  codes[3012] = "ER_EXPLAIN_NOT_SUPPORTED";
  codes[3013] = "ER_INVALID_FIELD_SIZE";
  codes[3014] = "ER_MISSING_HA_CREATE_OPTION";
  codes[3015] = "ER_ENGINE_OUT_OF_MEMORY";
  codes[3016] = "ER_PASSWORD_EXPIRE_ANONYMOUS_USER";
  codes[3017] = "ER_SLAVE_SQL_THREAD_MUST_STOP";
  codes[3018] = "ER_NO_FT_MATERIALIZED_SUBQUERY";
  codes[3019] = "ER_INNODB_UNDO_LOG_FULL";
  codes[3020] = "ER_INVALID_ARGUMENT_FOR_LOGARITHM";
  codes[3021] = "ER_SLAVE_CHANNEL_IO_THREAD_MUST_STOP";
  codes[3022] = "ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO";
  codes[3023] = "ER_WARN_ONLY_MASTER_LOG_FILE_NO_POS";
  codes[3024] = "ER_QUERY_TIMEOUT";
  codes[3025] = "ER_NON_RO_SELECT_DISABLE_TIMER";
  codes[3026] = "ER_DUP_LIST_ENTRY";
  codes[3027] = "ER_SQL_MODE_NO_EFFECT";
  codes[3028] = "ER_AGGREGATE_ORDER_FOR_UNION";
  codes[3029] = "ER_AGGREGATE_ORDER_NON_AGG_QUERY";
  codes[3030] = "ER_SLAVE_WORKER_STOPPED_PREVIOUS_THD_ERROR";
  codes[3031] = "ER_DONT_SUPPORT_SLAVE_PRESERVE_COMMIT_ORDER";
  codes[3032] = "ER_SERVER_OFFLINE_MODE";
  codes[3033] = "ER_GIS_DIFFERENT_SRIDS";
  codes[3034] = "ER_GIS_UNSUPPORTED_ARGUMENT";
  codes[3035] = "ER_GIS_UNKNOWN_ERROR";
  codes[3036] = "ER_GIS_UNKNOWN_EXCEPTION";
  codes[3037] = "ER_GIS_INVALID_DATA";
  codes[3038] = "ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION";
  codes[3039] = "ER_BOOST_GEOMETRY_CENTROID_EXCEPTION";
  codes[3040] = "ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION";
  codes[3041] = "ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION";
  codes[3042] = "ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION";
  codes[3043] = "ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION";
  codes[3044] = "ER_STD_BAD_ALLOC_ERROR";
  codes[3045] = "ER_STD_DOMAIN_ERROR";
  codes[3046] = "ER_STD_LENGTH_ERROR";
  codes[3047] = "ER_STD_INVALID_ARGUMENT";
  codes[3048] = "ER_STD_OUT_OF_RANGE_ERROR";
  codes[3049] = "ER_STD_OVERFLOW_ERROR";
  codes[3050] = "ER_STD_RANGE_ERROR";
  codes[3051] = "ER_STD_UNDERFLOW_ERROR";
  codes[3052] = "ER_STD_LOGIC_ERROR";
  codes[3053] = "ER_STD_RUNTIME_ERROR";
  codes[3054] = "ER_STD_UNKNOWN_EXCEPTION";
  codes[3055] = "ER_GIS_DATA_WRONG_ENDIANESS";
  codes[3056] = "ER_CHANGE_MASTER_PASSWORD_LENGTH";
  codes[3057] = "ER_USER_LOCK_WRONG_NAME";
  codes[3058] = "ER_USER_LOCK_DEADLOCK";
  codes[3059] = "ER_REPLACE_INACCESSIBLE_ROWS";
  codes[3060] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS";
  codes[4e3] = "ER_UNUSED_26";
  codes[4001] = "ER_UNUSED_27";
  codes[4002] = "ER_WITH_COL_WRONG_LIST";
  codes[4003] = "ER_TOO_MANY_DEFINITIONS_IN_WITH_CLAUSE";
  codes[4004] = "ER_DUP_QUERY_NAME";
  codes[4005] = "ER_RECURSIVE_WITHOUT_ANCHORS";
  codes[4006] = "ER_UNACCEPTABLE_MUTUAL_RECURSION";
  codes[4007] = "ER_REF_TO_RECURSIVE_WITH_TABLE_IN_DERIVED";
  codes[4008] = "ER_NOT_STANDARD_COMPLIANT_RECURSIVE";
  codes[4009] = "ER_WRONG_WINDOW_SPEC_NAME";
  codes[4010] = "ER_DUP_WINDOW_NAME";
  codes[4011] = "ER_PARTITION_LIST_IN_REFERENCING_WINDOW_SPEC";
  codes[4012] = "ER_ORDER_LIST_IN_REFERENCING_WINDOW_SPEC";
  codes[4013] = "ER_WINDOW_FRAME_IN_REFERENCED_WINDOW_SPEC";
  codes[4014] = "ER_BAD_COMBINATION_OF_WINDOW_FRAME_BOUND_SPECS";
  codes[4015] = "ER_WRONG_PLACEMENT_OF_WINDOW_FUNCTION";
  codes[4016] = "ER_WINDOW_FUNCTION_IN_WINDOW_SPEC";
  codes[4017] = "ER_NOT_ALLOWED_WINDOW_FRAME";
  codes[4018] = "ER_NO_ORDER_LIST_IN_WINDOW_SPEC";
  codes[4019] = "ER_RANGE_FRAME_NEEDS_SIMPLE_ORDERBY";
  codes[4020] = "ER_WRONG_TYPE_FOR_ROWS_FRAME";
  codes[4021] = "ER_WRONG_TYPE_FOR_RANGE_FRAME";
  codes[4022] = "ER_FRAME_EXCLUSION_NOT_SUPPORTED";
  codes[4023] = "ER_WINDOW_FUNCTION_DONT_HAVE_FRAME";
  codes[4024] = "ER_INVALID_NTILE_ARGUMENT";
  codes[4025] = "ER_CONSTRAINT_FAILED";
  codes[4026] = "ER_EXPRESSION_IS_TOO_BIG";
  codes[4027] = "ER_ERROR_EVALUATING_EXPRESSION";
  codes[4028] = "ER_CALCULATING_DEFAULT_VALUE";
  codes[4029] = "ER_EXPRESSION_REFERS_TO_UNINIT_FIELD";
  codes[4030] = "ER_PARTITION_DEFAULT_ERROR";
  codes[4031] = "ER_REFERENCED_TRG_DOES_NOT_EXIST";
  codes[4032] = "ER_INVALID_DEFAULT_PARAM";
  codes[4033] = "ER_BINLOG_NON_SUPPORTED_BULK";
  codes[4034] = "ER_BINLOG_UNCOMPRESS_ERROR";
  codes[4035] = "ER_JSON_BAD_CHR";
  codes[4036] = "ER_JSON_NOT_JSON_CHR";
  codes[4037] = "ER_JSON_EOS";
  codes[4038] = "ER_JSON_SYNTAX";
  codes[4039] = "ER_JSON_ESCAPING";
  codes[4040] = "ER_JSON_DEPTH";
  codes[4041] = "ER_JSON_PATH_EOS";
  codes[4042] = "ER_JSON_PATH_SYNTAX";
  codes[4043] = "ER_JSON_PATH_DEPTH";
  codes[4044] = "ER_JSON_PATH_NO_WILDCARD";
  codes[4045] = "ER_JSON_PATH_ARRAY";
  codes[4046] = "ER_JSON_ONE_OR_ALL";
  codes[4047] = "ER_UNSUPPORTED_COMPRESSED_TABLE";
  codes[4048] = "ER_GEOJSON_INCORRECT";
  codes[4049] = "ER_GEOJSON_TOO_FEW_POINTS";
  codes[4050] = "ER_GEOJSON_NOT_CLOSED";
  codes[4051] = "ER_JSON_PATH_EMPTY";
  codes[4052] = "ER_SLAVE_SAME_ID";
  codes[4053] = "ER_FLASHBACK_NOT_SUPPORTED";
  codes[4054] = "ER_KEYS_OUT_OF_ORDER";
  codes[4055] = "ER_OVERLAPPING_KEYS";
  codes[4056] = "ER_REQUIRE_ROW_BINLOG_FORMAT";
  codes[4057] = "ER_ISOLATION_MODE_NOT_SUPPORTED";
  codes[4058] = "ER_ON_DUPLICATE_DISABLED";
  codes[4059] = "ER_UPDATES_WITH_CONSISTENT_SNAPSHOT";
  codes[4060] = "ER_ROLLBACK_ONLY";
  codes[4061] = "ER_ROLLBACK_TO_SAVEPOINT";
  codes[4062] = "ER_ISOLATION_LEVEL_WITH_CONSISTENT_SNAPSHOT";
  codes[4063] = "ER_UNSUPPORTED_COLLATION";
  codes[4064] = "ER_METADATA_INCONSISTENCY";
  codes[4065] = "ER_CF_DIFFERENT";
  codes[4066] = "ER_RDB_TTL_DURATION_FORMAT";
  codes[4067] = "ER_RDB_STATUS_GENERAL";
  codes[4068] = "ER_RDB_STATUS_MSG";
  codes[4069] = "ER_RDB_TTL_UNSUPPORTED";
  codes[4070] = "ER_RDB_TTL_COL_FORMAT";
  codes[4071] = "ER_PER_INDEX_CF_DEPRECATED";
  codes[4072] = "ER_KEY_CREATE_DURING_ALTER";
  codes[4073] = "ER_SK_POPULATE_DURING_ALTER";
  codes[4074] = "ER_SUM_FUNC_WITH_WINDOW_FUNC_AS_ARG";
  codes[4075] = "ER_NET_OK_PACKET_TOO_LARGE";
  codes[4076] = "ER_GEOJSON_EMPTY_COORDINATES";
  codes[4077] = "ER_MYROCKS_CANT_NOPAD_COLLATION";
  codes[4078] = "ER_ILLEGAL_PARAMETER_DATA_TYPES2_FOR_OPERATION";
  codes[4079] = "ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION";
  codes[4080] = "ER_WRONG_PARAMCOUNT_TO_CURSOR";
  codes[4081] = "ER_UNKNOWN_STRUCTURED_VARIABLE";
  codes[4082] = "ER_ROW_VARIABLE_DOES_NOT_HAVE_FIELD";
  codes[4083] = "ER_END_IDENTIFIER_DOES_NOT_MATCH";
  codes[4084] = "ER_SEQUENCE_RUN_OUT";
  codes[4085] = "ER_SEQUENCE_INVALID_DATA";
  codes[4086] = "ER_SEQUENCE_INVALID_TABLE_STRUCTURE";
  codes[4087] = "ER_SEQUENCE_ACCESS_ERROR";
  codes[4088] = "ER_SEQUENCE_BINLOG_FORMAT";
  codes[4089] = "ER_NOT_SEQUENCE";
  codes[4090] = "ER_NOT_SEQUENCE2";
  codes[4091] = "ER_UNKNOWN_SEQUENCES";
  codes[4092] = "ER_UNKNOWN_VIEW";
  codes[4093] = "ER_WRONG_INSERT_INTO_SEQUENCE";
  codes[4094] = "ER_SP_STACK_TRACE";
  codes[4095] = "ER_PACKAGE_ROUTINE_IN_SPEC_NOT_DEFINED_IN_BODY";
  codes[4096] = "ER_PACKAGE_ROUTINE_FORWARD_DECLARATION_NOT_DEFINED";
  codes[4097] = "ER_COMPRESSED_COLUMN_USED_AS_KEY";
  codes[4098] = "ER_UNKNOWN_COMPRESSION_METHOD";
  codes[4099] = "ER_WRONG_NUMBER_OF_VALUES_IN_TVC";
  codes[4100] = "ER_FIELD_REFERENCE_IN_TVC";
  codes[4101] = "ER_WRONG_TYPE_FOR_PERCENTILE_FUNC";
  codes[4102] = "ER_ARGUMENT_NOT_CONSTANT";
  codes[4103] = "ER_ARGUMENT_OUT_OF_RANGE";
  codes[4104] = "ER_WRONG_TYPE_OF_ARGUMENT";
  codes[4105] = "ER_NOT_AGGREGATE_FUNCTION";
  codes[4106] = "ER_INVALID_AGGREGATE_FUNCTION";
  codes[4107] = "ER_INVALID_VALUE_TO_LIMIT";
  codes[4108] = "ER_INVISIBLE_NOT_NULL_WITHOUT_DEFAULT";
  codes[4109] = "ER_UPDATE_INFO_WITH_SYSTEM_VERSIONING";
  codes[4110] = "ER_VERS_FIELD_WRONG_TYPE";
  codes[4111] = "ER_VERS_ENGINE_UNSUPPORTED";
  codes[4112] = "ER_UNUSED_23";
  codes[4113] = "ER_PARTITION_WRONG_TYPE";
  codes[4114] = "WARN_VERS_PART_FULL";
  codes[4115] = "WARN_VERS_PARAMETERS";
  codes[4116] = "ER_VERS_DROP_PARTITION_INTERVAL";
  codes[4117] = "ER_UNUSED_25";
  codes[4118] = "WARN_VERS_PART_NON_HISTORICAL";
  codes[4119] = "ER_VERS_ALTER_NOT_ALLOWED";
  codes[4120] = "ER_VERS_ALTER_ENGINE_PROHIBITED";
  codes[4121] = "ER_VERS_RANGE_PROHIBITED";
  codes[4122] = "ER_CONFLICTING_FOR_SYSTEM_TIME";
  codes[4123] = "ER_VERS_TABLE_MUST_HAVE_COLUMNS";
  codes[4124] = "ER_VERS_NOT_VERSIONED";
  codes[4125] = "ER_MISSING";
  codes[4126] = "ER_VERS_PERIOD_COLUMNS";
  codes[4127] = "ER_PART_WRONG_VALUE";
  codes[4128] = "ER_VERS_WRONG_PARTS";
  codes[4129] = "ER_VERS_NO_TRX_ID";
  codes[4130] = "ER_VERS_ALTER_SYSTEM_FIELD";
  codes[4131] = "ER_DROP_VERSIONING_SYSTEM_TIME_PARTITION";
  codes[4132] = "ER_VERS_DB_NOT_SUPPORTED";
  codes[4133] = "ER_VERS_TRT_IS_DISABLED";
  codes[4134] = "ER_VERS_DUPLICATE_ROW_START_END";
  codes[4135] = "ER_VERS_ALREADY_VERSIONED";
  codes[4136] = "ER_UNUSED_24";
  codes[4137] = "ER_VERS_NOT_SUPPORTED";
  codes[4138] = "ER_VERS_TRX_PART_HISTORIC_ROW_NOT_SUPPORTED";
  codes[4139] = "ER_INDEX_FILE_FULL";
  codes[4140] = "ER_UPDATED_COLUMN_ONLY_ONCE";
  codes[4141] = "ER_EMPTY_ROW_IN_TVC";
  codes[4142] = "ER_VERS_QUERY_IN_PARTITION";
  codes[4143] = "ER_KEY_DOESNT_SUPPORT";
  codes[4144] = "ER_ALTER_OPERATION_TABLE_OPTIONS_NEED_REBUILD";
  codes[4145] = "ER_BACKUP_LOCK_IS_ACTIVE";
  codes[4146] = "ER_BACKUP_NOT_RUNNING";
  codes[4147] = "ER_BACKUP_WRONG_STAGE";
  codes[4148] = "ER_BACKUP_STAGE_FAILED";
  codes[4149] = "ER_BACKUP_UNKNOWN_STAGE";
  codes[4150] = "ER_USER_IS_BLOCKED";
  codes[4151] = "ER_ACCOUNT_HAS_BEEN_LOCKED";
  codes[4152] = "ER_PERIOD_TEMPORARY_NOT_ALLOWED";
  codes[4153] = "ER_PERIOD_TYPES_MISMATCH";
  codes[4154] = "ER_MORE_THAN_ONE_PERIOD";
  codes[4155] = "ER_PERIOD_FIELD_WRONG_ATTRIBUTES";
  codes[4156] = "ER_PERIOD_NOT_FOUND";
  codes[4157] = "ER_PERIOD_COLUMNS_UPDATED";
  codes[4158] = "ER_PERIOD_CONSTRAINT_DROP";
  codes[4159] = "ER_TOO_LONG_KEYPART";
  codes[4160] = "ER_TOO_LONG_DATABASE_COMMENT";
  codes[4161] = "ER_UNKNOWN_DATA_TYPE";
  codes[4162] = "ER_UNKNOWN_OPERATOR";
  codes[4163] = "ER_WARN_HISTORY_ROW_START_TIME";
  codes[4164] = "ER_PART_STARTS_BEYOND_INTERVAL";
  codes[4165] = "ER_GALERA_REPLICATION_NOT_SUPPORTED";
  codes[4166] = "ER_LOAD_INFILE_CAPABILITY_DISABLED";
  codes[4167] = "ER_NO_SECURE_TRANSPORTS_CONFIGURED";
  codes[4168] = "ER_SLAVE_IGNORED_SHARED_TABLE";
  codes[4169] = "ER_NO_AUTOINCREMENT_WITH_UNIQUE";
  codes[4170] = "ER_KEY_CONTAINS_PERIOD_FIELDS";
  codes[4171] = "ER_KEY_CANT_HAVE_WITHOUT_OVERLAPS";
  codes[4172] = "ER_NOT_ALLOWED_IN_THIS_CONTEXT";
  codes[4173] = "ER_DATA_WAS_COMMITED_UNDER_ROLLBACK";
  codes[4174] = "ER_PK_INDEX_CANT_BE_IGNORED";
  codes[4175] = "ER_BINLOG_UNSAFE_SKIP_LOCKED";
  codes[4176] = "ER_JSON_TABLE_ERROR_ON_FIELD";
  codes[4177] = "ER_JSON_TABLE_ALIAS_REQUIRED";
  codes[4178] = "ER_JSON_TABLE_SCALAR_EXPECTED";
  codes[4179] = "ER_JSON_TABLE_MULTIPLE_MATCHES";
  codes[4180] = "ER_WITH_TIES_NEEDS_ORDER";
  codes[4181] = "ER_REMOVED_ORPHAN_TRIGGER";
  codes[4182] = "ER_STORAGE_ENGINE_DISABLED";
  codes[4183] = "WARN_SFORMAT_ERROR";
  codes[4184] = "ER_PARTITION_CONVERT_SUBPARTITIONED";
  codes[4185] = "ER_PROVIDER_NOT_LOADED";
  codes[4186] = "ER_JSON_HISTOGRAM_PARSE_FAILED";
  codes[4187] = "ER_SF_OUT_INOUT_ARG_NOT_ALLOWED";
  codes[4188] = "ER_INCONSISTENT_SLAVE_TEMP_TABLE";
  codes[4189] = "ER_VERS_HIST_PART_FAILED";
  errorCode.codes = codes;
  return errorCode;
}
errors.exports;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors.exports;
  hasRequiredErrors = 1;
  (function(module) {
    const ErrorCodes = requireErrorCode();
    class SqlError extends Error {
      constructor(msg, sql, fatal, info, sqlState, errno, additionalStack, addHeader = void 0, cause) {
        super(
          (addHeader !== false ? `(conn:${info && info.threadId ? info.threadId : -1}, no: ${errno ? errno : -1}, SQLState: ${sqlState}) ` : "") + msg + (sql ? "\nsql: " + sql : ""),
          cause
        );
        this.name = "SqlError";
        this.sqlMessage = msg;
        this.sql = sql;
        this.fatal = fatal;
        this.errno = errno;
        this.sqlState = sqlState;
        if (errno > 45e3 && errno < 46e3) {
          this.code = errByNo[errno] || "UNKNOWN";
        } else {
          this.code = ErrorCodes.codes[this.errno] || "UNKNOWN";
        }
        if (additionalStack) {
          this.stack += "\n From event:\n" + additionalStack.substring(additionalStack.indexOf("\n") + 1);
        }
      }
      get text() {
        return this.sqlMessage;
      }
    }
    module.exports.createError = function(msg, errno, info = null, sqlState = "HY000", sql = null, fatal = false, additionalStack = void 0, addHeader = void 0, cause = void 0) {
      if (cause) return new SqlError(msg, sql, fatal, info, sqlState, errno, additionalStack, addHeader, { cause });
      return new SqlError(msg, sql, fatal, info, sqlState, errno, additionalStack, addHeader, cause);
    };
    module.exports.createFatalError = function(msg, errno, info = null, sqlState = "08S01", sql = null, additionalStack = void 0, addHeader = void 0) {
      return new SqlError(msg, sql, true, info, sqlState, errno, additionalStack, addHeader);
    };
    module.exports.ER_CONNECTION_ALREADY_CLOSED = 45001;
    module.exports.ER_MYSQL_CHANGE_USER_BUG = 45003;
    module.exports.ER_CMD_NOT_EXECUTED_DESTROYED = 45004;
    module.exports.ER_NULL_CHAR_ESCAPEID = 45005;
    module.exports.ER_NULL_ESCAPEID = 45006;
    module.exports.ER_NOT_IMPLEMENTED_FORMAT = 45007;
    module.exports.ER_NODE_NOT_SUPPORTED_TLS = 45008;
    module.exports.ER_SOCKET_UNEXPECTED_CLOSE = 45009;
    module.exports.ER_UNEXPECTED_PACKET = 45011;
    module.exports.ER_CONNECTION_TIMEOUT = 45012;
    module.exports.ER_CMD_CONNECTION_CLOSED = 45013;
    module.exports.ER_CHANGE_USER_BAD_PACKET = 45014;
    module.exports.ER_PING_BAD_PACKET = 45015;
    module.exports.ER_MISSING_PARAMETER = 45016;
    module.exports.ER_PARAMETER_UNDEFINED = 45017;
    module.exports.ER_PLACEHOLDER_UNDEFINED = 45018;
    module.exports.ER_SOCKET = 45019;
    module.exports.ER_EOF_EXPECTED = 45020;
    module.exports.ER_LOCAL_INFILE_DISABLED = 45021;
    module.exports.ER_LOCAL_INFILE_NOT_READABLE = 45022;
    module.exports.ER_SERVER_SSL_DISABLED = 45023;
    module.exports.ER_AUTHENTICATION_BAD_PACKET = 45024;
    module.exports.ER_AUTHENTICATION_PLUGIN_NOT_SUPPORTED = 45025;
    module.exports.ER_SOCKET_TIMEOUT = 45026;
    module.exports.ER_POOL_ALREADY_CLOSED = 45027;
    module.exports.ER_GET_CONNECTION_TIMEOUT = 45028;
    module.exports.ER_SETTING_SESSION_ERROR = 45029;
    module.exports.ER_INITIAL_SQL_ERROR = 45030;
    module.exports.ER_BATCH_WITH_NO_VALUES = 45031;
    module.exports.ER_RESET_BAD_PACKET = 45032;
    module.exports.ER_WRONG_IANA_TIMEZONE = 45033;
    module.exports.ER_LOCAL_INFILE_WRONG_FILENAME = 45034;
    module.exports.ER_ADD_CONNECTION_CLOSED_POOL = 45035;
    module.exports.ER_WRONG_AUTO_TIMEZONE = 45036;
    module.exports.ER_CLOSING_POOL = 45037;
    module.exports.ER_TIMEOUT_NOT_SUPPORTED = 45038;
    module.exports.ER_INITIAL_TIMEOUT_ERROR = 45039;
    module.exports.ER_DUPLICATE_FIELD = 45040;
    module.exports.ER_PING_TIMEOUT = 45042;
    module.exports.ER_BAD_PARAMETER_VALUE = 45043;
    module.exports.ER_CANNOT_RETRIEVE_RSA_KEY = 45044;
    module.exports.ER_MINIMUM_NODE_VERSION_REQUIRED = 45045;
    module.exports.ER_MAX_ALLOWED_PACKET = 45046;
    module.exports.ER_NOT_SUPPORTED_AUTH_PLUGIN = 45047;
    module.exports.ER_COMPRESSION_NOT_SUPPORTED = 45048;
    module.exports.ER_UNDEFINED_SQL = 45049;
    module.exports.ER_PARSING_PRECISION = 45050;
    module.exports.ER_PREPARE_CLOSED = 45051;
    module.exports.ER_MISSING_SQL_PARAMETER = 45052;
    module.exports.ER_MISSING_SQL_FILE = 45053;
    module.exports.ER_SQL_FILE_ERROR = 45054;
    module.exports.ER_MISSING_DATABASE_PARAMETER = 45055;
    module.exports.ER_SELF_SIGNED = 45056;
    module.exports.ER_SELF_SIGNED_NO_PWD = 45057;
    module.exports.ER_PRIVATE_FIELDS_USE = 45058;
    module.exports.ER_TLS_IDENTITY_ERROR = 45059;
    const keys = Object.keys(module.exports);
    const errByNo = {};
    for (let i = 0; i < keys.length; i++) {
      const keyName = keys[i];
      if (keyName !== "createError") {
        errByNo[module.exports[keyName]] = keyName;
      }
    }
    module.exports.SqlError = SqlError;
  })(errors);
  return errors.exports;
}
var packet;
var hasRequiredPacket;
function requirePacket() {
  if (hasRequiredPacket) return packet;
  hasRequiredPacket = 1;
  const Errors = requireErrors();
  class Packet {
    update(buf, pos, end) {
      this.buf = buf;
      this.pos = pos;
      this.end = end;
      return this;
    }
    skip(n) {
      this.pos += n;
    }
    readGeometry(defaultVal) {
      const geoBuf = this.readBufferLengthEncoded();
      if (geoBuf === null || geoBuf.length === 0) {
        return defaultVal;
      }
      let geoPos = 4;
      return readGeometryObject(false);
      function parseCoordinates(byteOrder) {
        geoPos += 16;
        const x = byteOrder ? geoBuf.readDoubleLE(geoPos - 16) : geoBuf.readDoubleBE(geoPos - 16);
        const y = byteOrder ? geoBuf.readDoubleLE(geoPos - 8) : geoBuf.readDoubleBE(geoPos - 8);
        return [x, y];
      }
      function readGeometryObject(inner) {
        const byteOrder = geoBuf[geoPos++];
        const wkbType = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
        geoPos += 4;
        switch (wkbType) {
          case 1:
            const coords = parseCoordinates(byteOrder);
            if (inner) return coords;
            return {
              type: "Point",
              coordinates: coords
            };
          case 2:
            const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
            geoPos += 4;
            let coordinates = [];
            for (let i = 0; i < pointNumber; i++) {
              coordinates.push(parseCoordinates(byteOrder));
            }
            if (inner) return coordinates;
            return {
              type: "LineString",
              coordinates
            };
          case 3:
            let polygonCoordinates = [];
            const numRings = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
            geoPos += 4;
            for (let ring = 0; ring < numRings; ring++) {
              const pointNumber2 = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
              geoPos += 4;
              let linesCoordinates = [];
              for (let i = 0; i < pointNumber2; i++) {
                linesCoordinates.push(parseCoordinates(byteOrder));
              }
              polygonCoordinates.push(linesCoordinates);
            }
            if (inner) return polygonCoordinates;
            return {
              type: "Polygon",
              coordinates: polygonCoordinates
            };
          case 4:
            return {
              type: "MultiPoint",
              coordinates: parseGeomArray(byteOrder, true)
            };
          case 5:
            return {
              type: "MultiLineString",
              coordinates: parseGeomArray(byteOrder, true)
            };
          case 6:
            return {
              type: "MultiPolygon",
              coordinates: parseGeomArray(byteOrder, true)
            };
          case 7:
            return {
              type: "GeometryCollection",
              geometries: parseGeomArray(byteOrder, false)
            };
        }
        return null;
      }
      function parseGeomArray(byteOrder, inner) {
        let coordinates = [];
        const number = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
        geoPos += 4;
        for (let i = 0; i < number; i++) {
          coordinates.push(readGeometryObject(inner));
        }
        return coordinates;
      }
    }
    peek() {
      return this.buf[this.pos];
    }
    remaining() {
      return this.end - this.pos > 0;
    }
    readInt8() {
      const val = this.buf[this.pos++];
      return val | (val & 2 ** 7) * 33554430;
    }
    readUInt8() {
      return this.buf[this.pos++];
    }
    readInt16() {
      const first = this.buf[this.pos++];
      const last = this.buf[this.pos++];
      const val = first + last * 2 ** 8;
      return val | (val & 2 ** 15) * 131070;
    }
    readUInt16() {
      return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;
    }
    readInt24() {
      const first = this.buf[this.pos];
      const last = this.buf[this.pos + 2];
      const val = first + this.buf[this.pos + 1] * 2 ** 8 + last * 2 ** 16;
      this.pos += 3;
      return val | (val & 2 ** 23) * 510;
    }
    readUInt24() {
      return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;
    }
    readUInt32() {
      return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16 + this.buf[this.pos++] * 2 ** 24;
    }
    readInt32() {
      return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16 + (this.buf[this.pos++] << 24);
    }
    readBigInt64() {
      const val = this.buf.readBigInt64LE(this.pos);
      this.pos += 8;
      return val;
    }
    readBigUInt64() {
      const val = this.buf.readBigUInt64LE(this.pos);
      this.pos += 8;
      return val;
    }
    /**
     * Metadata are length encoded, but cannot have length > 256, so simplified readUnsignedLength
     * @returns {number}
     */
    readMetadataLength() {
      const type2 = this.buf[this.pos++];
      if (type2 < 251) return type2;
      return this.readUInt16();
    }
    readUnsignedLength() {
      const type2 = this.buf[this.pos++];
      if (type2 < 251) return type2;
      switch (type2) {
        case 251:
          return null;
        case 252:
          return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8;
        case 253:
          return this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16;
        case 254:
          return Number(this.readBigInt64());
      }
    }
    readBuffer(len) {
      this.pos += len;
      return this.buf.subarray(this.pos - len, this.pos);
    }
    readBufferRemaining() {
      let b = this.buf.subarray(this.pos, this.end);
      this.pos = this.end;
      return b;
    }
    readBufferLengthEncoded() {
      const len = this.readUnsignedLength();
      if (len === null) return null;
      this.pos += len;
      return this.buf.subarray(this.pos - len, this.pos);
    }
    readStringNullEnded() {
      let initialPosition = this.pos;
      let cnt = 0;
      while (this.remaining() > 0 && this.buf[this.pos++] !== 0) {
        cnt++;
      }
      return this.buf.toString(void 0, initialPosition, initialPosition + cnt);
    }
    /**
     * Return unsigned Bigint.
     *
     * Could be used for reading other kind of value than InsertId, if reading possible null value
     * @returns {bigint}
     */
    readInsertId() {
      const type2 = this.buf[this.pos++];
      if (type2 < 251) return BigInt(type2);
      switch (type2) {
        case 252:
          return BigInt(this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8);
        case 253:
          return BigInt(this.buf[this.pos++] + this.buf[this.pos++] * 2 ** 8 + this.buf[this.pos++] * 2 ** 16);
        case 254:
          return this.readBigInt64();
      }
    }
    readAsciiStringLengthEncoded() {
      const len = this.readUnsignedLength();
      if (len === null) return null;
      this.pos += len;
      return this.buf.toString("ascii", this.pos - len, this.pos);
    }
    readStringLengthEncoded() {
      throw new Error("code is normally superseded by Node encoder or Iconv depending on charset used");
    }
    readBigIntLengthEncoded() {
      const len = this.buf[this.pos++];
      if (len < 16) {
        return BigInt(this._atoi(len));
      }
      if (len === 251) return null;
      return this.readBigIntFromLen(len);
    }
    readBigIntFromLen(len) {
      let result = 0n;
      let negate = false;
      let begin = this.pos;
      if (len > 0 && this.buf[begin] === 45) {
        negate = true;
        begin++;
      }
      for (; begin < this.pos + len; begin++) {
        result = result * 10n + BigInt(this.buf[begin] - 48);
      }
      this.pos += len;
      return negate ? -1n * result : result;
    }
    readDecimalLengthEncoded() {
      const len = this.buf[this.pos++];
      if (len === 251) return null;
      this.pos += len;
      return this.buf.toString("ascii", this.pos - len, this.pos);
    }
    readDate() {
      const len = this.buf[this.pos++];
      if (len === 251) return null;
      let res = [];
      let value = 0;
      let initPos = this.pos;
      this.pos += len;
      while (initPos < this.pos) {
        const char = this.buf[initPos++];
        if (char === 45) {
          res.push(value);
          value = 0;
        } else {
          value = value * 10 + char - 48;
        }
      }
      res.push(value);
      if (res[0] === 0 && res[1] === 0 && res[2] === 0) return null;
      return new Date(res[0], res[1] - 1, res[2]);
    }
    readBinaryDate(opts) {
      const len = this.buf[this.pos++];
      let year = 0;
      let month = 0;
      let day = 0;
      if (len > 0) {
        year = this.readInt16();
        if (len > 2) {
          month = this.readUInt8() - 1;
          if (len > 3) {
            day = this.readUInt8();
          }
        }
      }
      if (year === 0 && month === 0 && day === 0) return opts.dateStrings ? "0000-00-00" : null;
      if (opts.dateStrings) {
        return `${appendZero(year, 4)}-${appendZero(month + 1, 2)}-${appendZero(day, 2)}`;
      }
      return new Date(year, month, day);
    }
    readDateTime() {
      const len = this.buf[this.pos++];
      if (len === 251) return null;
      this.pos += len;
      const str2 = this.buf.toString("ascii", this.pos - len, this.pos);
      if (str2.startsWith("0000-00-00 00:00:00")) return null;
      return new Date(str2);
    }
    readBinaryDateTime() {
      const len = this.buf[this.pos++];
      let year = 0;
      let month = 0;
      let day = 0;
      let hour = 0;
      let min = 0;
      let sec = 0;
      let microSec = 0;
      if (len > 0) {
        year = this.readInt16();
        if (len > 2) {
          month = this.readUInt8();
          if (len > 3) {
            day = this.readUInt8();
            if (len > 4) {
              hour = this.readUInt8();
              min = this.readUInt8();
              sec = this.readUInt8();
              if (len > 7) {
                microSec = this.readUInt32();
              }
            }
          }
        }
      }
      if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0) return null;
      return new Date(year, month - 1, day, hour, min, sec, microSec / 1e3);
    }
    readBinaryDateTimeAsString(scale) {
      const len = this.buf[this.pos++];
      let year = 0;
      let month = 0;
      let day = 0;
      let hour = 0;
      let min = 0;
      let sec = 0;
      let microSec = 0;
      if (len > 0) {
        year = this.readInt16();
        if (len > 2) {
          month = this.readUInt8();
          if (len > 3) {
            day = this.readUInt8();
            if (len > 4) {
              hour = this.readUInt8();
              min = this.readUInt8();
              sec = this.readUInt8();
              if (len > 7) {
                microSec = this.readUInt32();
              }
            }
          }
        }
      }
      if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0)
        return "0000-00-00 00:00:00" + (scale > 0 ? ".000000".substring(0, scale + 1) : "");
      return appendZero(year, 4) + "-" + appendZero(month, 2) + "-" + appendZero(day, 2) + " " + appendZero(hour, 2) + ":" + appendZero(min, 2) + ":" + appendZero(sec, 2) + (microSec > 0 ? scale > 0 ? "." + appendZero(microSec, 6).substring(0, scale) : "." + appendZero(microSec, 6) : scale > 0 ? "." + appendZero(microSec, 6).substring(0, scale) : "");
    }
    readBinaryTime() {
      const len = this.buf[this.pos++];
      let negate = false;
      let hour = 0;
      let min = 0;
      let sec = 0;
      let microSec = 0;
      if (len > 0) {
        negate = this.buf[this.pos++] === 1;
        hour = this.readUInt32() * 24 + this.readUInt8();
        min = this.readUInt8();
        sec = this.readUInt8();
        if (len > 8) {
          microSec = this.readUInt32();
        }
      }
      let val = appendZero(hour, 2) + ":" + appendZero(min, 2) + ":" + appendZero(sec, 2);
      if (microSec > 0) {
        val += "." + appendZero(microSec, 6);
      }
      if (negate) return "-" + val;
      return val;
    }
    readFloat() {
      const val = this.buf.readFloatLE(this.pos);
      this.pos += 4;
      return val;
    }
    readDouble() {
      const val = this.buf.readDoubleLE(this.pos);
      this.pos += 8;
      return val;
    }
    readIntLengthEncoded() {
      const len = this.buf[this.pos++];
      if (len === 251) return null;
      return this._atoi(len);
    }
    _atoi(len) {
      let result = 0;
      let negate = false;
      let begin = this.pos;
      if (len > 0 && this.buf[begin] === 45) {
        negate = true;
        begin++;
      }
      for (; begin < this.pos + len; begin++) {
        result = result * 10 + (this.buf[begin] - 48);
      }
      this.pos += len;
      return negate ? -1 * result : result;
    }
    readFloatLengthCoded() {
      const len = this.readUnsignedLength();
      if (len === null) return null;
      this.pos += len;
      return +this.buf.toString("ascii", this.pos - len, this.pos);
    }
    skipLengthCodedNumber() {
      const type2 = this.buf[this.pos++];
      switch (type2) {
        case 251:
          return;
        case 252:
          this.pos += 2 + (65535 & this.buf[this.pos] + (this.buf[this.pos + 1] << 8));
          return;
        case 253:
          this.pos += 3 + (16777215 & this.buf[this.pos] + (this.buf[this.pos + 1] << 8) + (this.buf[this.pos + 2] << 16));
          return;
        case 254:
          this.pos += 8 + Number(this.buf.readBigUInt64LE(this.pos));
          return;
        default:
          this.pos += type2;
          return;
      }
    }
    length() {
      return this.end - this.pos;
    }
    subPacketLengthEncoded(len) {
    }
    /**
     * Parse ERR_Packet : https://mariadb.com/kb/en/library/err_packet/
     *
     * @param info              current connection info
     * @param sql               command sql
     * @param stack             additional stack trace
     * @returns {Error}
     */
    readError(info, sql, stack) {
      this.skip(1);
      let errno = this.readUInt16();
      let sqlState;
      let msg;
      if (this.peek() === 35) {
        this.skip(6);
        sqlState = this.buf.toString(void 0, this.pos - 5, this.pos);
        msg = this.readStringNullEnded();
      } else {
        sqlState = "HY000";
        msg = this.buf.toString(void 0, this.pos, this.end);
      }
      let fatal = sqlState.startsWith("08") || sqlState === "70100";
      return Errors.createError(msg, errno, info, sqlState, sql, fatal, stack);
    }
  }
  const appendZero = (val, len) => {
    let st = val.toString();
    while (st.length < len) {
      st = "0" + st;
    }
    return st;
  };
  packet = Packet;
  return packet;
}
var packetNodeEncoded;
var hasRequiredPacketNodeEncoded;
function requirePacketNodeEncoded() {
  if (hasRequiredPacketNodeEncoded) return packetNodeEncoded;
  hasRequiredPacketNodeEncoded = 1;
  const Packet = requirePacket();
  class PacketNodeEncoded extends Packet {
    constructor(encoding) {
      super();
      this.encoding = encoding === "utf8" ? void 0 : encoding;
    }
    readStringLengthEncoded() {
      const len = this.readUnsignedLength();
      if (len === null) return null;
      this.pos += len;
      return this.buf.toString(this.encoding, this.pos - len, this.pos);
    }
    static readString(encoding, buf, beg, len) {
      return buf.toString(encoding, beg, beg + len);
    }
    subPacketLengthEncoded(len) {
      this.skip(len);
      return new PacketNodeEncoded(this.encoding).update(this.buf, this.pos - len, this.pos);
    }
    readStringRemaining() {
      const str2 = this.buf.toString(this.encoding, this.pos, this.end);
      this.pos = this.end;
      return str2;
    }
  }
  packetNodeEncoded = PacketNodeEncoded;
  return packetNodeEncoded;
}
var lib$1 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer = require$$0$1;
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key)) continue;
    if (key === "SlowBuffer" || key === "Buffer") continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key)) continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str2) {
    if (this.addBOM) {
      str2 = BOMChar + str2;
      this.addBOM = false;
    }
    return this.encoder.write(str2);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$4.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str2) {
    return Buffer2.from(str2, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str2) {
    str2 = this.prevStr + str2;
    var completeQuads = str2.length - str2.length % 4;
    this.prevStr = str2.slice(completeQuads);
    str2 = str2.slice(0, completeQuads);
    return Buffer2.from(str2, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length * 3), bufIdx = 0;
    for (var i = 0; i < str2.length; i++) {
      var charCode = str2.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = { type: "_utf32", isLE: true };
  utf32.utf32be = { type: "_utf32", isLE: false };
  utf32.ucs4le = "utf32le";
  utf32.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str2) {
    var src2 = Buffer2.from(str2, "ucs2");
    var dst = Buffer2.alloc(src2.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src2.length; i += 2) {
      var code = src2.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src2) {
    if (src2.length === 0)
      return "";
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src2.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src2.length && overflow.length < 4; i++)
        overflow.push(src2[i]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i < src2.length - 3; i += 4) {
      if (isLE) {
        codepoint = src2[i] | src2[i + 1] << 8 | src2[i + 2] << 16 | src2[i + 3] << 24;
      } else {
        codepoint = src2[i + 3] | src2[i + 2] << 8 | src2[i + 1] << 16 | src2[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i < src2.length; i++) {
      overflow.push(src2[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16) invalidBE++;
            if (b[3] !== 0 || b[2] > 16) invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
  return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    var buf = Buffer2.from(str2, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254) return "utf-16le";
              if (b[0] === 254 && b[1] === 255) return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str2) {
    return Buffer2.from(str2.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str2) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str2.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str2.length; i2++) {
      var uChar = str2.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length);
    for (var i = 0; i < str2.length; i++)
      buf[i] = this.encodeBuf[str2.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp720": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48; j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129; k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48; l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED)
                fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node2 = this.decodeTables[0];
    for (var i2 = bytes.length - 1; i2 > 0; i2--) {
      var val = node2[bytes[i2]];
      if (val == UNASSIGNED) {
        node2[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq2 = [];
            for (var m = 0; m < len; m++)
              seq2.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq2);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq2, dbcsCode) {
    var uCode = seq2[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED) node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j = 1; j < seq2.length - 1; j++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object")
        node2 = oldVal;
      else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0)
          node2[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq2[seq2.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str2) {
    var newBuf = Buffer2.alloc(str2.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str2.length) break;
        var uCode = str2.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq2 = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq2.length - 1; k++) {
          uCode = seq2[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq2[seq2.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');
const require$$2 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');
const require$$3 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ],
  [
    "8135f437",
    ""
  ]
];
const uChars = [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536];
const gbChars = [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');
const require$$6 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');
const require$$7 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports) {
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = requireSafer().Buffer;
  streams = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1.exports;
  hasRequiredLib$1 = 1;
  (function(module) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling(), iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str2, encoding, options) {
      str2 = "" + (str2 || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str2);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling2.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling2.StripBOM(decoder, options);
      return decoder;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv.supportsStreams)
        return;
      var streams2 = requireStreams()(stream_module2);
      iconv.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
  })(lib$1);
  return lib$1.exports;
}
var packetNodeIconv;
var hasRequiredPacketNodeIconv;
function requirePacketNodeIconv() {
  if (hasRequiredPacketNodeIconv) return packetNodeIconv;
  hasRequiredPacketNodeIconv = 1;
  const Packet = requirePacket();
  const Iconv = requireLib$1();
  class PacketIconvEncoded extends Packet {
    constructor(encoding) {
      super();
      this.encoding = encoding;
    }
    readStringLengthEncoded() {
      const len = this.readUnsignedLength();
      if (len === null) return null;
      this.pos += len;
      return Iconv.decode(this.buf.subarray(this.pos - len, this.pos), this.encoding);
    }
    static readString(encoding, buf, beg, len) {
      return Iconv.decode(buf.subarray(beg, beg + len), encoding);
    }
    subPacketLengthEncoded(len) {
      this.skip(len);
      return new PacketIconvEncoded(this.encoding).update(this.buf, this.pos - len, this.pos);
    }
    readStringRemaining() {
      const str2 = Iconv.decode(this.buf.subarray(this.pos, this.end), this.encoding);
      this.pos = this.end;
      return str2;
    }
  }
  packetNodeIconv = PacketIconvEncoded;
  return packetNodeIconv;
}
var collations;
var hasRequiredCollations;
function requireCollations() {
  if (hasRequiredCollations) return collations;
  hasRequiredCollations = 1;
  let charsets = [];
  let defaultCharsets = [];
  class Collation {
    constructor(index, name, charset, maxLength) {
      this.index = index;
      this.name = name;
      this.charset = charset;
      this.maxLength = maxLength;
    }
    static fromCharset(charset) {
      return defaultCharsets[charset === "utf8mb3" ? "utf8" : charset];
    }
    static fromIndex(index) {
      if (index >= charsets.length) return void 0;
      return charsets[index];
    }
    static fromName(name) {
      for (let i = 0; i < charsets.length; i++) {
        let collation = charsets[i];
        if (collation && collation.name === name) {
          return collation;
        }
      }
      const nameWithMb4 = name.replace("UTF8_", "UTF8MB4_");
      for (let i = 0; i < charsets.length; i++) {
        let collation = charsets[i];
        if (collation && collation.name === nameWithMb4) {
          return collation;
        }
      }
      return void 0;
    }
  }
  charsets[1] = new Collation(1, "BIG5_CHINESE_CI", "big5", 2);
  charsets[2] = new Collation(2, "LATIN2_CZECH_CS", "latin2", 1);
  charsets[3] = new Collation(3, "DEC8_SWEDISH_CI", "dec8", 1);
  charsets[4] = new Collation(4, "CP850_GENERAL_CI", "cp850", 1);
  charsets[5] = new Collation(5, "LATIN1_GERMAN1_CI", "latin1", 1);
  charsets[6] = new Collation(6, "HP8_ENGLISH_CI", "hp8", 1);
  charsets[7] = new Collation(7, "KOI8R_GENERAL_CI", "koi8r", 1);
  charsets[8] = new Collation(8, "LATIN1_SWEDISH_CI", "latin1", 1);
  charsets[9] = new Collation(9, "LATIN2_GENERAL_CI", "latin2", 1);
  charsets[10] = new Collation(10, "SWE7_SWEDISH_CI", "swe7", 1);
  charsets[11] = new Collation(11, "ASCII_GENERAL_CI", "ascii", 1);
  charsets[12] = new Collation(12, "UJIS_JAPANESE_CI", "ujis", 3);
  charsets[13] = new Collation(13, "SJIS_JAPANESE_CI", "sjis", 2);
  charsets[14] = new Collation(14, "CP1251_BULGARIAN_CI", "cp1251", 1);
  charsets[15] = new Collation(15, "LATIN1_DANISH_CI", "latin1", 1);
  charsets[16] = new Collation(16, "HEBREW_GENERAL_CI", "hebrew", 1);
  charsets[18] = new Collation(18, "TIS620_THAI_CI", "tis620", 1);
  charsets[19] = new Collation(19, "EUCKR_KOREAN_CI", "euckr", 2);
  charsets[20] = new Collation(20, "LATIN7_ESTONIAN_CS", "latin7", 1);
  charsets[21] = new Collation(21, "LATIN2_HUNGARIAN_CI", "latin2", 1);
  charsets[22] = new Collation(22, "KOI8U_GENERAL_CI", "koi8u", 1);
  charsets[23] = new Collation(23, "CP1251_UKRAINIAN_CI", "cp1251", 1);
  charsets[24] = new Collation(24, "GB2312_CHINESE_CI", "gb2312", 2);
  charsets[25] = new Collation(25, "GREEK_GENERAL_CI", "greek", 1);
  charsets[26] = new Collation(26, "CP1250_GENERAL_CI", "cp1250", 1);
  charsets[27] = new Collation(27, "LATIN2_CROATIAN_CI", "latin2", 1);
  charsets[28] = new Collation(28, "GBK_CHINESE_CI", "gbk", 2);
  charsets[29] = new Collation(29, "CP1257_LITHUANIAN_CI", "cp1257", 1);
  charsets[30] = new Collation(30, "LATIN5_TURKISH_CI", "latin5", 1);
  charsets[31] = new Collation(31, "LATIN1_GERMAN2_CI", "latin1", 1);
  charsets[32] = new Collation(32, "ARMSCII8_GENERAL_CI", "armscii8", 1);
  charsets[33] = new Collation(33, "UTF8MB3_GENERAL_CI", "utf8", 3);
  charsets[34] = new Collation(34, "CP1250_CZECH_CS", "cp1250", 1);
  charsets[35] = new Collation(35, "UCS2_GENERAL_CI", "ucs2", 2);
  charsets[36] = new Collation(36, "CP866_GENERAL_CI", "cp866", 1);
  charsets[37] = new Collation(37, "KEYBCS2_GENERAL_CI", "keybcs2", 1);
  charsets[38] = new Collation(38, "MACCE_GENERAL_CI", "macce", 1);
  charsets[39] = new Collation(39, "MACROMAN_GENERAL_CI", "macroman", 1);
  charsets[40] = new Collation(40, "CP852_GENERAL_CI", "cp852", 1);
  charsets[41] = new Collation(41, "LATIN7_GENERAL_CI", "latin7", 1);
  charsets[42] = new Collation(42, "LATIN7_GENERAL_CS", "latin7", 1);
  charsets[43] = new Collation(43, "MACCE_BIN", "macce", 1);
  charsets[44] = new Collation(44, "CP1250_CROATIAN_CI", "cp1250", 1);
  charsets[45] = new Collation(45, "UTF8MB4_GENERAL_CI", "utf8", 4);
  charsets[46] = new Collation(46, "UTF8MB4_BIN", "utf8", 4);
  charsets[47] = new Collation(47, "LATIN1_BIN", "latin1", 1);
  charsets[48] = new Collation(48, "LATIN1_GENERAL_CI", "latin1", 1);
  charsets[49] = new Collation(49, "LATIN1_GENERAL_CS", "latin1", 1);
  charsets[50] = new Collation(50, "CP1251_BIN", "cp1251", 1);
  charsets[51] = new Collation(51, "CP1251_GENERAL_CI", "cp1251", 1);
  charsets[52] = new Collation(52, "CP1251_GENERAL_CS", "cp1251", 1);
  charsets[53] = new Collation(53, "MACROMAN_BIN", "macroman", 1);
  charsets[54] = new Collation(54, "UTF16_GENERAL_CI", "utf16", 4);
  charsets[55] = new Collation(55, "UTF16_BIN", "utf16", 4);
  charsets[56] = new Collation(56, "UTF16LE_GENERAL_CI", "utf16le", 4);
  charsets[57] = new Collation(57, "CP1256_GENERAL_CI", "cp1256", 1);
  charsets[58] = new Collation(58, "CP1257_BIN", "cp1257", 1);
  charsets[59] = new Collation(59, "CP1257_GENERAL_CI", "cp1257", 1);
  charsets[60] = new Collation(60, "UTF32_GENERAL_CI", "utf32", 4);
  charsets[61] = new Collation(61, "UTF32_BIN", "utf32", 4);
  charsets[62] = new Collation(62, "UTF16LE_BIN", "utf16le", 4);
  charsets[63] = new Collation(63, "BINARY", "binary", 1);
  charsets[64] = new Collation(64, "ARMSCII8_BIN", "armscii8", 1);
  charsets[65] = new Collation(65, "ASCII_BIN", "ascii", 1);
  charsets[66] = new Collation(66, "CP1250_BIN", "cp1250", 1);
  charsets[67] = new Collation(67, "CP1256_BIN", "cp1256", 1);
  charsets[68] = new Collation(68, "CP866_BIN", "cp866", 1);
  charsets[69] = new Collation(69, "DEC8_BIN", "dec8", 1);
  charsets[70] = new Collation(70, "GREEK_BIN", "greek", 1);
  charsets[71] = new Collation(71, "HEBREW_BIN", "hebrew", 1);
  charsets[72] = new Collation(72, "HP8_BIN", "hp8", 1);
  charsets[73] = new Collation(73, "KEYBCS2_BIN", "keybcs2", 1);
  charsets[74] = new Collation(74, "KOI8R_BIN", "koi8r", 1);
  charsets[75] = new Collation(75, "KOI8U_BIN", "koi8u", 1);
  charsets[76] = new Collation(76, "UTF8_TOLOWER_CI", "utf8", 3);
  charsets[77] = new Collation(77, "LATIN2_BIN", "latin2", 1);
  charsets[78] = new Collation(78, "LATIN5_BIN", "latin5", 1);
  charsets[79] = new Collation(79, "LATIN7_BIN", "latin7", 1);
  charsets[80] = new Collation(80, "CP850_BIN", "cp850", 1);
  charsets[81] = new Collation(81, "CP852_BIN", "cp852", 1);
  charsets[82] = new Collation(82, "SWE7_BIN", "swe7", 1);
  charsets[83] = new Collation(83, "UTF8MB3_BIN", "utf8", 3);
  charsets[84] = new Collation(84, "BIG5_BIN", "big5", 2);
  charsets[85] = new Collation(85, "EUCKR_BIN", "euckr", 2);
  charsets[86] = new Collation(86, "GB2312_BIN", "gb2312", 2);
  charsets[87] = new Collation(87, "GBK_BIN", "gbk", 2);
  charsets[88] = new Collation(88, "SJIS_BIN", "sjis", 2);
  charsets[89] = new Collation(89, "TIS620_BIN", "tis620", 1);
  charsets[90] = new Collation(90, "UCS2_BIN", "ucs2", 2);
  charsets[91] = new Collation(91, "UJIS_BIN", "ujis", 3);
  charsets[92] = new Collation(92, "GEOSTD8_GENERAL_CI", "geostd8", 1);
  charsets[93] = new Collation(93, "GEOSTD8_BIN", "geostd8", 1);
  charsets[94] = new Collation(94, "LATIN1_SPANISH_CI", "latin1", 1);
  charsets[95] = new Collation(95, "CP932_JAPANESE_CI", "cp932", 2);
  charsets[96] = new Collation(96, "CP932_BIN", "cp932", 2);
  charsets[97] = new Collation(97, "EUCJPMS_JAPANESE_CI", "eucjpms", 3);
  charsets[98] = new Collation(98, "EUCJPMS_BIN", "eucjpms", 3);
  charsets[99] = new Collation(99, "CP1250_POLISH_CI", "cp1250", 1);
  charsets[101] = new Collation(101, "UTF16_UNICODE_CI", "utf16", 4);
  charsets[102] = new Collation(102, "UTF16_ICELANDIC_CI", "utf16", 4);
  charsets[103] = new Collation(103, "UTF16_LATVIAN_CI", "utf16", 4);
  charsets[104] = new Collation(104, "UTF16_ROMANIAN_CI", "utf16", 4);
  charsets[105] = new Collation(105, "UTF16_SLOVENIAN_CI", "utf16", 4);
  charsets[106] = new Collation(106, "UTF16_POLISH_CI", "utf16", 4);
  charsets[107] = new Collation(107, "UTF16_ESTONIAN_CI", "utf16", 4);
  charsets[108] = new Collation(108, "UTF16_SPANISH_CI", "utf16", 4);
  charsets[109] = new Collation(109, "UTF16_SWEDISH_CI", "utf16", 4);
  charsets[110] = new Collation(110, "UTF16_TURKISH_CI", "utf16", 4);
  charsets[111] = new Collation(111, "UTF16_CZECH_CI", "utf16", 4);
  charsets[112] = new Collation(112, "UTF16_DANISH_CI", "utf16", 4);
  charsets[113] = new Collation(113, "UTF16_LITHUANIAN_CI", "utf16", 4);
  charsets[114] = new Collation(114, "UTF16_SLOVAK_CI", "utf16", 4);
  charsets[115] = new Collation(115, "UTF16_SPANISH2_CI", "utf16", 4);
  charsets[116] = new Collation(116, "UTF16_ROMAN_CI", "utf16", 4);
  charsets[117] = new Collation(117, "UTF16_PERSIAN_CI", "utf16", 4);
  charsets[118] = new Collation(118, "UTF16_ESPERANTO_CI", "utf16", 4);
  charsets[119] = new Collation(119, "UTF16_HUNGARIAN_CI", "utf16", 4);
  charsets[120] = new Collation(120, "UTF16_SINHALA_CI", "utf16", 4);
  charsets[121] = new Collation(121, "UTF16_GERMAN2_CI", "utf16", 4);
  charsets[122] = new Collation(122, "UTF16_CROATIAN_MYSQL561_CI", "utf16", 4);
  charsets[123] = new Collation(123, "UTF16_UNICODE_520_CI", "utf16", 4);
  charsets[124] = new Collation(124, "UTF16_VIETNAMESE_CI", "utf16", 4);
  charsets[128] = new Collation(128, "UCS2_UNICODE_CI", "ucs2", 2);
  charsets[129] = new Collation(129, "UCS2_ICELANDIC_CI", "ucs2", 2);
  charsets[130] = new Collation(130, "UCS2_LATVIAN_CI", "ucs2", 2);
  charsets[131] = new Collation(131, "UCS2_ROMANIAN_CI", "ucs2", 2);
  charsets[132] = new Collation(132, "UCS2_SLOVENIAN_CI", "ucs2", 2);
  charsets[133] = new Collation(133, "UCS2_POLISH_CI", "ucs2", 2);
  charsets[134] = new Collation(134, "UCS2_ESTONIAN_CI", "ucs2", 2);
  charsets[135] = new Collation(135, "UCS2_SPANISH_CI", "ucs2", 2);
  charsets[136] = new Collation(136, "UCS2_SWEDISH_CI", "ucs2", 2);
  charsets[137] = new Collation(137, "UCS2_TURKISH_CI", "ucs2", 2);
  charsets[138] = new Collation(138, "UCS2_CZECH_CI", "ucs2", 2);
  charsets[139] = new Collation(139, "UCS2_DANISH_CI", "ucs2", 2);
  charsets[140] = new Collation(140, "UCS2_LITHUANIAN_CI", "ucs2", 2);
  charsets[141] = new Collation(141, "UCS2_SLOVAK_CI", "ucs2", 2);
  charsets[142] = new Collation(142, "UCS2_SPANISH2_CI", "ucs2", 2);
  charsets[143] = new Collation(143, "UCS2_ROMAN_CI", "ucs2", 2);
  charsets[144] = new Collation(144, "UCS2_PERSIAN_CI", "ucs2", 2);
  charsets[145] = new Collation(145, "UCS2_ESPERANTO_CI", "ucs2", 2);
  charsets[146] = new Collation(146, "UCS2_HUNGARIAN_CI", "ucs2", 2);
  charsets[147] = new Collation(147, "UCS2_SINHALA_CI", "ucs2", 2);
  charsets[148] = new Collation(148, "UCS2_GERMAN2_CI", "ucs2", 2);
  charsets[149] = new Collation(149, "UCS2_CROATIAN_MYSQL561_CI", "ucs2", 2);
  charsets[150] = new Collation(150, "UCS2_UNICODE_520_CI", "ucs2", 2);
  charsets[151] = new Collation(151, "UCS2_VIETNAMESE_CI", "ucs2", 2);
  charsets[159] = new Collation(159, "UCS2_GENERAL_MYSQL500_CI", "ucs2", 2);
  charsets[160] = new Collation(160, "UTF32_UNICODE_CI", "utf32", 4);
  charsets[161] = new Collation(161, "UTF32_ICELANDIC_CI", "utf32", 4);
  charsets[162] = new Collation(162, "UTF32_LATVIAN_CI", "utf32", 4);
  charsets[163] = new Collation(163, "UTF32_ROMANIAN_CI", "utf32", 4);
  charsets[164] = new Collation(164, "UTF32_SLOVENIAN_CI", "utf32", 4);
  charsets[165] = new Collation(165, "UTF32_POLISH_CI", "utf32", 4);
  charsets[166] = new Collation(166, "UTF32_ESTONIAN_CI", "utf32", 4);
  charsets[167] = new Collation(167, "UTF32_SPANISH_CI", "utf32", 4);
  charsets[168] = new Collation(168, "UTF32_SWEDISH_CI", "utf32", 4);
  charsets[169] = new Collation(169, "UTF32_TURKISH_CI", "utf32", 4);
  charsets[170] = new Collation(170, "UTF32_CZECH_CI", "utf32", 4);
  charsets[171] = new Collation(171, "UTF32_DANISH_CI", "utf32", 4);
  charsets[172] = new Collation(172, "UTF32_LITHUANIAN_CI", "utf32", 4);
  charsets[173] = new Collation(173, "UTF32_SLOVAK_CI", "utf32", 4);
  charsets[174] = new Collation(174, "UTF32_SPANISH2_CI", "utf32", 4);
  charsets[175] = new Collation(175, "UTF32_ROMAN_CI", "utf32", 4);
  charsets[176] = new Collation(176, "UTF32_PERSIAN_CI", "utf32", 4);
  charsets[177] = new Collation(177, "UTF32_ESPERANTO_CI", "utf32", 4);
  charsets[178] = new Collation(178, "UTF32_HUNGARIAN_CI", "utf32", 4);
  charsets[179] = new Collation(179, "UTF32_SINHALA_CI", "utf32", 4);
  charsets[180] = new Collation(180, "UTF32_GERMAN2_CI", "utf32", 4);
  charsets[181] = new Collation(181, "UTF32_CROATIAN_MYSQL561_CI", "utf32", 4);
  charsets[182] = new Collation(182, "UTF32_UNICODE_520_CI", "utf32", 4);
  charsets[183] = new Collation(183, "UTF32_VIETNAMESE_CI", "utf32", 4);
  charsets[192] = new Collation(192, "UTF8MB3_UNICODE_CI", "utf8", 3);
  charsets[193] = new Collation(193, "UTF8MB3_ICELANDIC_CI", "utf8", 3);
  charsets[194] = new Collation(194, "UTF8MB3_LATVIAN_CI", "utf8", 3);
  charsets[195] = new Collation(195, "UTF8MB3_ROMANIAN_CI", "utf8", 3);
  charsets[196] = new Collation(196, "UTF8MB3_SLOVENIAN_CI", "utf8", 3);
  charsets[197] = new Collation(197, "UTF8MB3_POLISH_CI", "utf8", 3);
  charsets[198] = new Collation(198, "UTF8MB3_ESTONIAN_CI", "utf8", 3);
  charsets[199] = new Collation(199, "UTF8MB3_SPANISH_CI", "utf8", 3);
  charsets[200] = new Collation(200, "UTF8MB3_SWEDISH_CI", "utf8", 3);
  charsets[201] = new Collation(201, "UTF8MB3_TURKISH_CI", "utf8", 3);
  charsets[202] = new Collation(202, "UTF8MB3_CZECH_CI", "utf8", 3);
  charsets[203] = new Collation(203, "UTF8MB3_DANISH_CI", "utf8", 3);
  charsets[204] = new Collation(204, "UTF8MB3_LITHUANIAN_CI", "utf8", 3);
  charsets[205] = new Collation(205, "UTF8MB3_SLOVAK_CI", "utf8", 3);
  charsets[206] = new Collation(206, "UTF8MB3_SPANISH2_CI", "utf8", 3);
  charsets[207] = new Collation(207, "UTF8MB3_ROMAN_CI", "utf8", 3);
  charsets[208] = new Collation(208, "UTF8MB3_PERSIAN_CI", "utf8", 3);
  charsets[209] = new Collation(209, "UTF8MB3_ESPERANTO_CI", "utf8", 3);
  charsets[210] = new Collation(210, "UTF8MB3_HUNGARIAN_CI", "utf8", 3);
  charsets[211] = new Collation(211, "UTF8MB3_SINHALA_CI", "utf8", 3);
  charsets[212] = new Collation(212, "UTF8MB3_GERMAN2_CI", "utf8", 3);
  charsets[213] = new Collation(213, "UTF8MB3_CROATIAN_MYSQL561_CI", "utf8", 3);
  charsets[214] = new Collation(214, "UTF8MB3_UNICODE_520_CI", "utf8", 3);
  charsets[215] = new Collation(215, "UTF8MB3_VIETNAMESE_CI", "utf8", 3);
  charsets[223] = new Collation(223, "UTF8MB3_GENERAL_MYSQL500_CI", "utf8", 3);
  charsets[224] = new Collation(224, "UTF8MB4_UNICODE_CI", "utf8", 4);
  charsets[225] = new Collation(225, "UTF8MB4_ICELANDIC_CI", "utf8", 4);
  charsets[226] = new Collation(226, "UTF8MB4_LATVIAN_CI", "utf8", 4);
  charsets[227] = new Collation(227, "UTF8MB4_ROMANIAN_CI", "utf8", 4);
  charsets[228] = new Collation(228, "UTF8MB4_SLOVENIAN_CI", "utf8", 4);
  charsets[229] = new Collation(229, "UTF8MB4_POLISH_CI", "utf8", 4);
  charsets[230] = new Collation(230, "UTF8MB4_ESTONIAN_CI", "utf8", 4);
  charsets[231] = new Collation(231, "UTF8MB4_SPANISH_CI", "utf8", 4);
  charsets[232] = new Collation(232, "UTF8MB4_SWEDISH_CI", "utf8", 4);
  charsets[233] = new Collation(233, "UTF8MB4_TURKISH_CI", "utf8", 4);
  charsets[234] = new Collation(234, "UTF8MB4_CZECH_CI", "utf8", 4);
  charsets[235] = new Collation(235, "UTF8MB4_DANISH_CI", "utf8", 4);
  charsets[236] = new Collation(236, "UTF8MB4_LITHUANIAN_CI", "utf8", 4);
  charsets[237] = new Collation(237, "UTF8MB4_SLOVAK_CI", "utf8", 4);
  charsets[238] = new Collation(238, "UTF8MB4_SPANISH2_CI", "utf8", 4);
  charsets[239] = new Collation(239, "UTF8MB4_ROMAN_CI", "utf8", 4);
  charsets[240] = new Collation(240, "UTF8MB4_PERSIAN_CI", "utf8", 4);
  charsets[241] = new Collation(241, "UTF8MB4_ESPERANTO_CI", "utf8", 4);
  charsets[242] = new Collation(242, "UTF8MB4_HUNGARIAN_CI", "utf8", 4);
  charsets[243] = new Collation(243, "UTF8MB4_SINHALA_CI", "utf8", 4);
  charsets[244] = new Collation(244, "UTF8MB4_GERMAN2_CI", "utf8", 4);
  charsets[245] = new Collation(245, "UTF8MB4_CROATIAN_MYSQL561_CI", "utf8", 4);
  charsets[246] = new Collation(246, "UTF8MB4_UNICODE_520_CI", "utf8", 4);
  charsets[247] = new Collation(247, "UTF8MB4_VIETNAMESE_CI", "utf8", 4);
  charsets[248] = new Collation(248, "GB18030_CHINESE_CI", "gb18030", 4);
  charsets[249] = new Collation(249, "GB18030_BIN", "gb18030", 4);
  charsets[250] = new Collation(250, "GB18030_UNICODE_520_CI", "gb18030", 4);
  charsets[255] = new Collation(255, "UTF8MB4_0900_AI_CI", "utf8", 4);
  charsets[256] = new Collation(256, "UTF8MB4_DE_PB_0900_AI_CI", "utf8", 4);
  charsets[257] = new Collation(257, "UTF8MB4_IS_0900_AI_CI", "utf8", 4);
  charsets[258] = new Collation(258, "UTF8MB4_LV_0900_AI_CI", "utf8", 4);
  charsets[259] = new Collation(259, "UTF8MB4_RO_0900_AI_CI", "utf8", 4);
  charsets[260] = new Collation(260, "UTF8MB4_SL_0900_AI_CI", "utf8", 4);
  charsets[261] = new Collation(261, "UTF8MB4_PL_0900_AI_CI", "utf8", 4);
  charsets[262] = new Collation(262, "UTF8MB4_ET_0900_AI_CI", "utf8", 4);
  charsets[263] = new Collation(263, "UTF8MB4_ES_0900_AI_CI", "utf8", 4);
  charsets[264] = new Collation(264, "UTF8MB4_SV_0900_AI_CI", "utf8", 4);
  charsets[265] = new Collation(265, "UTF8MB4_TR_0900_AI_CI", "utf8", 4);
  charsets[266] = new Collation(266, "UTF8MB4_CS_0900_AI_CI", "utf8", 4);
  charsets[267] = new Collation(267, "UTF8MB4_DA_0900_AI_CI", "utf8", 4);
  charsets[268] = new Collation(268, "UTF8MB4_LT_0900_AI_CI", "utf8", 4);
  charsets[269] = new Collation(269, "UTF8MB4_SK_0900_AI_CI", "utf8", 4);
  charsets[270] = new Collation(270, "UTF8MB4_ES_TRAD_0900_AI_CI", "utf8", 4);
  charsets[271] = new Collation(271, "UTF8MB4_LA_0900_AI_CI", "utf8", 4);
  charsets[273] = new Collation(273, "UTF8MB4_EO_0900_AI_CI", "utf8", 4);
  charsets[274] = new Collation(274, "UTF8MB4_HU_0900_AI_CI", "utf8", 4);
  charsets[275] = new Collation(275, "UTF8MB4_HR_0900_AI_CI", "utf8", 4);
  charsets[277] = new Collation(277, "UTF8MB4_VI_0900_AI_CI", "utf8", 4);
  charsets[278] = new Collation(278, "UTF8MB4_0900_AS_CS", "utf8", 4);
  charsets[279] = new Collation(279, "UTF8MB4_DE_PB_0900_AS_CS", "utf8", 4);
  charsets[280] = new Collation(280, "UTF8MB4_IS_0900_AS_CS", "utf8", 4);
  charsets[281] = new Collation(281, "UTF8MB4_LV_0900_AS_CS", "utf8", 4);
  charsets[282] = new Collation(282, "UTF8MB4_RO_0900_AS_CS", "utf8", 4);
  charsets[283] = new Collation(283, "UTF8MB4_SL_0900_AS_CS", "utf8", 4);
  charsets[284] = new Collation(284, "UTF8MB4_PL_0900_AS_CS", "utf8", 4);
  charsets[285] = new Collation(285, "UTF8MB4_ET_0900_AS_CS", "utf8", 4);
  charsets[286] = new Collation(286, "UTF8MB4_ES_0900_AS_CS", "utf8", 4);
  charsets[287] = new Collation(287, "UTF8MB4_SV_0900_AS_CS", "utf8", 4);
  charsets[288] = new Collation(288, "UTF8MB4_TR_0900_AS_CS", "utf8", 4);
  charsets[289] = new Collation(289, "UTF8MB4_CS_0900_AS_CS", "utf8", 4);
  charsets[290] = new Collation(290, "UTF8MB4_DA_0900_AS_CS", "utf8", 4);
  charsets[291] = new Collation(291, "UTF8MB4_LT_0900_AS_CS", "utf8", 4);
  charsets[292] = new Collation(292, "UTF8MB4_SK_0900_AS_CS", "utf8", 4);
  charsets[293] = new Collation(293, "UTF8MB4_ES_TRAD_0900_AS_CS", "utf8", 4);
  charsets[294] = new Collation(294, "UTF8MB4_LA_0900_AS_CS", "utf8", 4);
  charsets[296] = new Collation(296, "UTF8MB4_EO_0900_AS_CS", "utf8", 4);
  charsets[297] = new Collation(297, "UTF8MB4_HU_0900_AS_CS", "utf8", 4);
  charsets[298] = new Collation(298, "UTF8MB4_HR_0900_AS_CS", "utf8", 4);
  charsets[300] = new Collation(300, "UTF8MB4_VI_0900_AS_CS", "utf8", 4);
  charsets[303] = new Collation(303, "UTF8MB4_JA_0900_AS_CS", "utf8", 4);
  charsets[304] = new Collation(304, "UTF8MB4_JA_0900_AS_CS_KS", "utf8", 4);
  charsets[305] = new Collation(305, "UTF8MB4_0900_AS_CI", "utf8", 4);
  charsets[306] = new Collation(306, "UTF8MB4_RU_0900_AI_CI", "utf8", 4);
  charsets[307] = new Collation(307, "UTF8MB4_RU_0900_AS_CS", "utf8", 4);
  charsets[308] = new Collation(308, "UTF8MB4_ZH_0900_AS_CS", "utf8", 4);
  charsets[309] = new Collation(309, "UTF8MB4_0900_BIN", "utf8", 4);
  charsets[576] = new Collation(576, "UTF8MB3_CROATIAN_CI", "utf8", 3);
  charsets[577] = new Collation(577, "UTF8MB3_MYANMAR_CI", "utf8", 3);
  charsets[578] = new Collation(578, "UTF8MB3_THAI_520_W2", "utf8", 3);
  charsets[608] = new Collation(608, "UTF8MB4_CROATIAN_CI", "utf8", 4);
  charsets[609] = new Collation(609, "UTF8MB4_MYANMAR_CI", "utf8", 4);
  charsets[610] = new Collation(610, "UTF8MB4_THAI_520_W2", "utf8", 4);
  charsets[640] = new Collation(640, "UCS2_CROATIAN_CI", "ucs2", 2);
  charsets[641] = new Collation(641, "UCS2_MYANMAR_CI", "ucs2", 2);
  charsets[642] = new Collation(642, "UCS2_THAI_520_W2", "ucs2", 2);
  charsets[672] = new Collation(672, "UTF16_CROATIAN_CI", "utf16", 4);
  charsets[673] = new Collation(673, "UTF16_MYANMAR_CI", "utf16", 4);
  charsets[674] = new Collation(674, "UTF16_THAI_520_W2", "utf16", 4);
  charsets[736] = new Collation(736, "UTF32_CROATIAN_CI", "utf32", 4);
  charsets[737] = new Collation(737, "UTF32_MYANMAR_CI", "utf32", 4);
  charsets[738] = new Collation(738, "UTF32_THAI_520_W2", "utf32", 4);
  charsets[1025] = new Collation(1025, "BIG5_CHINESE_NOPAD_CI", "big5", 2);
  charsets[1027] = new Collation(1027, "DEC8_SWEDISH_NOPAD_CI", "dec8", 1);
  charsets[1028] = new Collation(1028, "CP850_GENERAL_NOPAD_CI", "cp850", 1);
  charsets[1030] = new Collation(1030, "HP8_ENGLISH_NOPAD_CI", "hp8", 1);
  charsets[1031] = new Collation(1031, "KOI8R_GENERAL_NOPAD_CI", "koi8r", 1);
  charsets[1032] = new Collation(1032, "LATIN1_SWEDISH_NOPAD_CI", "latin1", 1);
  charsets[1033] = new Collation(1033, "LATIN2_GENERAL_NOPAD_CI", "latin2", 1);
  charsets[1034] = new Collation(1034, "SWE7_SWEDISH_NOPAD_CI", "swe7", 1);
  charsets[1035] = new Collation(1035, "ASCII_GENERAL_NOPAD_CI", "ascii", 1);
  charsets[1036] = new Collation(1036, "UJIS_JAPANESE_NOPAD_CI", "ujis", 3);
  charsets[1037] = new Collation(1037, "SJIS_JAPANESE_NOPAD_CI", "sjis", 2);
  charsets[1040] = new Collation(1040, "HEBREW_GENERAL_NOPAD_CI", "hebrew", 1);
  charsets[1042] = new Collation(1042, "TIS620_THAI_NOPAD_CI", "tis620", 1);
  charsets[1043] = new Collation(1043, "EUCKR_KOREAN_NOPAD_CI", "euckr", 2);
  charsets[1046] = new Collation(1046, "KOI8U_GENERAL_NOPAD_CI", "koi8u", 1);
  charsets[1048] = new Collation(1048, "GB2312_CHINESE_NOPAD_CI", "gb2312", 2);
  charsets[1049] = new Collation(1049, "GREEK_GENERAL_NOPAD_CI", "greek", 1);
  charsets[1050] = new Collation(1050, "CP1250_GENERAL_NOPAD_CI", "cp1250", 1);
  charsets[1052] = new Collation(1052, "GBK_CHINESE_NOPAD_CI", "gbk", 2);
  charsets[1054] = new Collation(1054, "LATIN5_TURKISH_NOPAD_CI", "latin5", 1);
  charsets[1056] = new Collation(1056, "ARMSCII8_GENERAL_NOPAD_CI", "armscii8", 1);
  charsets[1057] = new Collation(1057, "UTF8MB3_GENERAL_NOPAD_CI", "utf8", 3);
  charsets[1059] = new Collation(1059, "UCS2_GENERAL_NOPAD_CI", "ucs2", 2);
  charsets[1060] = new Collation(1060, "CP866_GENERAL_NOPAD_CI", "cp866", 1);
  charsets[1061] = new Collation(1061, "KEYBCS2_GENERAL_NOPAD_CI", "keybcs2", 1);
  charsets[1062] = new Collation(1062, "MACCE_GENERAL_NOPAD_CI", "macce", 1);
  charsets[1063] = new Collation(1063, "MACROMAN_GENERAL_NOPAD_CI", "macroman", 1);
  charsets[1064] = new Collation(1064, "CP852_GENERAL_NOPAD_CI", "cp852", 1);
  charsets[1065] = new Collation(1065, "LATIN7_GENERAL_NOPAD_CI", "latin7", 1);
  charsets[1067] = new Collation(1067, "MACCE_NOPAD_BIN", "macce", 1);
  charsets[1069] = new Collation(1069, "UTF8MB4_GENERAL_NOPAD_CI", "utf8", 4);
  charsets[1070] = new Collation(1070, "UTF8MB4_NOPAD_BIN", "utf8", 4);
  charsets[1071] = new Collation(1071, "LATIN1_NOPAD_BIN", "latin1", 1);
  charsets[1074] = new Collation(1074, "CP1251_NOPAD_BIN", "cp1251", 1);
  charsets[1075] = new Collation(1075, "CP1251_GENERAL_NOPAD_CI", "cp1251", 1);
  charsets[1077] = new Collation(1077, "MACROMAN_NOPAD_BIN", "macroman", 1);
  charsets[1078] = new Collation(1078, "UTF16_GENERAL_NOPAD_CI", "utf16", 4);
  charsets[1079] = new Collation(1079, "UTF16_NOPAD_BIN", "utf16", 4);
  charsets[1080] = new Collation(1080, "UTF16LE_GENERAL_NOPAD_CI", "utf16le", 4);
  charsets[1081] = new Collation(1081, "CP1256_GENERAL_NOPAD_CI", "cp1256", 1);
  charsets[1082] = new Collation(1082, "CP1257_NOPAD_BIN", "cp1257", 1);
  charsets[1083] = new Collation(1083, "CP1257_GENERAL_NOPAD_CI", "cp1257", 1);
  charsets[1084] = new Collation(1084, "UTF32_GENERAL_NOPAD_CI", "utf32", 4);
  charsets[1085] = new Collation(1085, "UTF32_NOPAD_BIN", "utf32", 4);
  charsets[1086] = new Collation(1086, "UTF16LE_NOPAD_BIN", "utf16le", 4);
  charsets[1088] = new Collation(1088, "ARMSCII8_NOPAD_BIN", "armscii8", 1);
  charsets[1089] = new Collation(1089, "ASCII_NOPAD_BIN", "ascii", 1);
  charsets[1090] = new Collation(1090, "CP1250_NOPAD_BIN", "cp1250", 1);
  charsets[1091] = new Collation(1091, "CP1256_NOPAD_BIN", "cp1256", 1);
  charsets[1092] = new Collation(1092, "CP866_NOPAD_BIN", "cp866", 1);
  charsets[1093] = new Collation(1093, "DEC8_NOPAD_BIN", "dec8", 1);
  charsets[1094] = new Collation(1094, "GREEK_NOPAD_BIN", "greek", 1);
  charsets[1095] = new Collation(1095, "HEBREW_NOPAD_BIN", "hebrew", 1);
  charsets[1096] = new Collation(1096, "HP8_NOPAD_BIN", "hp8", 1);
  charsets[1097] = new Collation(1097, "KEYBCS2_NOPAD_BIN", "keybcs2", 1);
  charsets[1098] = new Collation(1098, "KOI8R_NOPAD_BIN", "koi8r", 1);
  charsets[1099] = new Collation(1099, "KOI8U_NOPAD_BIN", "koi8u", 1);
  charsets[1101] = new Collation(1101, "LATIN2_NOPAD_BIN", "latin2", 1);
  charsets[1102] = new Collation(1102, "LATIN5_NOPAD_BIN", "latin5", 1);
  charsets[1103] = new Collation(1103, "LATIN7_NOPAD_BIN", "latin7", 1);
  charsets[1104] = new Collation(1104, "CP850_NOPAD_BIN", "cp850", 1);
  charsets[1105] = new Collation(1105, "CP852_NOPAD_BIN", "cp852", 1);
  charsets[1106] = new Collation(1106, "SWE7_NOPAD_BIN", "swe7", 1);
  charsets[1107] = new Collation(1107, "UTF8MB3_NOPAD_BIN", "utf8", 3);
  charsets[1108] = new Collation(1108, "BIG5_NOPAD_BIN", "big5", 2);
  charsets[1109] = new Collation(1109, "EUCKR_NOPAD_BIN", "euckr", 2);
  charsets[1110] = new Collation(1110, "GB2312_NOPAD_BIN", "gb2312", 2);
  charsets[1111] = new Collation(1111, "GBK_NOPAD_BIN", "gbk", 2);
  charsets[1112] = new Collation(1112, "SJIS_NOPAD_BIN", "sjis", 2);
  charsets[1113] = new Collation(1113, "TIS620_NOPAD_BIN", "tis620", 1);
  charsets[1114] = new Collation(1114, "UCS2_NOPAD_BIN", "ucs2", 2);
  charsets[1115] = new Collation(1115, "UJIS_NOPAD_BIN", "ujis", 3);
  charsets[1116] = new Collation(1116, "GEOSTD8_GENERAL_NOPAD_CI", "geostd8", 1);
  charsets[1117] = new Collation(1117, "GEOSTD8_NOPAD_BIN", "geostd8", 1);
  charsets[1119] = new Collation(1119, "CP932_JAPANESE_NOPAD_CI", "cp932", 2);
  charsets[1120] = new Collation(1120, "CP932_NOPAD_BIN", "cp932", 2);
  charsets[1121] = new Collation(1121, "EUCJPMS_JAPANESE_NOPAD_CI", "eucjpms", 3);
  charsets[1122] = new Collation(1122, "EUCJPMS_NOPAD_BIN", "eucjpms", 3);
  charsets[1125] = new Collation(1125, "UTF16_UNICODE_NOPAD_CI", "utf16", 4);
  charsets[1147] = new Collation(1147, "UTF16_UNICODE_520_NOPAD_CI", "utf16", 4);
  charsets[1152] = new Collation(1152, "UCS2_UNICODE_NOPAD_CI", "ucs2", 2);
  charsets[1174] = new Collation(1174, "UCS2_UNICODE_520_NOPAD_CI", "ucs2", 2);
  charsets[1184] = new Collation(1184, "UTF32_UNICODE_NOPAD_CI", "utf32", 4);
  charsets[1206] = new Collation(1206, "UTF32_UNICODE_520_NOPAD_CI", "utf32", 4);
  charsets[1216] = new Collation(1216, "UTF8MB3_UNICODE_NOPAD_CI", "utf8", 3);
  charsets[1238] = new Collation(1238, "UTF8MB3_UNICODE_520_NOPAD_CI", "utf8", 3);
  charsets[1248] = new Collation(1248, "UTF8MB4_UNICODE_NOPAD_CI", "utf8", 4);
  charsets[1270] = new Collation(1270, "UTF8MB4_UNICODE_520_NOPAD_CI", "utf8", 4);
  charsets[2048] = new Collation(2048, "UCA1400_AI_CI", "utf8", 3);
  charsets[2049] = new Collation(2049, "UCA1400_AI_CS", "utf8", 3);
  charsets[2050] = new Collation(2050, "UCA1400_AS_CI", "utf8", 3);
  charsets[2051] = new Collation(2051, "UCA1400_AS_CS", "utf8", 3);
  charsets[2052] = new Collation(2052, "UCA1400_NOPAD_AI_CI", "utf8", 3);
  charsets[2053] = new Collation(2053, "UCA1400_NOPAD_AI_CS", "utf8", 3);
  charsets[2054] = new Collation(2054, "UCA1400_NOPAD_AS_CI", "utf8", 3);
  charsets[2055] = new Collation(2055, "UCA1400_NOPAD_AS_CS", "utf8", 3);
  charsets[2056] = new Collation(2056, "UCA1400_ICELANDIC_AI_CI", "utf8", 3);
  charsets[2057] = new Collation(2057, "UCA1400_ICELANDIC_AI_CS", "utf8", 3);
  charsets[2058] = new Collation(2058, "UCA1400_ICELANDIC_AS_CI", "utf8", 3);
  charsets[2059] = new Collation(2059, "UCA1400_ICELANDIC_AS_CS", "utf8", 3);
  charsets[2060] = new Collation(2060, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf8", 3);
  charsets[2061] = new Collation(2061, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf8", 3);
  charsets[2062] = new Collation(2062, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf8", 3);
  charsets[2063] = new Collation(2063, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf8", 3);
  charsets[2064] = new Collation(2064, "UCA1400_LATVIAN_AI_CI", "utf8", 3);
  charsets[2065] = new Collation(2065, "UCA1400_LATVIAN_AI_CS", "utf8", 3);
  charsets[2066] = new Collation(2066, "UCA1400_LATVIAN_AS_CI", "utf8", 3);
  charsets[2067] = new Collation(2067, "UCA1400_LATVIAN_AS_CS", "utf8", 3);
  charsets[2068] = new Collation(2068, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf8", 3);
  charsets[2069] = new Collation(2069, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf8", 3);
  charsets[2070] = new Collation(2070, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf8", 3);
  charsets[2071] = new Collation(2071, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf8", 3);
  charsets[2072] = new Collation(2072, "UCA1400_ROMANIAN_AI_CI", "utf8", 3);
  charsets[2073] = new Collation(2073, "UCA1400_ROMANIAN_AI_CS", "utf8", 3);
  charsets[2074] = new Collation(2074, "UCA1400_ROMANIAN_AS_CI", "utf8", 3);
  charsets[2075] = new Collation(2075, "UCA1400_ROMANIAN_AS_CS", "utf8", 3);
  charsets[2076] = new Collation(2076, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf8", 3);
  charsets[2077] = new Collation(2077, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf8", 3);
  charsets[2078] = new Collation(2078, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf8", 3);
  charsets[2079] = new Collation(2079, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf8", 3);
  charsets[2080] = new Collation(2080, "UCA1400_SLOVENIAN_AI_CI", "utf8", 3);
  charsets[2081] = new Collation(2081, "UCA1400_SLOVENIAN_AI_CS", "utf8", 3);
  charsets[2082] = new Collation(2082, "UCA1400_SLOVENIAN_AS_CI", "utf8", 3);
  charsets[2083] = new Collation(2083, "UCA1400_SLOVENIAN_AS_CS", "utf8", 3);
  charsets[2084] = new Collation(2084, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf8", 3);
  charsets[2085] = new Collation(2085, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf8", 3);
  charsets[2086] = new Collation(2086, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf8", 3);
  charsets[2087] = new Collation(2087, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf8", 3);
  charsets[2088] = new Collation(2088, "UCA1400_POLISH_AI_CI", "utf8", 3);
  charsets[2089] = new Collation(2089, "UCA1400_POLISH_AI_CS", "utf8", 3);
  charsets[2090] = new Collation(2090, "UCA1400_POLISH_AS_CI", "utf8", 3);
  charsets[2091] = new Collation(2091, "UCA1400_POLISH_AS_CS", "utf8", 3);
  charsets[2092] = new Collation(2092, "UCA1400_POLISH_NOPAD_AI_CI", "utf8", 3);
  charsets[2093] = new Collation(2093, "UCA1400_POLISH_NOPAD_AI_CS", "utf8", 3);
  charsets[2094] = new Collation(2094, "UCA1400_POLISH_NOPAD_AS_CI", "utf8", 3);
  charsets[2095] = new Collation(2095, "UCA1400_POLISH_NOPAD_AS_CS", "utf8", 3);
  charsets[2096] = new Collation(2096, "UCA1400_ESTONIAN_AI_CI", "utf8", 3);
  charsets[2097] = new Collation(2097, "UCA1400_ESTONIAN_AI_CS", "utf8", 3);
  charsets[2098] = new Collation(2098, "UCA1400_ESTONIAN_AS_CI", "utf8", 3);
  charsets[2099] = new Collation(2099, "UCA1400_ESTONIAN_AS_CS", "utf8", 3);
  charsets[2100] = new Collation(2100, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf8", 3);
  charsets[2101] = new Collation(2101, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf8", 3);
  charsets[2102] = new Collation(2102, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf8", 3);
  charsets[2103] = new Collation(2103, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf8", 3);
  charsets[2104] = new Collation(2104, "UCA1400_SPANISH_AI_CI", "utf8", 3);
  charsets[2105] = new Collation(2105, "UCA1400_SPANISH_AI_CS", "utf8", 3);
  charsets[2106] = new Collation(2106, "UCA1400_SPANISH_AS_CI", "utf8", 3);
  charsets[2107] = new Collation(2107, "UCA1400_SPANISH_AS_CS", "utf8", 3);
  charsets[2108] = new Collation(2108, "UCA1400_SPANISH_NOPAD_AI_CI", "utf8", 3);
  charsets[2109] = new Collation(2109, "UCA1400_SPANISH_NOPAD_AI_CS", "utf8", 3);
  charsets[2110] = new Collation(2110, "UCA1400_SPANISH_NOPAD_AS_CI", "utf8", 3);
  charsets[2111] = new Collation(2111, "UCA1400_SPANISH_NOPAD_AS_CS", "utf8", 3);
  charsets[2112] = new Collation(2112, "UCA1400_SWEDISH_AI_CI", "utf8", 3);
  charsets[2113] = new Collation(2113, "UCA1400_SWEDISH_AI_CS", "utf8", 3);
  charsets[2114] = new Collation(2114, "UCA1400_SWEDISH_AS_CI", "utf8", 3);
  charsets[2115] = new Collation(2115, "UCA1400_SWEDISH_AS_CS", "utf8", 3);
  charsets[2116] = new Collation(2116, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf8", 3);
  charsets[2117] = new Collation(2117, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf8", 3);
  charsets[2118] = new Collation(2118, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf8", 3);
  charsets[2119] = new Collation(2119, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf8", 3);
  charsets[2120] = new Collation(2120, "UCA1400_TURKISH_AI_CI", "utf8", 3);
  charsets[2121] = new Collation(2121, "UCA1400_TURKISH_AI_CS", "utf8", 3);
  charsets[2122] = new Collation(2122, "UCA1400_TURKISH_AS_CI", "utf8", 3);
  charsets[2123] = new Collation(2123, "UCA1400_TURKISH_AS_CS", "utf8", 3);
  charsets[2124] = new Collation(2124, "UCA1400_TURKISH_NOPAD_AI_CI", "utf8", 3);
  charsets[2125] = new Collation(2125, "UCA1400_TURKISH_NOPAD_AI_CS", "utf8", 3);
  charsets[2126] = new Collation(2126, "UCA1400_TURKISH_NOPAD_AS_CI", "utf8", 3);
  charsets[2127] = new Collation(2127, "UCA1400_TURKISH_NOPAD_AS_CS", "utf8", 3);
  charsets[2128] = new Collation(2128, "UCA1400_CZECH_AI_CI", "utf8", 3);
  charsets[2129] = new Collation(2129, "UCA1400_CZECH_AI_CS", "utf8", 3);
  charsets[2130] = new Collation(2130, "UCA1400_CZECH_AS_CI", "utf8", 3);
  charsets[2131] = new Collation(2131, "UCA1400_CZECH_AS_CS", "utf8", 3);
  charsets[2132] = new Collation(2132, "UCA1400_CZECH_NOPAD_AI_CI", "utf8", 3);
  charsets[2133] = new Collation(2133, "UCA1400_CZECH_NOPAD_AI_CS", "utf8", 3);
  charsets[2134] = new Collation(2134, "UCA1400_CZECH_NOPAD_AS_CI", "utf8", 3);
  charsets[2135] = new Collation(2135, "UCA1400_CZECH_NOPAD_AS_CS", "utf8", 3);
  charsets[2136] = new Collation(2136, "UCA1400_DANISH_AI_CI", "utf8", 3);
  charsets[2137] = new Collation(2137, "UCA1400_DANISH_AI_CS", "utf8", 3);
  charsets[2138] = new Collation(2138, "UCA1400_DANISH_AS_CI", "utf8", 3);
  charsets[2139] = new Collation(2139, "UCA1400_DANISH_AS_CS", "utf8", 3);
  charsets[2140] = new Collation(2140, "UCA1400_DANISH_NOPAD_AI_CI", "utf8", 3);
  charsets[2141] = new Collation(2141, "UCA1400_DANISH_NOPAD_AI_CS", "utf8", 3);
  charsets[2142] = new Collation(2142, "UCA1400_DANISH_NOPAD_AS_CI", "utf8", 3);
  charsets[2143] = new Collation(2143, "UCA1400_DANISH_NOPAD_AS_CS", "utf8", 3);
  charsets[2144] = new Collation(2144, "UCA1400_LITHUANIAN_AI_CI", "utf8", 3);
  charsets[2145] = new Collation(2145, "UCA1400_LITHUANIAN_AI_CS", "utf8", 3);
  charsets[2146] = new Collation(2146, "UCA1400_LITHUANIAN_AS_CI", "utf8", 3);
  charsets[2147] = new Collation(2147, "UCA1400_LITHUANIAN_AS_CS", "utf8", 3);
  charsets[2148] = new Collation(2148, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf8", 3);
  charsets[2149] = new Collation(2149, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf8", 3);
  charsets[2150] = new Collation(2150, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf8", 3);
  charsets[2151] = new Collation(2151, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf8", 3);
  charsets[2152] = new Collation(2152, "UCA1400_SLOVAK_AI_CI", "utf8", 3);
  charsets[2153] = new Collation(2153, "UCA1400_SLOVAK_AI_CS", "utf8", 3);
  charsets[2154] = new Collation(2154, "UCA1400_SLOVAK_AS_CI", "utf8", 3);
  charsets[2155] = new Collation(2155, "UCA1400_SLOVAK_AS_CS", "utf8", 3);
  charsets[2156] = new Collation(2156, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf8", 3);
  charsets[2157] = new Collation(2157, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf8", 3);
  charsets[2158] = new Collation(2158, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf8", 3);
  charsets[2159] = new Collation(2159, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf8", 3);
  charsets[2160] = new Collation(2160, "UCA1400_SPANISH2_AI_CI", "utf8", 3);
  charsets[2161] = new Collation(2161, "UCA1400_SPANISH2_AI_CS", "utf8", 3);
  charsets[2162] = new Collation(2162, "UCA1400_SPANISH2_AS_CI", "utf8", 3);
  charsets[2163] = new Collation(2163, "UCA1400_SPANISH2_AS_CS", "utf8", 3);
  charsets[2164] = new Collation(2164, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf8", 3);
  charsets[2165] = new Collation(2165, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf8", 3);
  charsets[2166] = new Collation(2166, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf8", 3);
  charsets[2167] = new Collation(2167, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf8", 3);
  charsets[2168] = new Collation(2168, "UCA1400_ROMAN_AI_CI", "utf8", 3);
  charsets[2169] = new Collation(2169, "UCA1400_ROMAN_AI_CS", "utf8", 3);
  charsets[2170] = new Collation(2170, "UCA1400_ROMAN_AS_CI", "utf8", 3);
  charsets[2171] = new Collation(2171, "UCA1400_ROMAN_AS_CS", "utf8", 3);
  charsets[2172] = new Collation(2172, "UCA1400_ROMAN_NOPAD_AI_CI", "utf8", 3);
  charsets[2173] = new Collation(2173, "UCA1400_ROMAN_NOPAD_AI_CS", "utf8", 3);
  charsets[2174] = new Collation(2174, "UCA1400_ROMAN_NOPAD_AS_CI", "utf8", 3);
  charsets[2175] = new Collation(2175, "UCA1400_ROMAN_NOPAD_AS_CS", "utf8", 3);
  charsets[2176] = new Collation(2176, "UCA1400_PERSIAN_AI_CI", "utf8", 3);
  charsets[2177] = new Collation(2177, "UCA1400_PERSIAN_AI_CS", "utf8", 3);
  charsets[2178] = new Collation(2178, "UCA1400_PERSIAN_AS_CI", "utf8", 3);
  charsets[2179] = new Collation(2179, "UCA1400_PERSIAN_AS_CS", "utf8", 3);
  charsets[2180] = new Collation(2180, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf8", 3);
  charsets[2181] = new Collation(2181, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf8", 3);
  charsets[2182] = new Collation(2182, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf8", 3);
  charsets[2183] = new Collation(2183, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf8", 3);
  charsets[2184] = new Collation(2184, "UCA1400_ESPERANTO_AI_CI", "utf8", 3);
  charsets[2185] = new Collation(2185, "UCA1400_ESPERANTO_AI_CS", "utf8", 3);
  charsets[2186] = new Collation(2186, "UCA1400_ESPERANTO_AS_CI", "utf8", 3);
  charsets[2187] = new Collation(2187, "UCA1400_ESPERANTO_AS_CS", "utf8", 3);
  charsets[2188] = new Collation(2188, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf8", 3);
  charsets[2189] = new Collation(2189, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf8", 3);
  charsets[2190] = new Collation(2190, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf8", 3);
  charsets[2191] = new Collation(2191, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf8", 3);
  charsets[2192] = new Collation(2192, "UCA1400_HUNGARIAN_AI_CI", "utf8", 3);
  charsets[2193] = new Collation(2193, "UCA1400_HUNGARIAN_AI_CS", "utf8", 3);
  charsets[2194] = new Collation(2194, "UCA1400_HUNGARIAN_AS_CI", "utf8", 3);
  charsets[2195] = new Collation(2195, "UCA1400_HUNGARIAN_AS_CS", "utf8", 3);
  charsets[2196] = new Collation(2196, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf8", 3);
  charsets[2197] = new Collation(2197, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf8", 3);
  charsets[2198] = new Collation(2198, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf8", 3);
  charsets[2199] = new Collation(2199, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf8", 3);
  charsets[2200] = new Collation(2200, "UCA1400_SINHALA_AI_CI", "utf8", 3);
  charsets[2201] = new Collation(2201, "UCA1400_SINHALA_AI_CS", "utf8", 3);
  charsets[2202] = new Collation(2202, "UCA1400_SINHALA_AS_CI", "utf8", 3);
  charsets[2203] = new Collation(2203, "UCA1400_SINHALA_AS_CS", "utf8", 3);
  charsets[2204] = new Collation(2204, "UCA1400_SINHALA_NOPAD_AI_CI", "utf8", 3);
  charsets[2205] = new Collation(2205, "UCA1400_SINHALA_NOPAD_AI_CS", "utf8", 3);
  charsets[2206] = new Collation(2206, "UCA1400_SINHALA_NOPAD_AS_CI", "utf8", 3);
  charsets[2207] = new Collation(2207, "UCA1400_SINHALA_NOPAD_AS_CS", "utf8", 3);
  charsets[2208] = new Collation(2208, "UCA1400_GERMAN2_AI_CI", "utf8", 3);
  charsets[2209] = new Collation(2209, "UCA1400_GERMAN2_AI_CS", "utf8", 3);
  charsets[2210] = new Collation(2210, "UCA1400_GERMAN2_AS_CI", "utf8", 3);
  charsets[2211] = new Collation(2211, "UCA1400_GERMAN2_AS_CS", "utf8", 3);
  charsets[2212] = new Collation(2212, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf8", 3);
  charsets[2213] = new Collation(2213, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf8", 3);
  charsets[2214] = new Collation(2214, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf8", 3);
  charsets[2215] = new Collation(2215, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf8", 3);
  charsets[2232] = new Collation(2232, "UCA1400_VIETNAMESE_AI_CI", "utf8", 3);
  charsets[2233] = new Collation(2233, "UCA1400_VIETNAMESE_AI_CS", "utf8", 3);
  charsets[2234] = new Collation(2234, "UCA1400_VIETNAMESE_AS_CI", "utf8", 3);
  charsets[2235] = new Collation(2235, "UCA1400_VIETNAMESE_AS_CS", "utf8", 3);
  charsets[2236] = new Collation(2236, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf8", 3);
  charsets[2237] = new Collation(2237, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf8", 3);
  charsets[2238] = new Collation(2238, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf8", 3);
  charsets[2239] = new Collation(2239, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf8", 3);
  charsets[2240] = new Collation(2240, "UCA1400_CROATIAN_AI_CI", "utf8", 3);
  charsets[2241] = new Collation(2241, "UCA1400_CROATIAN_AI_CS", "utf8", 3);
  charsets[2242] = new Collation(2242, "UCA1400_CROATIAN_AS_CI", "utf8", 3);
  charsets[2243] = new Collation(2243, "UCA1400_CROATIAN_AS_CS", "utf8", 3);
  charsets[2244] = new Collation(2244, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf8", 3);
  charsets[2245] = new Collation(2245, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf8", 3);
  charsets[2246] = new Collation(2246, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf8", 3);
  charsets[2247] = new Collation(2247, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf8", 3);
  charsets[2304] = new Collation(2304, "UCA1400_AI_CI", "utf8", 4);
  charsets[2305] = new Collation(2305, "UCA1400_AI_CS", "utf8", 4);
  charsets[2306] = new Collation(2306, "UCA1400_AS_CI", "utf8", 4);
  charsets[2307] = new Collation(2307, "UCA1400_AS_CS", "utf8", 4);
  charsets[2308] = new Collation(2308, "UCA1400_NOPAD_AI_CI", "utf8", 4);
  charsets[2309] = new Collation(2309, "UCA1400_NOPAD_AI_CS", "utf8", 4);
  charsets[2310] = new Collation(2310, "UCA1400_NOPAD_AS_CI", "utf8", 4);
  charsets[2311] = new Collation(2311, "UCA1400_NOPAD_AS_CS", "utf8", 4);
  charsets[2312] = new Collation(2312, "UCA1400_ICELANDIC_AI_CI", "utf8", 4);
  charsets[2313] = new Collation(2313, "UCA1400_ICELANDIC_AI_CS", "utf8", 4);
  charsets[2314] = new Collation(2314, "UCA1400_ICELANDIC_AS_CI", "utf8", 4);
  charsets[2315] = new Collation(2315, "UCA1400_ICELANDIC_AS_CS", "utf8", 4);
  charsets[2316] = new Collation(2316, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf8", 4);
  charsets[2317] = new Collation(2317, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf8", 4);
  charsets[2318] = new Collation(2318, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf8", 4);
  charsets[2319] = new Collation(2319, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf8", 4);
  charsets[2320] = new Collation(2320, "UCA1400_LATVIAN_AI_CI", "utf8", 4);
  charsets[2321] = new Collation(2321, "UCA1400_LATVIAN_AI_CS", "utf8", 4);
  charsets[2322] = new Collation(2322, "UCA1400_LATVIAN_AS_CI", "utf8", 4);
  charsets[2323] = new Collation(2323, "UCA1400_LATVIAN_AS_CS", "utf8", 4);
  charsets[2324] = new Collation(2324, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf8", 4);
  charsets[2325] = new Collation(2325, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf8", 4);
  charsets[2326] = new Collation(2326, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf8", 4);
  charsets[2327] = new Collation(2327, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf8", 4);
  charsets[2328] = new Collation(2328, "UCA1400_ROMANIAN_AI_CI", "utf8", 4);
  charsets[2329] = new Collation(2329, "UCA1400_ROMANIAN_AI_CS", "utf8", 4);
  charsets[2330] = new Collation(2330, "UCA1400_ROMANIAN_AS_CI", "utf8", 4);
  charsets[2331] = new Collation(2331, "UCA1400_ROMANIAN_AS_CS", "utf8", 4);
  charsets[2332] = new Collation(2332, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf8", 4);
  charsets[2333] = new Collation(2333, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf8", 4);
  charsets[2334] = new Collation(2334, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf8", 4);
  charsets[2335] = new Collation(2335, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf8", 4);
  charsets[2336] = new Collation(2336, "UCA1400_SLOVENIAN_AI_CI", "utf8", 4);
  charsets[2337] = new Collation(2337, "UCA1400_SLOVENIAN_AI_CS", "utf8", 4);
  charsets[2338] = new Collation(2338, "UCA1400_SLOVENIAN_AS_CI", "utf8", 4);
  charsets[2339] = new Collation(2339, "UCA1400_SLOVENIAN_AS_CS", "utf8", 4);
  charsets[2340] = new Collation(2340, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf8", 4);
  charsets[2341] = new Collation(2341, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf8", 4);
  charsets[2342] = new Collation(2342, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf8", 4);
  charsets[2343] = new Collation(2343, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf8", 4);
  charsets[2344] = new Collation(2344, "UCA1400_POLISH_AI_CI", "utf8", 4);
  charsets[2345] = new Collation(2345, "UCA1400_POLISH_AI_CS", "utf8", 4);
  charsets[2346] = new Collation(2346, "UCA1400_POLISH_AS_CI", "utf8", 4);
  charsets[2347] = new Collation(2347, "UCA1400_POLISH_AS_CS", "utf8", 4);
  charsets[2348] = new Collation(2348, "UCA1400_POLISH_NOPAD_AI_CI", "utf8", 4);
  charsets[2349] = new Collation(2349, "UCA1400_POLISH_NOPAD_AI_CS", "utf8", 4);
  charsets[2350] = new Collation(2350, "UCA1400_POLISH_NOPAD_AS_CI", "utf8", 4);
  charsets[2351] = new Collation(2351, "UCA1400_POLISH_NOPAD_AS_CS", "utf8", 4);
  charsets[2352] = new Collation(2352, "UCA1400_ESTONIAN_AI_CI", "utf8", 4);
  charsets[2353] = new Collation(2353, "UCA1400_ESTONIAN_AI_CS", "utf8", 4);
  charsets[2354] = new Collation(2354, "UCA1400_ESTONIAN_AS_CI", "utf8", 4);
  charsets[2355] = new Collation(2355, "UCA1400_ESTONIAN_AS_CS", "utf8", 4);
  charsets[2356] = new Collation(2356, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf8", 4);
  charsets[2357] = new Collation(2357, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf8", 4);
  charsets[2358] = new Collation(2358, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf8", 4);
  charsets[2359] = new Collation(2359, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf8", 4);
  charsets[2360] = new Collation(2360, "UCA1400_SPANISH_AI_CI", "utf8", 4);
  charsets[2361] = new Collation(2361, "UCA1400_SPANISH_AI_CS", "utf8", 4);
  charsets[2362] = new Collation(2362, "UCA1400_SPANISH_AS_CI", "utf8", 4);
  charsets[2363] = new Collation(2363, "UCA1400_SPANISH_AS_CS", "utf8", 4);
  charsets[2364] = new Collation(2364, "UCA1400_SPANISH_NOPAD_AI_CI", "utf8", 4);
  charsets[2365] = new Collation(2365, "UCA1400_SPANISH_NOPAD_AI_CS", "utf8", 4);
  charsets[2366] = new Collation(2366, "UCA1400_SPANISH_NOPAD_AS_CI", "utf8", 4);
  charsets[2367] = new Collation(2367, "UCA1400_SPANISH_NOPAD_AS_CS", "utf8", 4);
  charsets[2368] = new Collation(2368, "UCA1400_SWEDISH_AI_CI", "utf8", 4);
  charsets[2369] = new Collation(2369, "UCA1400_SWEDISH_AI_CS", "utf8", 4);
  charsets[2370] = new Collation(2370, "UCA1400_SWEDISH_AS_CI", "utf8", 4);
  charsets[2371] = new Collation(2371, "UCA1400_SWEDISH_AS_CS", "utf8", 4);
  charsets[2372] = new Collation(2372, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf8", 4);
  charsets[2373] = new Collation(2373, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf8", 4);
  charsets[2374] = new Collation(2374, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf8", 4);
  charsets[2375] = new Collation(2375, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf8", 4);
  charsets[2376] = new Collation(2376, "UCA1400_TURKISH_AI_CI", "utf8", 4);
  charsets[2377] = new Collation(2377, "UCA1400_TURKISH_AI_CS", "utf8", 4);
  charsets[2378] = new Collation(2378, "UCA1400_TURKISH_AS_CI", "utf8", 4);
  charsets[2379] = new Collation(2379, "UCA1400_TURKISH_AS_CS", "utf8", 4);
  charsets[2380] = new Collation(2380, "UCA1400_TURKISH_NOPAD_AI_CI", "utf8", 4);
  charsets[2381] = new Collation(2381, "UCA1400_TURKISH_NOPAD_AI_CS", "utf8", 4);
  charsets[2382] = new Collation(2382, "UCA1400_TURKISH_NOPAD_AS_CI", "utf8", 4);
  charsets[2383] = new Collation(2383, "UCA1400_TURKISH_NOPAD_AS_CS", "utf8", 4);
  charsets[2384] = new Collation(2384, "UCA1400_CZECH_AI_CI", "utf8", 4);
  charsets[2385] = new Collation(2385, "UCA1400_CZECH_AI_CS", "utf8", 4);
  charsets[2386] = new Collation(2386, "UCA1400_CZECH_AS_CI", "utf8", 4);
  charsets[2387] = new Collation(2387, "UCA1400_CZECH_AS_CS", "utf8", 4);
  charsets[2388] = new Collation(2388, "UCA1400_CZECH_NOPAD_AI_CI", "utf8", 4);
  charsets[2389] = new Collation(2389, "UCA1400_CZECH_NOPAD_AI_CS", "utf8", 4);
  charsets[2390] = new Collation(2390, "UCA1400_CZECH_NOPAD_AS_CI", "utf8", 4);
  charsets[2391] = new Collation(2391, "UCA1400_CZECH_NOPAD_AS_CS", "utf8", 4);
  charsets[2392] = new Collation(2392, "UCA1400_DANISH_AI_CI", "utf8", 4);
  charsets[2393] = new Collation(2393, "UCA1400_DANISH_AI_CS", "utf8", 4);
  charsets[2394] = new Collation(2394, "UCA1400_DANISH_AS_CI", "utf8", 4);
  charsets[2395] = new Collation(2395, "UCA1400_DANISH_AS_CS", "utf8", 4);
  charsets[2396] = new Collation(2396, "UCA1400_DANISH_NOPAD_AI_CI", "utf8", 4);
  charsets[2397] = new Collation(2397, "UCA1400_DANISH_NOPAD_AI_CS", "utf8", 4);
  charsets[2398] = new Collation(2398, "UCA1400_DANISH_NOPAD_AS_CI", "utf8", 4);
  charsets[2399] = new Collation(2399, "UCA1400_DANISH_NOPAD_AS_CS", "utf8", 4);
  charsets[2400] = new Collation(2400, "UCA1400_LITHUANIAN_AI_CI", "utf8", 4);
  charsets[2401] = new Collation(2401, "UCA1400_LITHUANIAN_AI_CS", "utf8", 4);
  charsets[2402] = new Collation(2402, "UCA1400_LITHUANIAN_AS_CI", "utf8", 4);
  charsets[2403] = new Collation(2403, "UCA1400_LITHUANIAN_AS_CS", "utf8", 4);
  charsets[2404] = new Collation(2404, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf8", 4);
  charsets[2405] = new Collation(2405, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf8", 4);
  charsets[2406] = new Collation(2406, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf8", 4);
  charsets[2407] = new Collation(2407, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf8", 4);
  charsets[2408] = new Collation(2408, "UCA1400_SLOVAK_AI_CI", "utf8", 4);
  charsets[2409] = new Collation(2409, "UCA1400_SLOVAK_AI_CS", "utf8", 4);
  charsets[2410] = new Collation(2410, "UCA1400_SLOVAK_AS_CI", "utf8", 4);
  charsets[2411] = new Collation(2411, "UCA1400_SLOVAK_AS_CS", "utf8", 4);
  charsets[2412] = new Collation(2412, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf8", 4);
  charsets[2413] = new Collation(2413, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf8", 4);
  charsets[2414] = new Collation(2414, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf8", 4);
  charsets[2415] = new Collation(2415, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf8", 4);
  charsets[2416] = new Collation(2416, "UCA1400_SPANISH2_AI_CI", "utf8", 4);
  charsets[2417] = new Collation(2417, "UCA1400_SPANISH2_AI_CS", "utf8", 4);
  charsets[2418] = new Collation(2418, "UCA1400_SPANISH2_AS_CI", "utf8", 4);
  charsets[2419] = new Collation(2419, "UCA1400_SPANISH2_AS_CS", "utf8", 4);
  charsets[2420] = new Collation(2420, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf8", 4);
  charsets[2421] = new Collation(2421, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf8", 4);
  charsets[2422] = new Collation(2422, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf8", 4);
  charsets[2423] = new Collation(2423, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf8", 4);
  charsets[2424] = new Collation(2424, "UCA1400_ROMAN_AI_CI", "utf8", 4);
  charsets[2425] = new Collation(2425, "UCA1400_ROMAN_AI_CS", "utf8", 4);
  charsets[2426] = new Collation(2426, "UCA1400_ROMAN_AS_CI", "utf8", 4);
  charsets[2427] = new Collation(2427, "UCA1400_ROMAN_AS_CS", "utf8", 4);
  charsets[2428] = new Collation(2428, "UCA1400_ROMAN_NOPAD_AI_CI", "utf8", 4);
  charsets[2429] = new Collation(2429, "UCA1400_ROMAN_NOPAD_AI_CS", "utf8", 4);
  charsets[2430] = new Collation(2430, "UCA1400_ROMAN_NOPAD_AS_CI", "utf8", 4);
  charsets[2431] = new Collation(2431, "UCA1400_ROMAN_NOPAD_AS_CS", "utf8", 4);
  charsets[2432] = new Collation(2432, "UCA1400_PERSIAN_AI_CI", "utf8", 4);
  charsets[2433] = new Collation(2433, "UCA1400_PERSIAN_AI_CS", "utf8", 4);
  charsets[2434] = new Collation(2434, "UCA1400_PERSIAN_AS_CI", "utf8", 4);
  charsets[2435] = new Collation(2435, "UCA1400_PERSIAN_AS_CS", "utf8", 4);
  charsets[2436] = new Collation(2436, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf8", 4);
  charsets[2437] = new Collation(2437, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf8", 4);
  charsets[2438] = new Collation(2438, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf8", 4);
  charsets[2439] = new Collation(2439, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf8", 4);
  charsets[2440] = new Collation(2440, "UCA1400_ESPERANTO_AI_CI", "utf8", 4);
  charsets[2441] = new Collation(2441, "UCA1400_ESPERANTO_AI_CS", "utf8", 4);
  charsets[2442] = new Collation(2442, "UCA1400_ESPERANTO_AS_CI", "utf8", 4);
  charsets[2443] = new Collation(2443, "UCA1400_ESPERANTO_AS_CS", "utf8", 4);
  charsets[2444] = new Collation(2444, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf8", 4);
  charsets[2445] = new Collation(2445, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf8", 4);
  charsets[2446] = new Collation(2446, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf8", 4);
  charsets[2447] = new Collation(2447, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf8", 4);
  charsets[2448] = new Collation(2448, "UCA1400_HUNGARIAN_AI_CI", "utf8", 4);
  charsets[2449] = new Collation(2449, "UCA1400_HUNGARIAN_AI_CS", "utf8", 4);
  charsets[2450] = new Collation(2450, "UCA1400_HUNGARIAN_AS_CI", "utf8", 4);
  charsets[2451] = new Collation(2451, "UCA1400_HUNGARIAN_AS_CS", "utf8", 4);
  charsets[2452] = new Collation(2452, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf8", 4);
  charsets[2453] = new Collation(2453, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf8", 4);
  charsets[2454] = new Collation(2454, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf8", 4);
  charsets[2455] = new Collation(2455, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf8", 4);
  charsets[2456] = new Collation(2456, "UCA1400_SINHALA_AI_CI", "utf8", 4);
  charsets[2457] = new Collation(2457, "UCA1400_SINHALA_AI_CS", "utf8", 4);
  charsets[2458] = new Collation(2458, "UCA1400_SINHALA_AS_CI", "utf8", 4);
  charsets[2459] = new Collation(2459, "UCA1400_SINHALA_AS_CS", "utf8", 4);
  charsets[2460] = new Collation(2460, "UCA1400_SINHALA_NOPAD_AI_CI", "utf8", 4);
  charsets[2461] = new Collation(2461, "UCA1400_SINHALA_NOPAD_AI_CS", "utf8", 4);
  charsets[2462] = new Collation(2462, "UCA1400_SINHALA_NOPAD_AS_CI", "utf8", 4);
  charsets[2463] = new Collation(2463, "UCA1400_SINHALA_NOPAD_AS_CS", "utf8", 4);
  charsets[2464] = new Collation(2464, "UCA1400_GERMAN2_AI_CI", "utf8", 4);
  charsets[2465] = new Collation(2465, "UCA1400_GERMAN2_AI_CS", "utf8", 4);
  charsets[2466] = new Collation(2466, "UCA1400_GERMAN2_AS_CI", "utf8", 4);
  charsets[2467] = new Collation(2467, "UCA1400_GERMAN2_AS_CS", "utf8", 4);
  charsets[2468] = new Collation(2468, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf8", 4);
  charsets[2469] = new Collation(2469, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf8", 4);
  charsets[2470] = new Collation(2470, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf8", 4);
  charsets[2471] = new Collation(2471, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf8", 4);
  charsets[2488] = new Collation(2488, "UCA1400_VIETNAMESE_AI_CI", "utf8", 4);
  charsets[2489] = new Collation(2489, "UCA1400_VIETNAMESE_AI_CS", "utf8", 4);
  charsets[2490] = new Collation(2490, "UCA1400_VIETNAMESE_AS_CI", "utf8", 4);
  charsets[2491] = new Collation(2491, "UCA1400_VIETNAMESE_AS_CS", "utf8", 4);
  charsets[2492] = new Collation(2492, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf8", 4);
  charsets[2493] = new Collation(2493, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf8", 4);
  charsets[2494] = new Collation(2494, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf8", 4);
  charsets[2495] = new Collation(2495, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf8", 4);
  charsets[2496] = new Collation(2496, "UCA1400_CROATIAN_AI_CI", "utf8", 4);
  charsets[2497] = new Collation(2497, "UCA1400_CROATIAN_AI_CS", "utf8", 4);
  charsets[2498] = new Collation(2498, "UCA1400_CROATIAN_AS_CI", "utf8", 4);
  charsets[2499] = new Collation(2499, "UCA1400_CROATIAN_AS_CS", "utf8", 4);
  charsets[2500] = new Collation(2500, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf8", 4);
  charsets[2501] = new Collation(2501, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf8", 4);
  charsets[2502] = new Collation(2502, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf8", 4);
  charsets[2503] = new Collation(2503, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf8", 4);
  charsets[2560] = new Collation(2560, "UCA1400_AI_CI", "ucs2", 2);
  charsets[2561] = new Collation(2561, "UCA1400_AI_CS", "ucs2", 2);
  charsets[2562] = new Collation(2562, "UCA1400_AS_CI", "ucs2", 2);
  charsets[2563] = new Collation(2563, "UCA1400_AS_CS", "ucs2", 2);
  charsets[2564] = new Collation(2564, "UCA1400_NOPAD_AI_CI", "ucs2", 2);
  charsets[2565] = new Collation(2565, "UCA1400_NOPAD_AI_CS", "ucs2", 2);
  charsets[2566] = new Collation(2566, "UCA1400_NOPAD_AS_CI", "ucs2", 2);
  charsets[2567] = new Collation(2567, "UCA1400_NOPAD_AS_CS", "ucs2", 2);
  charsets[2568] = new Collation(2568, "UCA1400_ICELANDIC_AI_CI", "ucs2", 2);
  charsets[2569] = new Collation(2569, "UCA1400_ICELANDIC_AI_CS", "ucs2", 2);
  charsets[2570] = new Collation(2570, "UCA1400_ICELANDIC_AS_CI", "ucs2", 2);
  charsets[2571] = new Collation(2571, "UCA1400_ICELANDIC_AS_CS", "ucs2", 2);
  charsets[2572] = new Collation(2572, "UCA1400_ICELANDIC_NOPAD_AI_CI", "ucs2", 2);
  charsets[2573] = new Collation(2573, "UCA1400_ICELANDIC_NOPAD_AI_CS", "ucs2", 2);
  charsets[2574] = new Collation(2574, "UCA1400_ICELANDIC_NOPAD_AS_CI", "ucs2", 2);
  charsets[2575] = new Collation(2575, "UCA1400_ICELANDIC_NOPAD_AS_CS", "ucs2", 2);
  charsets[2576] = new Collation(2576, "UCA1400_LATVIAN_AI_CI", "ucs2", 2);
  charsets[2577] = new Collation(2577, "UCA1400_LATVIAN_AI_CS", "ucs2", 2);
  charsets[2578] = new Collation(2578, "UCA1400_LATVIAN_AS_CI", "ucs2", 2);
  charsets[2579] = new Collation(2579, "UCA1400_LATVIAN_AS_CS", "ucs2", 2);
  charsets[2580] = new Collation(2580, "UCA1400_LATVIAN_NOPAD_AI_CI", "ucs2", 2);
  charsets[2581] = new Collation(2581, "UCA1400_LATVIAN_NOPAD_AI_CS", "ucs2", 2);
  charsets[2582] = new Collation(2582, "UCA1400_LATVIAN_NOPAD_AS_CI", "ucs2", 2);
  charsets[2583] = new Collation(2583, "UCA1400_LATVIAN_NOPAD_AS_CS", "ucs2", 2);
  charsets[2584] = new Collation(2584, "UCA1400_ROMANIAN_AI_CI", "ucs2", 2);
  charsets[2585] = new Collation(2585, "UCA1400_ROMANIAN_AI_CS", "ucs2", 2);
  charsets[2586] = new Collation(2586, "UCA1400_ROMANIAN_AS_CI", "ucs2", 2);
  charsets[2587] = new Collation(2587, "UCA1400_ROMANIAN_AS_CS", "ucs2", 2);
  charsets[2588] = new Collation(2588, "UCA1400_ROMANIAN_NOPAD_AI_CI", "ucs2", 2);
  charsets[2589] = new Collation(2589, "UCA1400_ROMANIAN_NOPAD_AI_CS", "ucs2", 2);
  charsets[2590] = new Collation(2590, "UCA1400_ROMANIAN_NOPAD_AS_CI", "ucs2", 2);
  charsets[2591] = new Collation(2591, "UCA1400_ROMANIAN_NOPAD_AS_CS", "ucs2", 2);
  charsets[2592] = new Collation(2592, "UCA1400_SLOVENIAN_AI_CI", "ucs2", 2);
  charsets[2593] = new Collation(2593, "UCA1400_SLOVENIAN_AI_CS", "ucs2", 2);
  charsets[2594] = new Collation(2594, "UCA1400_SLOVENIAN_AS_CI", "ucs2", 2);
  charsets[2595] = new Collation(2595, "UCA1400_SLOVENIAN_AS_CS", "ucs2", 2);
  charsets[2596] = new Collation(2596, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "ucs2", 2);
  charsets[2597] = new Collation(2597, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "ucs2", 2);
  charsets[2598] = new Collation(2598, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "ucs2", 2);
  charsets[2599] = new Collation(2599, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "ucs2", 2);
  charsets[2600] = new Collation(2600, "UCA1400_POLISH_AI_CI", "ucs2", 2);
  charsets[2601] = new Collation(2601, "UCA1400_POLISH_AI_CS", "ucs2", 2);
  charsets[2602] = new Collation(2602, "UCA1400_POLISH_AS_CI", "ucs2", 2);
  charsets[2603] = new Collation(2603, "UCA1400_POLISH_AS_CS", "ucs2", 2);
  charsets[2604] = new Collation(2604, "UCA1400_POLISH_NOPAD_AI_CI", "ucs2", 2);
  charsets[2605] = new Collation(2605, "UCA1400_POLISH_NOPAD_AI_CS", "ucs2", 2);
  charsets[2606] = new Collation(2606, "UCA1400_POLISH_NOPAD_AS_CI", "ucs2", 2);
  charsets[2607] = new Collation(2607, "UCA1400_POLISH_NOPAD_AS_CS", "ucs2", 2);
  charsets[2608] = new Collation(2608, "UCA1400_ESTONIAN_AI_CI", "ucs2", 2);
  charsets[2609] = new Collation(2609, "UCA1400_ESTONIAN_AI_CS", "ucs2", 2);
  charsets[2610] = new Collation(2610, "UCA1400_ESTONIAN_AS_CI", "ucs2", 2);
  charsets[2611] = new Collation(2611, "UCA1400_ESTONIAN_AS_CS", "ucs2", 2);
  charsets[2612] = new Collation(2612, "UCA1400_ESTONIAN_NOPAD_AI_CI", "ucs2", 2);
  charsets[2613] = new Collation(2613, "UCA1400_ESTONIAN_NOPAD_AI_CS", "ucs2", 2);
  charsets[2614] = new Collation(2614, "UCA1400_ESTONIAN_NOPAD_AS_CI", "ucs2", 2);
  charsets[2615] = new Collation(2615, "UCA1400_ESTONIAN_NOPAD_AS_CS", "ucs2", 2);
  charsets[2616] = new Collation(2616, "UCA1400_SPANISH_AI_CI", "ucs2", 2);
  charsets[2617] = new Collation(2617, "UCA1400_SPANISH_AI_CS", "ucs2", 2);
  charsets[2618] = new Collation(2618, "UCA1400_SPANISH_AS_CI", "ucs2", 2);
  charsets[2619] = new Collation(2619, "UCA1400_SPANISH_AS_CS", "ucs2", 2);
  charsets[2620] = new Collation(2620, "UCA1400_SPANISH_NOPAD_AI_CI", "ucs2", 2);
  charsets[2621] = new Collation(2621, "UCA1400_SPANISH_NOPAD_AI_CS", "ucs2", 2);
  charsets[2622] = new Collation(2622, "UCA1400_SPANISH_NOPAD_AS_CI", "ucs2", 2);
  charsets[2623] = new Collation(2623, "UCA1400_SPANISH_NOPAD_AS_CS", "ucs2", 2);
  charsets[2624] = new Collation(2624, "UCA1400_SWEDISH_AI_CI", "ucs2", 2);
  charsets[2625] = new Collation(2625, "UCA1400_SWEDISH_AI_CS", "ucs2", 2);
  charsets[2626] = new Collation(2626, "UCA1400_SWEDISH_AS_CI", "ucs2", 2);
  charsets[2627] = new Collation(2627, "UCA1400_SWEDISH_AS_CS", "ucs2", 2);
  charsets[2628] = new Collation(2628, "UCA1400_SWEDISH_NOPAD_AI_CI", "ucs2", 2);
  charsets[2629] = new Collation(2629, "UCA1400_SWEDISH_NOPAD_AI_CS", "ucs2", 2);
  charsets[2630] = new Collation(2630, "UCA1400_SWEDISH_NOPAD_AS_CI", "ucs2", 2);
  charsets[2631] = new Collation(2631, "UCA1400_SWEDISH_NOPAD_AS_CS", "ucs2", 2);
  charsets[2632] = new Collation(2632, "UCA1400_TURKISH_AI_CI", "ucs2", 2);
  charsets[2633] = new Collation(2633, "UCA1400_TURKISH_AI_CS", "ucs2", 2);
  charsets[2634] = new Collation(2634, "UCA1400_TURKISH_AS_CI", "ucs2", 2);
  charsets[2635] = new Collation(2635, "UCA1400_TURKISH_AS_CS", "ucs2", 2);
  charsets[2636] = new Collation(2636, "UCA1400_TURKISH_NOPAD_AI_CI", "ucs2", 2);
  charsets[2637] = new Collation(2637, "UCA1400_TURKISH_NOPAD_AI_CS", "ucs2", 2);
  charsets[2638] = new Collation(2638, "UCA1400_TURKISH_NOPAD_AS_CI", "ucs2", 2);
  charsets[2639] = new Collation(2639, "UCA1400_TURKISH_NOPAD_AS_CS", "ucs2", 2);
  charsets[2640] = new Collation(2640, "UCA1400_CZECH_AI_CI", "ucs2", 2);
  charsets[2641] = new Collation(2641, "UCA1400_CZECH_AI_CS", "ucs2", 2);
  charsets[2642] = new Collation(2642, "UCA1400_CZECH_AS_CI", "ucs2", 2);
  charsets[2643] = new Collation(2643, "UCA1400_CZECH_AS_CS", "ucs2", 2);
  charsets[2644] = new Collation(2644, "UCA1400_CZECH_NOPAD_AI_CI", "ucs2", 2);
  charsets[2645] = new Collation(2645, "UCA1400_CZECH_NOPAD_AI_CS", "ucs2", 2);
  charsets[2646] = new Collation(2646, "UCA1400_CZECH_NOPAD_AS_CI", "ucs2", 2);
  charsets[2647] = new Collation(2647, "UCA1400_CZECH_NOPAD_AS_CS", "ucs2", 2);
  charsets[2648] = new Collation(2648, "UCA1400_DANISH_AI_CI", "ucs2", 2);
  charsets[2649] = new Collation(2649, "UCA1400_DANISH_AI_CS", "ucs2", 2);
  charsets[2650] = new Collation(2650, "UCA1400_DANISH_AS_CI", "ucs2", 2);
  charsets[2651] = new Collation(2651, "UCA1400_DANISH_AS_CS", "ucs2", 2);
  charsets[2652] = new Collation(2652, "UCA1400_DANISH_NOPAD_AI_CI", "ucs2", 2);
  charsets[2653] = new Collation(2653, "UCA1400_DANISH_NOPAD_AI_CS", "ucs2", 2);
  charsets[2654] = new Collation(2654, "UCA1400_DANISH_NOPAD_AS_CI", "ucs2", 2);
  charsets[2655] = new Collation(2655, "UCA1400_DANISH_NOPAD_AS_CS", "ucs2", 2);
  charsets[2656] = new Collation(2656, "UCA1400_LITHUANIAN_AI_CI", "ucs2", 2);
  charsets[2657] = new Collation(2657, "UCA1400_LITHUANIAN_AI_CS", "ucs2", 2);
  charsets[2658] = new Collation(2658, "UCA1400_LITHUANIAN_AS_CI", "ucs2", 2);
  charsets[2659] = new Collation(2659, "UCA1400_LITHUANIAN_AS_CS", "ucs2", 2);
  charsets[2660] = new Collation(2660, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "ucs2", 2);
  charsets[2661] = new Collation(2661, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "ucs2", 2);
  charsets[2662] = new Collation(2662, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "ucs2", 2);
  charsets[2663] = new Collation(2663, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "ucs2", 2);
  charsets[2664] = new Collation(2664, "UCA1400_SLOVAK_AI_CI", "ucs2", 2);
  charsets[2665] = new Collation(2665, "UCA1400_SLOVAK_AI_CS", "ucs2", 2);
  charsets[2666] = new Collation(2666, "UCA1400_SLOVAK_AS_CI", "ucs2", 2);
  charsets[2667] = new Collation(2667, "UCA1400_SLOVAK_AS_CS", "ucs2", 2);
  charsets[2668] = new Collation(2668, "UCA1400_SLOVAK_NOPAD_AI_CI", "ucs2", 2);
  charsets[2669] = new Collation(2669, "UCA1400_SLOVAK_NOPAD_AI_CS", "ucs2", 2);
  charsets[2670] = new Collation(2670, "UCA1400_SLOVAK_NOPAD_AS_CI", "ucs2", 2);
  charsets[2671] = new Collation(2671, "UCA1400_SLOVAK_NOPAD_AS_CS", "ucs2", 2);
  charsets[2672] = new Collation(2672, "UCA1400_SPANISH2_AI_CI", "ucs2", 2);
  charsets[2673] = new Collation(2673, "UCA1400_SPANISH2_AI_CS", "ucs2", 2);
  charsets[2674] = new Collation(2674, "UCA1400_SPANISH2_AS_CI", "ucs2", 2);
  charsets[2675] = new Collation(2675, "UCA1400_SPANISH2_AS_CS", "ucs2", 2);
  charsets[2676] = new Collation(2676, "UCA1400_SPANISH2_NOPAD_AI_CI", "ucs2", 2);
  charsets[2677] = new Collation(2677, "UCA1400_SPANISH2_NOPAD_AI_CS", "ucs2", 2);
  charsets[2678] = new Collation(2678, "UCA1400_SPANISH2_NOPAD_AS_CI", "ucs2", 2);
  charsets[2679] = new Collation(2679, "UCA1400_SPANISH2_NOPAD_AS_CS", "ucs2", 2);
  charsets[2680] = new Collation(2680, "UCA1400_ROMAN_AI_CI", "ucs2", 2);
  charsets[2681] = new Collation(2681, "UCA1400_ROMAN_AI_CS", "ucs2", 2);
  charsets[2682] = new Collation(2682, "UCA1400_ROMAN_AS_CI", "ucs2", 2);
  charsets[2683] = new Collation(2683, "UCA1400_ROMAN_AS_CS", "ucs2", 2);
  charsets[2684] = new Collation(2684, "UCA1400_ROMAN_NOPAD_AI_CI", "ucs2", 2);
  charsets[2685] = new Collation(2685, "UCA1400_ROMAN_NOPAD_AI_CS", "ucs2", 2);
  charsets[2686] = new Collation(2686, "UCA1400_ROMAN_NOPAD_AS_CI", "ucs2", 2);
  charsets[2687] = new Collation(2687, "UCA1400_ROMAN_NOPAD_AS_CS", "ucs2", 2);
  charsets[2688] = new Collation(2688, "UCA1400_PERSIAN_AI_CI", "ucs2", 2);
  charsets[2689] = new Collation(2689, "UCA1400_PERSIAN_AI_CS", "ucs2", 2);
  charsets[2690] = new Collation(2690, "UCA1400_PERSIAN_AS_CI", "ucs2", 2);
  charsets[2691] = new Collation(2691, "UCA1400_PERSIAN_AS_CS", "ucs2", 2);
  charsets[2692] = new Collation(2692, "UCA1400_PERSIAN_NOPAD_AI_CI", "ucs2", 2);
  charsets[2693] = new Collation(2693, "UCA1400_PERSIAN_NOPAD_AI_CS", "ucs2", 2);
  charsets[2694] = new Collation(2694, "UCA1400_PERSIAN_NOPAD_AS_CI", "ucs2", 2);
  charsets[2695] = new Collation(2695, "UCA1400_PERSIAN_NOPAD_AS_CS", "ucs2", 2);
  charsets[2696] = new Collation(2696, "UCA1400_ESPERANTO_AI_CI", "ucs2", 2);
  charsets[2697] = new Collation(2697, "UCA1400_ESPERANTO_AI_CS", "ucs2", 2);
  charsets[2698] = new Collation(2698, "UCA1400_ESPERANTO_AS_CI", "ucs2", 2);
  charsets[2699] = new Collation(2699, "UCA1400_ESPERANTO_AS_CS", "ucs2", 2);
  charsets[2700] = new Collation(2700, "UCA1400_ESPERANTO_NOPAD_AI_CI", "ucs2", 2);
  charsets[2701] = new Collation(2701, "UCA1400_ESPERANTO_NOPAD_AI_CS", "ucs2", 2);
  charsets[2702] = new Collation(2702, "UCA1400_ESPERANTO_NOPAD_AS_CI", "ucs2", 2);
  charsets[2703] = new Collation(2703, "UCA1400_ESPERANTO_NOPAD_AS_CS", "ucs2", 2);
  charsets[2704] = new Collation(2704, "UCA1400_HUNGARIAN_AI_CI", "ucs2", 2);
  charsets[2705] = new Collation(2705, "UCA1400_HUNGARIAN_AI_CS", "ucs2", 2);
  charsets[2706] = new Collation(2706, "UCA1400_HUNGARIAN_AS_CI", "ucs2", 2);
  charsets[2707] = new Collation(2707, "UCA1400_HUNGARIAN_AS_CS", "ucs2", 2);
  charsets[2708] = new Collation(2708, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "ucs2", 2);
  charsets[2709] = new Collation(2709, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "ucs2", 2);
  charsets[2710] = new Collation(2710, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "ucs2", 2);
  charsets[2711] = new Collation(2711, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "ucs2", 2);
  charsets[2712] = new Collation(2712, "UCA1400_SINHALA_AI_CI", "ucs2", 2);
  charsets[2713] = new Collation(2713, "UCA1400_SINHALA_AI_CS", "ucs2", 2);
  charsets[2714] = new Collation(2714, "UCA1400_SINHALA_AS_CI", "ucs2", 2);
  charsets[2715] = new Collation(2715, "UCA1400_SINHALA_AS_CS", "ucs2", 2);
  charsets[2716] = new Collation(2716, "UCA1400_SINHALA_NOPAD_AI_CI", "ucs2", 2);
  charsets[2717] = new Collation(2717, "UCA1400_SINHALA_NOPAD_AI_CS", "ucs2", 2);
  charsets[2718] = new Collation(2718, "UCA1400_SINHALA_NOPAD_AS_CI", "ucs2", 2);
  charsets[2719] = new Collation(2719, "UCA1400_SINHALA_NOPAD_AS_CS", "ucs2", 2);
  charsets[2720] = new Collation(2720, "UCA1400_GERMAN2_AI_CI", "ucs2", 2);
  charsets[2721] = new Collation(2721, "UCA1400_GERMAN2_AI_CS", "ucs2", 2);
  charsets[2722] = new Collation(2722, "UCA1400_GERMAN2_AS_CI", "ucs2", 2);
  charsets[2723] = new Collation(2723, "UCA1400_GERMAN2_AS_CS", "ucs2", 2);
  charsets[2724] = new Collation(2724, "UCA1400_GERMAN2_NOPAD_AI_CI", "ucs2", 2);
  charsets[2725] = new Collation(2725, "UCA1400_GERMAN2_NOPAD_AI_CS", "ucs2", 2);
  charsets[2726] = new Collation(2726, "UCA1400_GERMAN2_NOPAD_AS_CI", "ucs2", 2);
  charsets[2727] = new Collation(2727, "UCA1400_GERMAN2_NOPAD_AS_CS", "ucs2", 2);
  charsets[2744] = new Collation(2744, "UCA1400_VIETNAMESE_AI_CI", "ucs2", 2);
  charsets[2745] = new Collation(2745, "UCA1400_VIETNAMESE_AI_CS", "ucs2", 2);
  charsets[2746] = new Collation(2746, "UCA1400_VIETNAMESE_AS_CI", "ucs2", 2);
  charsets[2747] = new Collation(2747, "UCA1400_VIETNAMESE_AS_CS", "ucs2", 2);
  charsets[2748] = new Collation(2748, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "ucs2", 2);
  charsets[2749] = new Collation(2749, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "ucs2", 2);
  charsets[2750] = new Collation(2750, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "ucs2", 2);
  charsets[2751] = new Collation(2751, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "ucs2", 2);
  charsets[2752] = new Collation(2752, "UCA1400_CROATIAN_AI_CI", "ucs2", 2);
  charsets[2753] = new Collation(2753, "UCA1400_CROATIAN_AI_CS", "ucs2", 2);
  charsets[2754] = new Collation(2754, "UCA1400_CROATIAN_AS_CI", "ucs2", 2);
  charsets[2755] = new Collation(2755, "UCA1400_CROATIAN_AS_CS", "ucs2", 2);
  charsets[2756] = new Collation(2756, "UCA1400_CROATIAN_NOPAD_AI_CI", "ucs2", 2);
  charsets[2757] = new Collation(2757, "UCA1400_CROATIAN_NOPAD_AI_CS", "ucs2", 2);
  charsets[2758] = new Collation(2758, "UCA1400_CROATIAN_NOPAD_AS_CI", "ucs2", 2);
  charsets[2759] = new Collation(2759, "UCA1400_CROATIAN_NOPAD_AS_CS", "ucs2", 2);
  charsets[2816] = new Collation(2816, "UCA1400_AI_CI", "utf16", 4);
  charsets[2817] = new Collation(2817, "UCA1400_AI_CS", "utf16", 4);
  charsets[2818] = new Collation(2818, "UCA1400_AS_CI", "utf16", 4);
  charsets[2819] = new Collation(2819, "UCA1400_AS_CS", "utf16", 4);
  charsets[2820] = new Collation(2820, "UCA1400_NOPAD_AI_CI", "utf16", 4);
  charsets[2821] = new Collation(2821, "UCA1400_NOPAD_AI_CS", "utf16", 4);
  charsets[2822] = new Collation(2822, "UCA1400_NOPAD_AS_CI", "utf16", 4);
  charsets[2823] = new Collation(2823, "UCA1400_NOPAD_AS_CS", "utf16", 4);
  charsets[2824] = new Collation(2824, "UCA1400_ICELANDIC_AI_CI", "utf16", 4);
  charsets[2825] = new Collation(2825, "UCA1400_ICELANDIC_AI_CS", "utf16", 4);
  charsets[2826] = new Collation(2826, "UCA1400_ICELANDIC_AS_CI", "utf16", 4);
  charsets[2827] = new Collation(2827, "UCA1400_ICELANDIC_AS_CS", "utf16", 4);
  charsets[2828] = new Collation(2828, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf16", 4);
  charsets[2829] = new Collation(2829, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf16", 4);
  charsets[2830] = new Collation(2830, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf16", 4);
  charsets[2831] = new Collation(2831, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf16", 4);
  charsets[2832] = new Collation(2832, "UCA1400_LATVIAN_AI_CI", "utf16", 4);
  charsets[2833] = new Collation(2833, "UCA1400_LATVIAN_AI_CS", "utf16", 4);
  charsets[2834] = new Collation(2834, "UCA1400_LATVIAN_AS_CI", "utf16", 4);
  charsets[2835] = new Collation(2835, "UCA1400_LATVIAN_AS_CS", "utf16", 4);
  charsets[2836] = new Collation(2836, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf16", 4);
  charsets[2837] = new Collation(2837, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf16", 4);
  charsets[2838] = new Collation(2838, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf16", 4);
  charsets[2839] = new Collation(2839, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf16", 4);
  charsets[2840] = new Collation(2840, "UCA1400_ROMANIAN_AI_CI", "utf16", 4);
  charsets[2841] = new Collation(2841, "UCA1400_ROMANIAN_AI_CS", "utf16", 4);
  charsets[2842] = new Collation(2842, "UCA1400_ROMANIAN_AS_CI", "utf16", 4);
  charsets[2843] = new Collation(2843, "UCA1400_ROMANIAN_AS_CS", "utf16", 4);
  charsets[2844] = new Collation(2844, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf16", 4);
  charsets[2845] = new Collation(2845, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf16", 4);
  charsets[2846] = new Collation(2846, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf16", 4);
  charsets[2847] = new Collation(2847, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf16", 4);
  charsets[2848] = new Collation(2848, "UCA1400_SLOVENIAN_AI_CI", "utf16", 4);
  charsets[2849] = new Collation(2849, "UCA1400_SLOVENIAN_AI_CS", "utf16", 4);
  charsets[2850] = new Collation(2850, "UCA1400_SLOVENIAN_AS_CI", "utf16", 4);
  charsets[2851] = new Collation(2851, "UCA1400_SLOVENIAN_AS_CS", "utf16", 4);
  charsets[2852] = new Collation(2852, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf16", 4);
  charsets[2853] = new Collation(2853, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf16", 4);
  charsets[2854] = new Collation(2854, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf16", 4);
  charsets[2855] = new Collation(2855, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf16", 4);
  charsets[2856] = new Collation(2856, "UCA1400_POLISH_AI_CI", "utf16", 4);
  charsets[2857] = new Collation(2857, "UCA1400_POLISH_AI_CS", "utf16", 4);
  charsets[2858] = new Collation(2858, "UCA1400_POLISH_AS_CI", "utf16", 4);
  charsets[2859] = new Collation(2859, "UCA1400_POLISH_AS_CS", "utf16", 4);
  charsets[2860] = new Collation(2860, "UCA1400_POLISH_NOPAD_AI_CI", "utf16", 4);
  charsets[2861] = new Collation(2861, "UCA1400_POLISH_NOPAD_AI_CS", "utf16", 4);
  charsets[2862] = new Collation(2862, "UCA1400_POLISH_NOPAD_AS_CI", "utf16", 4);
  charsets[2863] = new Collation(2863, "UCA1400_POLISH_NOPAD_AS_CS", "utf16", 4);
  charsets[2864] = new Collation(2864, "UCA1400_ESTONIAN_AI_CI", "utf16", 4);
  charsets[2865] = new Collation(2865, "UCA1400_ESTONIAN_AI_CS", "utf16", 4);
  charsets[2866] = new Collation(2866, "UCA1400_ESTONIAN_AS_CI", "utf16", 4);
  charsets[2867] = new Collation(2867, "UCA1400_ESTONIAN_AS_CS", "utf16", 4);
  charsets[2868] = new Collation(2868, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf16", 4);
  charsets[2869] = new Collation(2869, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf16", 4);
  charsets[2870] = new Collation(2870, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf16", 4);
  charsets[2871] = new Collation(2871, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf16", 4);
  charsets[2872] = new Collation(2872, "UCA1400_SPANISH_AI_CI", "utf16", 4);
  charsets[2873] = new Collation(2873, "UCA1400_SPANISH_AI_CS", "utf16", 4);
  charsets[2874] = new Collation(2874, "UCA1400_SPANISH_AS_CI", "utf16", 4);
  charsets[2875] = new Collation(2875, "UCA1400_SPANISH_AS_CS", "utf16", 4);
  charsets[2876] = new Collation(2876, "UCA1400_SPANISH_NOPAD_AI_CI", "utf16", 4);
  charsets[2877] = new Collation(2877, "UCA1400_SPANISH_NOPAD_AI_CS", "utf16", 4);
  charsets[2878] = new Collation(2878, "UCA1400_SPANISH_NOPAD_AS_CI", "utf16", 4);
  charsets[2879] = new Collation(2879, "UCA1400_SPANISH_NOPAD_AS_CS", "utf16", 4);
  charsets[2880] = new Collation(2880, "UCA1400_SWEDISH_AI_CI", "utf16", 4);
  charsets[2881] = new Collation(2881, "UCA1400_SWEDISH_AI_CS", "utf16", 4);
  charsets[2882] = new Collation(2882, "UCA1400_SWEDISH_AS_CI", "utf16", 4);
  charsets[2883] = new Collation(2883, "UCA1400_SWEDISH_AS_CS", "utf16", 4);
  charsets[2884] = new Collation(2884, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf16", 4);
  charsets[2885] = new Collation(2885, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf16", 4);
  charsets[2886] = new Collation(2886, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf16", 4);
  charsets[2887] = new Collation(2887, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf16", 4);
  charsets[2888] = new Collation(2888, "UCA1400_TURKISH_AI_CI", "utf16", 4);
  charsets[2889] = new Collation(2889, "UCA1400_TURKISH_AI_CS", "utf16", 4);
  charsets[2890] = new Collation(2890, "UCA1400_TURKISH_AS_CI", "utf16", 4);
  charsets[2891] = new Collation(2891, "UCA1400_TURKISH_AS_CS", "utf16", 4);
  charsets[2892] = new Collation(2892, "UCA1400_TURKISH_NOPAD_AI_CI", "utf16", 4);
  charsets[2893] = new Collation(2893, "UCA1400_TURKISH_NOPAD_AI_CS", "utf16", 4);
  charsets[2894] = new Collation(2894, "UCA1400_TURKISH_NOPAD_AS_CI", "utf16", 4);
  charsets[2895] = new Collation(2895, "UCA1400_TURKISH_NOPAD_AS_CS", "utf16", 4);
  charsets[2896] = new Collation(2896, "UCA1400_CZECH_AI_CI", "utf16", 4);
  charsets[2897] = new Collation(2897, "UCA1400_CZECH_AI_CS", "utf16", 4);
  charsets[2898] = new Collation(2898, "UCA1400_CZECH_AS_CI", "utf16", 4);
  charsets[2899] = new Collation(2899, "UCA1400_CZECH_AS_CS", "utf16", 4);
  charsets[2900] = new Collation(2900, "UCA1400_CZECH_NOPAD_AI_CI", "utf16", 4);
  charsets[2901] = new Collation(2901, "UCA1400_CZECH_NOPAD_AI_CS", "utf16", 4);
  charsets[2902] = new Collation(2902, "UCA1400_CZECH_NOPAD_AS_CI", "utf16", 4);
  charsets[2903] = new Collation(2903, "UCA1400_CZECH_NOPAD_AS_CS", "utf16", 4);
  charsets[2904] = new Collation(2904, "UCA1400_DANISH_AI_CI", "utf16", 4);
  charsets[2905] = new Collation(2905, "UCA1400_DANISH_AI_CS", "utf16", 4);
  charsets[2906] = new Collation(2906, "UCA1400_DANISH_AS_CI", "utf16", 4);
  charsets[2907] = new Collation(2907, "UCA1400_DANISH_AS_CS", "utf16", 4);
  charsets[2908] = new Collation(2908, "UCA1400_DANISH_NOPAD_AI_CI", "utf16", 4);
  charsets[2909] = new Collation(2909, "UCA1400_DANISH_NOPAD_AI_CS", "utf16", 4);
  charsets[2910] = new Collation(2910, "UCA1400_DANISH_NOPAD_AS_CI", "utf16", 4);
  charsets[2911] = new Collation(2911, "UCA1400_DANISH_NOPAD_AS_CS", "utf16", 4);
  charsets[2912] = new Collation(2912, "UCA1400_LITHUANIAN_AI_CI", "utf16", 4);
  charsets[2913] = new Collation(2913, "UCA1400_LITHUANIAN_AI_CS", "utf16", 4);
  charsets[2914] = new Collation(2914, "UCA1400_LITHUANIAN_AS_CI", "utf16", 4);
  charsets[2915] = new Collation(2915, "UCA1400_LITHUANIAN_AS_CS", "utf16", 4);
  charsets[2916] = new Collation(2916, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf16", 4);
  charsets[2917] = new Collation(2917, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf16", 4);
  charsets[2918] = new Collation(2918, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf16", 4);
  charsets[2919] = new Collation(2919, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf16", 4);
  charsets[2920] = new Collation(2920, "UCA1400_SLOVAK_AI_CI", "utf16", 4);
  charsets[2921] = new Collation(2921, "UCA1400_SLOVAK_AI_CS", "utf16", 4);
  charsets[2922] = new Collation(2922, "UCA1400_SLOVAK_AS_CI", "utf16", 4);
  charsets[2923] = new Collation(2923, "UCA1400_SLOVAK_AS_CS", "utf16", 4);
  charsets[2924] = new Collation(2924, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf16", 4);
  charsets[2925] = new Collation(2925, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf16", 4);
  charsets[2926] = new Collation(2926, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf16", 4);
  charsets[2927] = new Collation(2927, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf16", 4);
  charsets[2928] = new Collation(2928, "UCA1400_SPANISH2_AI_CI", "utf16", 4);
  charsets[2929] = new Collation(2929, "UCA1400_SPANISH2_AI_CS", "utf16", 4);
  charsets[2930] = new Collation(2930, "UCA1400_SPANISH2_AS_CI", "utf16", 4);
  charsets[2931] = new Collation(2931, "UCA1400_SPANISH2_AS_CS", "utf16", 4);
  charsets[2932] = new Collation(2932, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf16", 4);
  charsets[2933] = new Collation(2933, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf16", 4);
  charsets[2934] = new Collation(2934, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf16", 4);
  charsets[2935] = new Collation(2935, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf16", 4);
  charsets[2936] = new Collation(2936, "UCA1400_ROMAN_AI_CI", "utf16", 4);
  charsets[2937] = new Collation(2937, "UCA1400_ROMAN_AI_CS", "utf16", 4);
  charsets[2938] = new Collation(2938, "UCA1400_ROMAN_AS_CI", "utf16", 4);
  charsets[2939] = new Collation(2939, "UCA1400_ROMAN_AS_CS", "utf16", 4);
  charsets[2940] = new Collation(2940, "UCA1400_ROMAN_NOPAD_AI_CI", "utf16", 4);
  charsets[2941] = new Collation(2941, "UCA1400_ROMAN_NOPAD_AI_CS", "utf16", 4);
  charsets[2942] = new Collation(2942, "UCA1400_ROMAN_NOPAD_AS_CI", "utf16", 4);
  charsets[2943] = new Collation(2943, "UCA1400_ROMAN_NOPAD_AS_CS", "utf16", 4);
  charsets[2944] = new Collation(2944, "UCA1400_PERSIAN_AI_CI", "utf16", 4);
  charsets[2945] = new Collation(2945, "UCA1400_PERSIAN_AI_CS", "utf16", 4);
  charsets[2946] = new Collation(2946, "UCA1400_PERSIAN_AS_CI", "utf16", 4);
  charsets[2947] = new Collation(2947, "UCA1400_PERSIAN_AS_CS", "utf16", 4);
  charsets[2948] = new Collation(2948, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf16", 4);
  charsets[2949] = new Collation(2949, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf16", 4);
  charsets[2950] = new Collation(2950, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf16", 4);
  charsets[2951] = new Collation(2951, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf16", 4);
  charsets[2952] = new Collation(2952, "UCA1400_ESPERANTO_AI_CI", "utf16", 4);
  charsets[2953] = new Collation(2953, "UCA1400_ESPERANTO_AI_CS", "utf16", 4);
  charsets[2954] = new Collation(2954, "UCA1400_ESPERANTO_AS_CI", "utf16", 4);
  charsets[2955] = new Collation(2955, "UCA1400_ESPERANTO_AS_CS", "utf16", 4);
  charsets[2956] = new Collation(2956, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf16", 4);
  charsets[2957] = new Collation(2957, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf16", 4);
  charsets[2958] = new Collation(2958, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf16", 4);
  charsets[2959] = new Collation(2959, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf16", 4);
  charsets[2960] = new Collation(2960, "UCA1400_HUNGARIAN_AI_CI", "utf16", 4);
  charsets[2961] = new Collation(2961, "UCA1400_HUNGARIAN_AI_CS", "utf16", 4);
  charsets[2962] = new Collation(2962, "UCA1400_HUNGARIAN_AS_CI", "utf16", 4);
  charsets[2963] = new Collation(2963, "UCA1400_HUNGARIAN_AS_CS", "utf16", 4);
  charsets[2964] = new Collation(2964, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf16", 4);
  charsets[2965] = new Collation(2965, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf16", 4);
  charsets[2966] = new Collation(2966, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf16", 4);
  charsets[2967] = new Collation(2967, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf16", 4);
  charsets[2968] = new Collation(2968, "UCA1400_SINHALA_AI_CI", "utf16", 4);
  charsets[2969] = new Collation(2969, "UCA1400_SINHALA_AI_CS", "utf16", 4);
  charsets[2970] = new Collation(2970, "UCA1400_SINHALA_AS_CI", "utf16", 4);
  charsets[2971] = new Collation(2971, "UCA1400_SINHALA_AS_CS", "utf16", 4);
  charsets[2972] = new Collation(2972, "UCA1400_SINHALA_NOPAD_AI_CI", "utf16", 4);
  charsets[2973] = new Collation(2973, "UCA1400_SINHALA_NOPAD_AI_CS", "utf16", 4);
  charsets[2974] = new Collation(2974, "UCA1400_SINHALA_NOPAD_AS_CI", "utf16", 4);
  charsets[2975] = new Collation(2975, "UCA1400_SINHALA_NOPAD_AS_CS", "utf16", 4);
  charsets[2976] = new Collation(2976, "UCA1400_GERMAN2_AI_CI", "utf16", 4);
  charsets[2977] = new Collation(2977, "UCA1400_GERMAN2_AI_CS", "utf16", 4);
  charsets[2978] = new Collation(2978, "UCA1400_GERMAN2_AS_CI", "utf16", 4);
  charsets[2979] = new Collation(2979, "UCA1400_GERMAN2_AS_CS", "utf16", 4);
  charsets[2980] = new Collation(2980, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf16", 4);
  charsets[2981] = new Collation(2981, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf16", 4);
  charsets[2982] = new Collation(2982, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf16", 4);
  charsets[2983] = new Collation(2983, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf16", 4);
  charsets[3e3] = new Collation(3e3, "UCA1400_VIETNAMESE_AI_CI", "utf16", 4);
  charsets[3001] = new Collation(3001, "UCA1400_VIETNAMESE_AI_CS", "utf16", 4);
  charsets[3002] = new Collation(3002, "UCA1400_VIETNAMESE_AS_CI", "utf16", 4);
  charsets[3003] = new Collation(3003, "UCA1400_VIETNAMESE_AS_CS", "utf16", 4);
  charsets[3004] = new Collation(3004, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf16", 4);
  charsets[3005] = new Collation(3005, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf16", 4);
  charsets[3006] = new Collation(3006, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf16", 4);
  charsets[3007] = new Collation(3007, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf16", 4);
  charsets[3008] = new Collation(3008, "UCA1400_CROATIAN_AI_CI", "utf16", 4);
  charsets[3009] = new Collation(3009, "UCA1400_CROATIAN_AI_CS", "utf16", 4);
  charsets[3010] = new Collation(3010, "UCA1400_CROATIAN_AS_CI", "utf16", 4);
  charsets[3011] = new Collation(3011, "UCA1400_CROATIAN_AS_CS", "utf16", 4);
  charsets[3012] = new Collation(3012, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf16", 4);
  charsets[3013] = new Collation(3013, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf16", 4);
  charsets[3014] = new Collation(3014, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf16", 4);
  charsets[3015] = new Collation(3015, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf16", 4);
  charsets[3072] = new Collation(3072, "UCA1400_AI_CI", "utf32", 4);
  charsets[3073] = new Collation(3073, "UCA1400_AI_CS", "utf32", 4);
  charsets[3074] = new Collation(3074, "UCA1400_AS_CI", "utf32", 4);
  charsets[3075] = new Collation(3075, "UCA1400_AS_CS", "utf32", 4);
  charsets[3076] = new Collation(3076, "UCA1400_NOPAD_AI_CI", "utf32", 4);
  charsets[3077] = new Collation(3077, "UCA1400_NOPAD_AI_CS", "utf32", 4);
  charsets[3078] = new Collation(3078, "UCA1400_NOPAD_AS_CI", "utf32", 4);
  charsets[3079] = new Collation(3079, "UCA1400_NOPAD_AS_CS", "utf32", 4);
  charsets[3080] = new Collation(3080, "UCA1400_ICELANDIC_AI_CI", "utf32", 4);
  charsets[3081] = new Collation(3081, "UCA1400_ICELANDIC_AI_CS", "utf32", 4);
  charsets[3082] = new Collation(3082, "UCA1400_ICELANDIC_AS_CI", "utf32", 4);
  charsets[3083] = new Collation(3083, "UCA1400_ICELANDIC_AS_CS", "utf32", 4);
  charsets[3084] = new Collation(3084, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf32", 4);
  charsets[3085] = new Collation(3085, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf32", 4);
  charsets[3086] = new Collation(3086, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf32", 4);
  charsets[3087] = new Collation(3087, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf32", 4);
  charsets[3088] = new Collation(3088, "UCA1400_LATVIAN_AI_CI", "utf32", 4);
  charsets[3089] = new Collation(3089, "UCA1400_LATVIAN_AI_CS", "utf32", 4);
  charsets[3090] = new Collation(3090, "UCA1400_LATVIAN_AS_CI", "utf32", 4);
  charsets[3091] = new Collation(3091, "UCA1400_LATVIAN_AS_CS", "utf32", 4);
  charsets[3092] = new Collation(3092, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf32", 4);
  charsets[3093] = new Collation(3093, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf32", 4);
  charsets[3094] = new Collation(3094, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf32", 4);
  charsets[3095] = new Collation(3095, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf32", 4);
  charsets[3096] = new Collation(3096, "UCA1400_ROMANIAN_AI_CI", "utf32", 4);
  charsets[3097] = new Collation(3097, "UCA1400_ROMANIAN_AI_CS", "utf32", 4);
  charsets[3098] = new Collation(3098, "UCA1400_ROMANIAN_AS_CI", "utf32", 4);
  charsets[3099] = new Collation(3099, "UCA1400_ROMANIAN_AS_CS", "utf32", 4);
  charsets[3100] = new Collation(3100, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf32", 4);
  charsets[3101] = new Collation(3101, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf32", 4);
  charsets[3102] = new Collation(3102, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf32", 4);
  charsets[3103] = new Collation(3103, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf32", 4);
  charsets[3104] = new Collation(3104, "UCA1400_SLOVENIAN_AI_CI", "utf32", 4);
  charsets[3105] = new Collation(3105, "UCA1400_SLOVENIAN_AI_CS", "utf32", 4);
  charsets[3106] = new Collation(3106, "UCA1400_SLOVENIAN_AS_CI", "utf32", 4);
  charsets[3107] = new Collation(3107, "UCA1400_SLOVENIAN_AS_CS", "utf32", 4);
  charsets[3108] = new Collation(3108, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf32", 4);
  charsets[3109] = new Collation(3109, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf32", 4);
  charsets[3110] = new Collation(3110, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf32", 4);
  charsets[3111] = new Collation(3111, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf32", 4);
  charsets[3112] = new Collation(3112, "UCA1400_POLISH_AI_CI", "utf32", 4);
  charsets[3113] = new Collation(3113, "UCA1400_POLISH_AI_CS", "utf32", 4);
  charsets[3114] = new Collation(3114, "UCA1400_POLISH_AS_CI", "utf32", 4);
  charsets[3115] = new Collation(3115, "UCA1400_POLISH_AS_CS", "utf32", 4);
  charsets[3116] = new Collation(3116, "UCA1400_POLISH_NOPAD_AI_CI", "utf32", 4);
  charsets[3117] = new Collation(3117, "UCA1400_POLISH_NOPAD_AI_CS", "utf32", 4);
  charsets[3118] = new Collation(3118, "UCA1400_POLISH_NOPAD_AS_CI", "utf32", 4);
  charsets[3119] = new Collation(3119, "UCA1400_POLISH_NOPAD_AS_CS", "utf32", 4);
  charsets[3120] = new Collation(3120, "UCA1400_ESTONIAN_AI_CI", "utf32", 4);
  charsets[3121] = new Collation(3121, "UCA1400_ESTONIAN_AI_CS", "utf32", 4);
  charsets[3122] = new Collation(3122, "UCA1400_ESTONIAN_AS_CI", "utf32", 4);
  charsets[3123] = new Collation(3123, "UCA1400_ESTONIAN_AS_CS", "utf32", 4);
  charsets[3124] = new Collation(3124, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf32", 4);
  charsets[3125] = new Collation(3125, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf32", 4);
  charsets[3126] = new Collation(3126, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf32", 4);
  charsets[3127] = new Collation(3127, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf32", 4);
  charsets[3128] = new Collation(3128, "UCA1400_SPANISH_AI_CI", "utf32", 4);
  charsets[3129] = new Collation(3129, "UCA1400_SPANISH_AI_CS", "utf32", 4);
  charsets[3130] = new Collation(3130, "UCA1400_SPANISH_AS_CI", "utf32", 4);
  charsets[3131] = new Collation(3131, "UCA1400_SPANISH_AS_CS", "utf32", 4);
  charsets[3132] = new Collation(3132, "UCA1400_SPANISH_NOPAD_AI_CI", "utf32", 4);
  charsets[3133] = new Collation(3133, "UCA1400_SPANISH_NOPAD_AI_CS", "utf32", 4);
  charsets[3134] = new Collation(3134, "UCA1400_SPANISH_NOPAD_AS_CI", "utf32", 4);
  charsets[3135] = new Collation(3135, "UCA1400_SPANISH_NOPAD_AS_CS", "utf32", 4);
  charsets[3136] = new Collation(3136, "UCA1400_SWEDISH_AI_CI", "utf32", 4);
  charsets[3137] = new Collation(3137, "UCA1400_SWEDISH_AI_CS", "utf32", 4);
  charsets[3138] = new Collation(3138, "UCA1400_SWEDISH_AS_CI", "utf32", 4);
  charsets[3139] = new Collation(3139, "UCA1400_SWEDISH_AS_CS", "utf32", 4);
  charsets[3140] = new Collation(3140, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf32", 4);
  charsets[3141] = new Collation(3141, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf32", 4);
  charsets[3142] = new Collation(3142, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf32", 4);
  charsets[3143] = new Collation(3143, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf32", 4);
  charsets[3144] = new Collation(3144, "UCA1400_TURKISH_AI_CI", "utf32", 4);
  charsets[3145] = new Collation(3145, "UCA1400_TURKISH_AI_CS", "utf32", 4);
  charsets[3146] = new Collation(3146, "UCA1400_TURKISH_AS_CI", "utf32", 4);
  charsets[3147] = new Collation(3147, "UCA1400_TURKISH_AS_CS", "utf32", 4);
  charsets[3148] = new Collation(3148, "UCA1400_TURKISH_NOPAD_AI_CI", "utf32", 4);
  charsets[3149] = new Collation(3149, "UCA1400_TURKISH_NOPAD_AI_CS", "utf32", 4);
  charsets[3150] = new Collation(3150, "UCA1400_TURKISH_NOPAD_AS_CI", "utf32", 4);
  charsets[3151] = new Collation(3151, "UCA1400_TURKISH_NOPAD_AS_CS", "utf32", 4);
  charsets[3152] = new Collation(3152, "UCA1400_CZECH_AI_CI", "utf32", 4);
  charsets[3153] = new Collation(3153, "UCA1400_CZECH_AI_CS", "utf32", 4);
  charsets[3154] = new Collation(3154, "UCA1400_CZECH_AS_CI", "utf32", 4);
  charsets[3155] = new Collation(3155, "UCA1400_CZECH_AS_CS", "utf32", 4);
  charsets[3156] = new Collation(3156, "UCA1400_CZECH_NOPAD_AI_CI", "utf32", 4);
  charsets[3157] = new Collation(3157, "UCA1400_CZECH_NOPAD_AI_CS", "utf32", 4);
  charsets[3158] = new Collation(3158, "UCA1400_CZECH_NOPAD_AS_CI", "utf32", 4);
  charsets[3159] = new Collation(3159, "UCA1400_CZECH_NOPAD_AS_CS", "utf32", 4);
  charsets[3160] = new Collation(3160, "UCA1400_DANISH_AI_CI", "utf32", 4);
  charsets[3161] = new Collation(3161, "UCA1400_DANISH_AI_CS", "utf32", 4);
  charsets[3162] = new Collation(3162, "UCA1400_DANISH_AS_CI", "utf32", 4);
  charsets[3163] = new Collation(3163, "UCA1400_DANISH_AS_CS", "utf32", 4);
  charsets[3164] = new Collation(3164, "UCA1400_DANISH_NOPAD_AI_CI", "utf32", 4);
  charsets[3165] = new Collation(3165, "UCA1400_DANISH_NOPAD_AI_CS", "utf32", 4);
  charsets[3166] = new Collation(3166, "UCA1400_DANISH_NOPAD_AS_CI", "utf32", 4);
  charsets[3167] = new Collation(3167, "UCA1400_DANISH_NOPAD_AS_CS", "utf32", 4);
  charsets[3168] = new Collation(3168, "UCA1400_LITHUANIAN_AI_CI", "utf32", 4);
  charsets[3169] = new Collation(3169, "UCA1400_LITHUANIAN_AI_CS", "utf32", 4);
  charsets[3170] = new Collation(3170, "UCA1400_LITHUANIAN_AS_CI", "utf32", 4);
  charsets[3171] = new Collation(3171, "UCA1400_LITHUANIAN_AS_CS", "utf32", 4);
  charsets[3172] = new Collation(3172, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf32", 4);
  charsets[3173] = new Collation(3173, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf32", 4);
  charsets[3174] = new Collation(3174, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf32", 4);
  charsets[3175] = new Collation(3175, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf32", 4);
  charsets[3176] = new Collation(3176, "UCA1400_SLOVAK_AI_CI", "utf32", 4);
  charsets[3177] = new Collation(3177, "UCA1400_SLOVAK_AI_CS", "utf32", 4);
  charsets[3178] = new Collation(3178, "UCA1400_SLOVAK_AS_CI", "utf32", 4);
  charsets[3179] = new Collation(3179, "UCA1400_SLOVAK_AS_CS", "utf32", 4);
  charsets[3180] = new Collation(3180, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf32", 4);
  charsets[3181] = new Collation(3181, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf32", 4);
  charsets[3182] = new Collation(3182, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf32", 4);
  charsets[3183] = new Collation(3183, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf32", 4);
  charsets[3184] = new Collation(3184, "UCA1400_SPANISH2_AI_CI", "utf32", 4);
  charsets[3185] = new Collation(3185, "UCA1400_SPANISH2_AI_CS", "utf32", 4);
  charsets[3186] = new Collation(3186, "UCA1400_SPANISH2_AS_CI", "utf32", 4);
  charsets[3187] = new Collation(3187, "UCA1400_SPANISH2_AS_CS", "utf32", 4);
  charsets[3188] = new Collation(3188, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf32", 4);
  charsets[3189] = new Collation(3189, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf32", 4);
  charsets[3190] = new Collation(3190, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf32", 4);
  charsets[3191] = new Collation(3191, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf32", 4);
  charsets[3192] = new Collation(3192, "UCA1400_ROMAN_AI_CI", "utf32", 4);
  charsets[3193] = new Collation(3193, "UCA1400_ROMAN_AI_CS", "utf32", 4);
  charsets[3194] = new Collation(3194, "UCA1400_ROMAN_AS_CI", "utf32", 4);
  charsets[3195] = new Collation(3195, "UCA1400_ROMAN_AS_CS", "utf32", 4);
  charsets[3196] = new Collation(3196, "UCA1400_ROMAN_NOPAD_AI_CI", "utf32", 4);
  charsets[3197] = new Collation(3197, "UCA1400_ROMAN_NOPAD_AI_CS", "utf32", 4);
  charsets[3198] = new Collation(3198, "UCA1400_ROMAN_NOPAD_AS_CI", "utf32", 4);
  charsets[3199] = new Collation(3199, "UCA1400_ROMAN_NOPAD_AS_CS", "utf32", 4);
  charsets[3200] = new Collation(3200, "UCA1400_PERSIAN_AI_CI", "utf32", 4);
  charsets[3201] = new Collation(3201, "UCA1400_PERSIAN_AI_CS", "utf32", 4);
  charsets[3202] = new Collation(3202, "UCA1400_PERSIAN_AS_CI", "utf32", 4);
  charsets[3203] = new Collation(3203, "UCA1400_PERSIAN_AS_CS", "utf32", 4);
  charsets[3204] = new Collation(3204, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf32", 4);
  charsets[3205] = new Collation(3205, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf32", 4);
  charsets[3206] = new Collation(3206, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf32", 4);
  charsets[3207] = new Collation(3207, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf32", 4);
  charsets[3208] = new Collation(3208, "UCA1400_ESPERANTO_AI_CI", "utf32", 4);
  charsets[3209] = new Collation(3209, "UCA1400_ESPERANTO_AI_CS", "utf32", 4);
  charsets[3210] = new Collation(3210, "UCA1400_ESPERANTO_AS_CI", "utf32", 4);
  charsets[3211] = new Collation(3211, "UCA1400_ESPERANTO_AS_CS", "utf32", 4);
  charsets[3212] = new Collation(3212, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf32", 4);
  charsets[3213] = new Collation(3213, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf32", 4);
  charsets[3214] = new Collation(3214, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf32", 4);
  charsets[3215] = new Collation(3215, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf32", 4);
  charsets[3216] = new Collation(3216, "UCA1400_HUNGARIAN_AI_CI", "utf32", 4);
  charsets[3217] = new Collation(3217, "UCA1400_HUNGARIAN_AI_CS", "utf32", 4);
  charsets[3218] = new Collation(3218, "UCA1400_HUNGARIAN_AS_CI", "utf32", 4);
  charsets[3219] = new Collation(3219, "UCA1400_HUNGARIAN_AS_CS", "utf32", 4);
  charsets[3220] = new Collation(3220, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf32", 4);
  charsets[3221] = new Collation(3221, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf32", 4);
  charsets[3222] = new Collation(3222, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf32", 4);
  charsets[3223] = new Collation(3223, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf32", 4);
  charsets[3224] = new Collation(3224, "UCA1400_SINHALA_AI_CI", "utf32", 4);
  charsets[3225] = new Collation(3225, "UCA1400_SINHALA_AI_CS", "utf32", 4);
  charsets[3226] = new Collation(3226, "UCA1400_SINHALA_AS_CI", "utf32", 4);
  charsets[3227] = new Collation(3227, "UCA1400_SINHALA_AS_CS", "utf32", 4);
  charsets[3228] = new Collation(3228, "UCA1400_SINHALA_NOPAD_AI_CI", "utf32", 4);
  charsets[3229] = new Collation(3229, "UCA1400_SINHALA_NOPAD_AI_CS", "utf32", 4);
  charsets[3230] = new Collation(3230, "UCA1400_SINHALA_NOPAD_AS_CI", "utf32", 4);
  charsets[3231] = new Collation(3231, "UCA1400_SINHALA_NOPAD_AS_CS", "utf32", 4);
  charsets[3232] = new Collation(3232, "UCA1400_GERMAN2_AI_CI", "utf32", 4);
  charsets[3233] = new Collation(3233, "UCA1400_GERMAN2_AI_CS", "utf32", 4);
  charsets[3234] = new Collation(3234, "UCA1400_GERMAN2_AS_CI", "utf32", 4);
  charsets[3235] = new Collation(3235, "UCA1400_GERMAN2_AS_CS", "utf32", 4);
  charsets[3236] = new Collation(3236, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf32", 4);
  charsets[3237] = new Collation(3237, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf32", 4);
  charsets[3238] = new Collation(3238, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf32", 4);
  charsets[3239] = new Collation(3239, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf32", 4);
  charsets[3256] = new Collation(3256, "UCA1400_VIETNAMESE_AI_CI", "utf32", 4);
  charsets[3257] = new Collation(3257, "UCA1400_VIETNAMESE_AI_CS", "utf32", 4);
  charsets[3258] = new Collation(3258, "UCA1400_VIETNAMESE_AS_CI", "utf32", 4);
  charsets[3259] = new Collation(3259, "UCA1400_VIETNAMESE_AS_CS", "utf32", 4);
  charsets[3260] = new Collation(3260, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf32", 4);
  charsets[3261] = new Collation(3261, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf32", 4);
  charsets[3262] = new Collation(3262, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf32", 4);
  charsets[3263] = new Collation(3263, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf32", 4);
  charsets[3264] = new Collation(3264, "UCA1400_CROATIAN_AI_CI", "utf32", 4);
  charsets[3265] = new Collation(3265, "UCA1400_CROATIAN_AI_CS", "utf32", 4);
  charsets[3266] = new Collation(3266, "UCA1400_CROATIAN_AS_CI", "utf32", 4);
  charsets[3267] = new Collation(3267, "UCA1400_CROATIAN_AS_CS", "utf32", 4);
  charsets[3268] = new Collation(3268, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf32", 4);
  charsets[3269] = new Collation(3269, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf32", 4);
  charsets[3270] = new Collation(3270, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf32", 4);
  charsets[3271] = new Collation(3271, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf32", 4);
  for (let i = 0; i < charsets.length; i++) {
    let collation = charsets[i];
    if (collation) {
      Collation.prototype[collation.name] = collation;
    }
  }
  defaultCharsets["big5"] = charsets[1];
  defaultCharsets["dec8"] = charsets[3];
  defaultCharsets["cp850"] = charsets[4];
  defaultCharsets["hp8"] = charsets[6];
  defaultCharsets["koi8r"] = charsets[7];
  defaultCharsets["latin1"] = charsets[8];
  defaultCharsets["latin2"] = charsets[9];
  defaultCharsets["swe7"] = charsets[10];
  defaultCharsets["ascii"] = charsets[11];
  defaultCharsets["ujis"] = charsets[12];
  defaultCharsets["sjis"] = charsets[13];
  defaultCharsets["hebrew"] = charsets[16];
  defaultCharsets["tis620"] = charsets[18];
  defaultCharsets["euckr"] = charsets[19];
  defaultCharsets["koi8u"] = charsets[22];
  defaultCharsets["gb2312"] = charsets[24];
  defaultCharsets["greek"] = charsets[25];
  defaultCharsets["cp1250"] = charsets[26];
  defaultCharsets["gbk"] = charsets[28];
  defaultCharsets["latin5"] = charsets[30];
  defaultCharsets["armscii8"] = charsets[32];
  defaultCharsets["utf8"] = charsets[33];
  defaultCharsets["ucs2"] = charsets[35];
  defaultCharsets["cp866"] = charsets[36];
  defaultCharsets["keybcs2"] = charsets[37];
  defaultCharsets["macce"] = charsets[38];
  defaultCharsets["macroman"] = charsets[39];
  defaultCharsets["cp852"] = charsets[40];
  defaultCharsets["latin7"] = charsets[41];
  defaultCharsets["utf8mb4"] = charsets[45];
  defaultCharsets["cp1251"] = charsets[51];
  defaultCharsets["utf16"] = charsets[54];
  defaultCharsets["utf16le"] = charsets[56];
  defaultCharsets["cp1256"] = charsets[57];
  defaultCharsets["cp1257"] = charsets[59];
  defaultCharsets["utf32"] = charsets[60];
  defaultCharsets["binary"] = charsets[63];
  defaultCharsets["geostd8"] = charsets[92];
  defaultCharsets["cp932"] = charsets[95];
  defaultCharsets["eucjpms"] = charsets[97];
  defaultCharsets["gb18030"] = charsets[248];
  collations = Collation;
  return collations;
}
var utils$2 = {};
var textEncoder;
var hasRequiredTextEncoder;
function requireTextEncoder() {
  if (hasRequiredTextEncoder) return textEncoder;
  hasRequiredTextEncoder = 1;
  const QUOTE = 39;
  const formatDigit = function(val, significantDigit) {
    let res = `${val}`;
    while (res.length < significantDigit) res = "0" + res;
    return res;
  };
  class TextEncoder {
    /**
     * Write (and escape) current parameter value to output writer
     *
     * @param out     output writer
     * @param value   current parameter. Expected to be non-null
     * @param opts    connection options
     * @param info    connection information
     */
    static writeParam(out2, value, opts, info) {
      switch (typeof value) {
        case "boolean":
          out2.writeStringAscii(value ? "true" : "false");
          break;
        case "bigint":
        case "number":
          out2.writeStringAscii(`${value}`);
          break;
        case "string":
          out2.writeStringEscapeQuote(value);
          break;
        case "object":
          if (Object.prototype.toString.call(value) === "[object Date]") {
            out2.writeStringAscii(TextEncoder.getLocalDate(value));
          } else if (Buffer.isBuffer(value)) {
            out2.writeStringAscii("_BINARY '");
            out2.writeBufferEscape(value);
            out2.writeInt8(QUOTE);
          } else if (typeof value.toSqlString === "function") {
            out2.writeStringEscapeQuote(String(value.toSqlString()));
          } else if (Array.isArray(value)) {
            if (opts.arrayParenthesis) {
              out2.writeStringAscii("(");
            }
            for (let i = 0; i < value.length; i++) {
              if (i !== 0) out2.writeStringAscii(",");
              if (value[i] == null) {
                out2.writeStringAscii("NULL");
              } else TextEncoder.writeParam(out2, value[i], opts, info);
            }
            if (opts.arrayParenthesis) {
              out2.writeStringAscii(")");
            }
          } else {
            if (value.type != null && [
              "Point",
              "LineString",
              "Polygon",
              "MultiPoint",
              "MultiLineString",
              "MultiPolygon",
              "GeometryCollection"
            ].includes(value.type)) {
              let prefix = info.isMariaDB() && info.hasMinVersion(10, 1, 4) || !info.isMariaDB() && info.hasMinVersion(5, 7, 6) ? "ST_" : "";
              switch (value.type) {
                case "Point":
                  out2.writeStringAscii(
                    prefix + "PointFromText('POINT(" + TextEncoder.geoPointToString(value.coordinates) + ")')"
                  );
                  break;
                case "LineString":
                  out2.writeStringAscii(
                    prefix + "LineFromText('LINESTRING(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                  );
                  break;
                case "Polygon":
                  out2.writeStringAscii(
                    prefix + "PolygonFromText('POLYGON(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                  );
                  break;
                case "MultiPoint":
                  out2.writeStringAscii(
                    prefix + "MULTIPOINTFROMTEXT('MULTIPOINT(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                  );
                  break;
                case "MultiLineString":
                  out2.writeStringAscii(
                    prefix + "MLineFromText('MULTILINESTRING(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                  );
                  break;
                case "MultiPolygon":
                  out2.writeStringAscii(
                    prefix + "MPolyFromText('MULTIPOLYGON(" + TextEncoder.geoMultiPolygonToString(value.coordinates) + ")')"
                  );
                  break;
                case "GeometryCollection":
                  out2.writeStringAscii(
                    prefix + "GeomCollFromText('GEOMETRYCOLLECTION(" + TextEncoder.geometricCollectionToString(value.geometries) + ")')"
                  );
                  break;
              }
            } else if (String === value.constructor) {
              out2.writeStringEscapeQuote(value);
              break;
            } else {
              if (opts.permitSetMultiParamEntries) {
                let first = true;
                for (let key in value) {
                  const val = value[key];
                  if (typeof val === "function") continue;
                  if (first) {
                    first = false;
                  } else {
                    out2.writeStringAscii(",");
                  }
                  out2.writeString("`" + key + "`");
                  if (val == null) {
                    out2.writeStringAscii("=NULL");
                  } else {
                    out2.writeStringAscii("=");
                    TextEncoder.writeParam(out2, val, opts, info);
                  }
                }
                if (first) out2.writeStringEscapeQuote(JSON.stringify(value));
              } else {
                out2.writeStringEscapeQuote(JSON.stringify(value));
              }
            }
          }
          break;
      }
    }
    static geometricCollectionToString(geo) {
      if (!geo) return "";
      let st = "";
      for (let i = 0; i < geo.length; i++) {
        st += i !== 0 ? "," : "";
        switch (geo[i].type) {
          case "Point":
            st += `POINT(${TextEncoder.geoPointToString(geo[i].coordinates)})`;
            break;
          case "LineString":
            st += `LINESTRING(${TextEncoder.geoArrayPointToString(geo[i].coordinates)})`;
            break;
          case "Polygon":
            st += `POLYGON(${TextEncoder.geoMultiArrayPointToString(geo[i].coordinates)})`;
            break;
          case "MultiPoint":
            st += `MULTIPOINT(${TextEncoder.geoArrayPointToString(geo[i].coordinates)})`;
            break;
          case "MultiLineString":
            st += `MULTILINESTRING(${TextEncoder.geoMultiArrayPointToString(geo[i].coordinates)})`;
            break;
          case "MultiPolygon":
            st += `MULTIPOLYGON(${TextEncoder.geoMultiPolygonToString(geo[i].coordinates)})`;
            break;
        }
      }
      return st;
    }
    static geoMultiPolygonToString(coords) {
      if (!coords) return "";
      let st = "";
      for (let i = 0; i < coords.length; i++) {
        st += (i !== 0 ? ",(" : "(") + TextEncoder.geoMultiArrayPointToString(coords[i]) + ")";
      }
      return st;
    }
    static geoMultiArrayPointToString(coords) {
      if (!coords) return "";
      let st = "";
      for (let i = 0; i < coords.length; i++) {
        st += (i !== 0 ? ",(" : "(") + TextEncoder.geoArrayPointToString(coords[i]) + ")";
      }
      return st;
    }
    static geoArrayPointToString(coords) {
      if (!coords) return "";
      let st = "";
      for (let i = 0; i < coords.length; i++) {
        st += (i !== 0 ? "," : "") + TextEncoder.geoPointToString(coords[i]);
      }
      return st;
    }
    static geoPointToString(coords) {
      if (!coords) return "";
      return (isNaN(coords[0]) ? "" : coords[0]) + " " + (isNaN(coords[1]) ? "" : coords[1]);
    }
    static getLocalDate(date) {
      const ms2 = date.getMilliseconds();
      let d = "'" + date.getFullYear() + "-" + (date.getMonth() + 1) + "-" + date.getDate() + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
      if (ms2 === 0) return d + "'";
      let res = `${ms2}`;
      while (res.length < 3) res = "0" + res;
      return d + "." + res + "'";
    }
    static getFixedFormatDate(date) {
      const year = date.getFullYear();
      const mon = date.getMonth() + 1;
      const day = date.getDate();
      const hour = date.getHours();
      const min = date.getMinutes();
      const sec = date.getSeconds();
      const ms2 = date.getMilliseconds();
      return "'" + formatDigit(year, 4) + "-" + formatDigit(mon, 2) + "-" + formatDigit(day, 2) + " " + formatDigit(hour, 2) + ":" + formatDigit(min, 2) + ":" + formatDigit(sec, 2) + (ms2 > 0 ? "." + formatDigit(ms2, 3) : "") + "'";
    }
  }
  textEncoder = TextEncoder;
  return textEncoder;
}
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  const hexArray = "0123456789ABCDEF".split("");
  const Errors = requireErrors();
  const Iconv = requireLib$1();
  const TextEncoder = requireTextEncoder();
  utils$2.log = function(opts, buf, off, end, header) {
    let out2 = [];
    if (!buf) return "";
    if (off === void 0 || off === null) off = 0;
    if (end === void 0 || end === null) end = buf.length;
    let asciiValue = new Array(16);
    asciiValue[8] = " ";
    let useHeader = header !== void 0;
    let offset = off || 0;
    const maxLgh = Math.min(useHeader ? opts.debugLen - header.length : opts.debugLen, end - offset);
    const isLimited = end - offset > maxLgh;
    let byteValue;
    let posHexa = 0;
    let pos = 0;
    out2.push(
      "+--------------------------------------------------+\n|  0  1  2  3  4  5  6  7   8  9  a  b  c  d  e  f |\n+--------------------------------------------------+------------------+\n"
    );
    if (useHeader) {
      while (pos < header.length) {
        if (posHexa === 0) out2.push("| ");
        byteValue = header[pos++] & 255;
        out2.push(hexArray[byteValue >>> 4], hexArray[byteValue & 15], " ");
        asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : ".";
        if (posHexa === 8) out2.push(" ");
      }
    }
    pos = offset;
    while (pos < maxLgh + offset) {
      if (posHexa === 0) out2.push("| ");
      byteValue = buf[pos] & 255;
      out2.push(hexArray[byteValue >>> 4], hexArray[byteValue & 15], " ");
      asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : ".";
      if (posHexa === 8) out2.push(" ");
      if (posHexa === 16) {
        out2.push("| ", asciiValue.join(""), " |\n");
        posHexa = 0;
      }
      pos++;
    }
    let remaining = posHexa;
    if (remaining > 0) {
      if (remaining < 8) {
        for (; remaining < 8; remaining++) {
          out2.push("   ");
          asciiValue[posHexa++] = " ";
        }
        out2.push(" ");
      }
      for (; remaining < 16; remaining++) {
        out2.push("   ");
        asciiValue[posHexa++] = " ";
      }
      out2.push("| ", asciiValue.join(""), isLimited ? " |...\n" : " |\n");
    } else if (isLimited) {
      out2[out2.length - 1] = " |...\n";
    }
    out2.push("+--------------------------------------------------+------------------+\n");
    return out2.join("");
  };
  utils$2.toHexString = (bytes) => {
    return Array.from(bytes, (byte) => {
      return ("0" + (byte & 255).toString(16)).slice(-2);
    }).join("");
  };
  utils$2.escapeId = (opts, info, value) => {
    if (!value || value === "") {
      throw Errors.createError("Cannot escape empty ID value", Errors.ER_NULL_ESCAPEID, info, "0A000");
    }
    if (value.includes("\0")) {
      throw Errors.createError(
        "Cannot escape ID with null character (u0000)",
        Errors.ER_NULL_CHAR_ESCAPEID,
        info,
        "0A000"
      );
    }
    return "`" + value.replace(/`/g, "``") + "`";
  };
  const escapeParameters = (opts, info, value) => {
    if (value == null) return "NULL";
    switch (typeof value) {
      case "boolean":
        return value ? "true" : "false";
      case "bigint":
      case "number":
        return `${value}`;
      case "object":
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return TextEncoder.getFixedFormatDate(value);
        } else if (Buffer.isBuffer(value)) {
          let stValue;
          if (Buffer.isEncoding(info.collation.charset)) {
            stValue = value.toString(info.collation.charset, 0, value.length);
          } else {
            stValue = Iconv.decode(value, info.collation.charset);
          }
          return "_binary'" + escapeString(stValue) + "'";
        } else if (typeof value.toSqlString === "function") {
          return "'" + escapeString(String(value.toSqlString())) + "'";
        } else if (Array.isArray(value)) {
          let out2 = opts.arrayParenthesis ? "(" : "";
          for (let i = 0; i < value.length; i++) {
            if (i !== 0) out2 += ",";
            out2 += escapeParameters(opts, info, value[i]);
          }
          if (opts.arrayParenthesis) out2 += ")";
          return out2;
        } else {
          if (value.type != null && [
            "Point",
            "LineString",
            "Polygon",
            "MultiPoint",
            "MultiLineString",
            "MultiPolygon",
            "GeometryCollection"
          ].includes(value.type)) {
            let prefix = info && (info.isMariaDB() && info.hasMinVersion(10, 1, 4) || !info.isMariaDB() && info.hasMinVersion(5, 7, 6)) ? "ST_" : "";
            switch (value.type) {
              case "Point":
                return prefix + "PointFromText('POINT(" + TextEncoder.geoPointToString(value.coordinates) + ")')";
              case "LineString":
                return prefix + "LineFromText('LINESTRING(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')";
              case "Polygon":
                return prefix + "PolygonFromText('POLYGON(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')";
              case "MultiPoint":
                return prefix + "MULTIPOINTFROMTEXT('MULTIPOINT(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')";
              case "MultiLineString":
                return prefix + "MLineFromText('MULTILINESTRING(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')";
              case "MultiPolygon":
                return prefix + "MPolyFromText('MULTIPOLYGON(" + TextEncoder.geoMultiPolygonToString(value.coordinates) + ")')";
              case "GeometryCollection":
                return prefix + "GeomCollFromText('GEOMETRYCOLLECTION(" + TextEncoder.geometricCollectionToString(value.geometries) + ")')";
            }
          } else {
            if (opts.permitSetMultiParamEntries) {
              let out2 = "";
              let first = true;
              for (let key in value) {
                const val = value[key];
                if (typeof val === "function") continue;
                if (first) {
                  first = false;
                } else {
                  out2 += ",";
                }
                out2 += "`" + key + "`=";
                out2 += this.escape(opts, info, val);
              }
              if (out2 === "") return "'" + escapeString(JSON.stringify(value)) + "'";
              return out2;
            } else {
              return "'" + escapeString(JSON.stringify(value)) + "'";
            }
          }
        }
      default:
        return "'" + escapeString(value) + "'";
    }
  };
  const LITTERAL_ESCAPE = {
    "\0": "\\0",
    "'": "\\'",
    '"': '\\"',
    "\b": "\\b",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "": "\\Z",
    "\\": "\\\\"
  };
  const CHARS_GLOBAL_REGEXP = /[\000\032"'\\\b\n\r\t]/g;
  const escapeString = (val) => {
    let offset = 0;
    let escaped = "";
    let match;
    while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
      escaped += val.substring(offset, match.index);
      escaped += LITTERAL_ESCAPE[match[0]];
      offset = CHARS_GLOBAL_REGEXP.lastIndex;
    }
    if (offset === 0) {
      return val;
    }
    if (offset < val.length) {
      escaped += val.substring(offset);
    }
    return escaped;
  };
  utils$2.escape = escapeParameters;
  return utils$2;
}
var packetInputStream;
var hasRequiredPacketInputStream;
function requirePacketInputStream() {
  if (hasRequiredPacketInputStream) return packetInputStream;
  hasRequiredPacketInputStream = 1;
  const PacketNodeEncoded = requirePacketNodeEncoded();
  const PacketIconvEncoded = requirePacketNodeIconv();
  const Collations = requireCollations();
  const Utils = requireUtils$2();
  class PacketInputStream {
    constructor(unexpectedPacket, receiveQueue, out2, opts, info) {
      this.unexpectedPacket = unexpectedPacket;
      this.opts = opts;
      this.receiveQueue = receiveQueue;
      this.info = info;
      this.out = out2;
      this.header = Buffer.allocUnsafe(4);
      this.headerLen = 0;
      this.packetLen = null;
      this.remainingLen = null;
      this.parts = null;
      this.partsTotalLen = 0;
      this.changeEncoding(this.opts.collation ? this.opts.collation : Collations.fromIndex(224));
      this.changeDebug(this.opts.debug);
      this.opts.on("collation", this.changeEncoding.bind(this));
      this.opts.on("debug", this.changeDebug.bind(this));
    }
    changeEncoding(collation) {
      this.encoding = collation.charset;
      this.packet = Buffer.isEncoding(this.encoding) ? new PacketNodeEncoded(this.encoding) : new PacketIconvEncoded(this.encoding);
    }
    changeDebug(debug) {
      this.receivePacket = debug ? this.receivePacketDebug : this.receivePacketBasic;
    }
    receivePacketDebug(packet2) {
      let cmd = this.currentCmd();
      this.header[0] = this.packetLen;
      this.header[1] = this.packetLen >> 8;
      this.header[2] = this.packetLen >> 16;
      this.header[3] = this.sequenceNo;
      if (packet2) {
        this.opts.logger.network(
          `<== conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.onPacketReceive ? cmd.constructor.name + "." + cmd.onPacketReceive.name : cmd.constructor.name : "no command"} (${packet2.pos},${packet2.end})
${Utils.log(this.opts, packet2.buf, packet2.pos, packet2.end, this.header)}`
        );
      }
      if (!cmd) {
        this.unexpectedPacket(packet2);
        return;
      }
      cmd.sequenceNo = this.sequenceNo;
      cmd.onPacketReceive(packet2, this.out, this.opts, this.info);
      if (!cmd.onPacketReceive) {
        this.receiveQueue.shift();
      }
    }
    receivePacketBasic(packet2) {
      let cmd = this.currentCmd();
      if (!cmd) {
        this.unexpectedPacket(packet2);
        return;
      }
      cmd.sequenceNo = this.sequenceNo;
      cmd.onPacketReceive(packet2, this.out, this.opts, this.info);
      if (!cmd.onPacketReceive) this.receiveQueue.shift();
    }
    resetHeader() {
      this.remainingLen = null;
      this.headerLen = 0;
    }
    currentCmd() {
      let cmd;
      while (cmd = this.receiveQueue.peek()) {
        if (cmd.onPacketReceive) return cmd;
        this.receiveQueue.shift();
      }
      return null;
    }
    onData(chunk) {
      let pos = 0;
      let length;
      const chunkLen = chunk.length;
      do {
        if (this.remainingLen) {
          length = this.remainingLen;
        } else if (this.headerLen === 0 && chunkLen - pos >= 4) {
          this.packetLen = chunk[pos] + (chunk[pos + 1] << 8) + (chunk[pos + 2] << 16);
          this.sequenceNo = chunk[pos + 3];
          pos += 4;
          length = this.packetLen;
        } else {
          length = null;
          while (chunkLen - pos > 0) {
            this.header[this.headerLen++] = chunk[pos++];
            if (this.headerLen === 4) {
              this.packetLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);
              this.sequenceNo = this.header[3];
              length = this.packetLen;
              break;
            }
          }
        }
        if (length) {
          if (chunkLen - pos >= length) {
            pos += length;
            if (!this.parts) {
              if (this.packetLen < 16777215) {
                this.receivePacket(this.packet.update(chunk, pos - length, pos));
                while (pos + 4 < chunkLen) {
                  this.packetLen = chunk[pos] + (chunk[pos + 1] << 8) + (chunk[pos + 2] << 16);
                  this.sequenceNo = chunk[pos + 3];
                  pos += 4;
                  if (chunkLen - pos >= this.packetLen) {
                    pos += this.packetLen;
                    if (this.packetLen < 16777215) {
                      this.receivePacket(this.packet.update(chunk, pos - this.packetLen, pos));
                    } else {
                      this.parts = [chunk.subarray(pos - this.packetLen, pos)];
                      this.partsTotalLen = this.packetLen;
                      break;
                    }
                  } else {
                    const buf = chunk.subarray(pos, chunkLen);
                    if (!this.parts) {
                      this.parts = [buf];
                      this.partsTotalLen = chunkLen - pos;
                    } else {
                      this.parts.push(buf);
                      this.partsTotalLen += chunkLen - pos;
                    }
                    this.remainingLen = this.packetLen - (chunkLen - pos);
                    return;
                  }
                }
              } else {
                this.parts = [chunk.subarray(pos - length, pos)];
                this.partsTotalLen = length;
              }
            } else {
              this.parts.push(chunk.subarray(pos - length, pos));
              this.partsTotalLen += length;
              if (this.packetLen < 16777215) {
                let buf = Buffer.concat(this.parts, this.partsTotalLen);
                this.parts = null;
                this.receivePacket(this.packet.update(buf, 0, this.partsTotalLen));
              }
            }
            this.resetHeader();
          } else {
            const buf = chunk.subarray(pos, chunkLen);
            if (!this.parts) {
              this.parts = [buf];
              this.partsTotalLen = chunkLen - pos;
            } else {
              this.parts.push(buf);
              this.partsTotalLen += chunkLen - pos;
            }
            this.remainingLen = length - (chunkLen - pos);
            return;
          }
        }
      } while (pos < chunkLen);
    }
  }
  packetInputStream = PacketInputStream;
  return packetInputStream;
}
var packetOutputStream;
var hasRequiredPacketOutputStream;
function requirePacketOutputStream() {
  if (hasRequiredPacketOutputStream) return packetOutputStream;
  hasRequiredPacketOutputStream = 1;
  const Iconv = requireLib$1();
  const Utils = requireUtils$2();
  const Errors = requireErrors();
  const Collations = requireCollations();
  const QUOTE = 39;
  const DBL_QUOTE = 34;
  const ZERO_BYTE = 0;
  const SLASH = 92;
  const SMALL_BUFFER_SIZE = 256;
  const MEDIUM_BUFFER_SIZE = 16384;
  const LARGE_BUFFER_SIZE = 131072;
  const BIG_BUFFER_SIZE = 1048576;
  const MAX_BUFFER_SIZE = 16777219;
  const CHARS_GLOBAL_REGEXP = /[\000\032"'\\\n\r\t]/g;
  class PacketOutputStream {
    constructor(opts, info) {
      this.opts = opts;
      this.info = info;
      this.pos = 4;
      this.markPos = -1;
      this.bufContainDataAfterMark = false;
      this.cmdLength = 0;
      this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
      this.maxAllowedPacket = opts.maxAllowedPacket || 16777216;
      this.maxPacketLength = Math.min(MAX_BUFFER_SIZE, this.maxAllowedPacket + 4);
      this.changeEncoding(this.opts.collation ? this.opts.collation : Collations.fromIndex(224));
      this.changeDebug(this.opts.debug);
      this.opts.on("collation", this.changeEncoding.bind(this));
      this.opts.on("debug", this.changeDebug.bind(this));
    }
    changeEncoding(collation) {
      this.encoding = collation.charset;
      if (this.encoding === "utf8") {
        this.writeString = this.writeDefaultBufferString;
        this.encodeString = this.encodeNodeString;
        this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;
        this.writeStringEscapeQuote = this.writeUtf8StringEscapeQuote;
      } else if (Buffer.isEncoding(this.encoding)) {
        this.writeString = this.writeDefaultBufferString;
        this.encodeString = this.encodeNodeString;
        this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;
        this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;
      } else {
        this.writeString = this.writeDefaultIconvString;
        this.encodeString = this.encodeIconvString;
        this.writeLengthEncodedString = this.writeDefaultIconvLengthEncodedString;
        this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;
      }
    }
    changeDebug(debug) {
      this.debug = debug;
      this.flushBuffer = debug ? this.flushBufferDebug : this.flushBufferBasic;
      this.fastFlush = debug ? this.fastFlushDebug : this.fastFlushBasic;
    }
    setStream(stream2) {
      this.stream = stream2;
    }
    growBuffer(len) {
      let newCapacity;
      if (len + this.pos < MEDIUM_BUFFER_SIZE) {
        newCapacity = MEDIUM_BUFFER_SIZE;
      } else if (len + this.pos < LARGE_BUFFER_SIZE) {
        newCapacity = LARGE_BUFFER_SIZE;
      } else if (len + this.pos < BIG_BUFFER_SIZE) {
        newCapacity = BIG_BUFFER_SIZE;
      } else if (this.bufContainDataAfterMark) {
        newCapacity = len + this.pos;
      } else {
        newCapacity = MAX_BUFFER_SIZE;
      }
      if (len + this.pos > newCapacity) {
        if (this.markPos !== -1) {
          this.flushBufferStopAtMark();
          if (len + this.pos <= this.buf.length) {
            return;
          }
          return this.growBuffer(len);
        }
      }
      let newBuf = Buffer.allocUnsafe(newCapacity);
      this.buf.copy(newBuf, 0, 0, this.pos);
      this.buf = newBuf;
    }
    mark() {
      this.markPos = this.pos;
    }
    isMarked() {
      return this.markPos !== -1;
    }
    hasFlushed() {
      return this.cmd.sequenceNo !== -1;
    }
    bufIsDataAfterMark() {
      return this.bufContainDataAfterMark;
    }
    bufIsAfterMaxPacketLength() {
      return this.pos > this.maxPacketLength;
    }
    /**
     * Reset mark flag and send bytes after mark flag.
     *
     * @return buffer after mark flag
     */
    resetMark() {
      this.pos = this.markPos;
      this.markPos = -1;
      if (this.bufContainDataAfterMark) {
        const data = Buffer.allocUnsafe(this.pos - 4);
        this.buf.copy(data, 0, 4, this.pos);
        this.cmd.sequenceNo = -1;
        this.cmd.compressSequenceNo = -1;
        this.bufContainDataAfterMark = false;
        return data;
      }
      return null;
    }
    /**
     * Send packet to socket.
     *
     * @throws IOException if socket error occur.
     */
    flush() {
      this.flushBuffer(true, 0);
      this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
      this.cmd.sequenceNo = -1;
      this.cmd.compressSequenceNo = -1;
      this.cmdLength = 0;
      this.markPos = -1;
    }
    flushPacket() {
      this.flushBuffer(false, 0);
      this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
      this.cmdLength = 0;
      this.markPos = -1;
    }
    startPacket(cmd) {
      this.cmd = cmd;
      this.pos = 4;
    }
    writeInt8(value) {
      if (this.pos + 1 >= this.buf.length) {
        if (this.pos >= MAX_BUFFER_SIZE && !this.bufContainDataAfterMark) {
          this.flushBuffer(false, 1);
        } else this.growBuffer(1);
      }
      this.buf[this.pos++] = value;
    }
    writeInt16(value) {
      if (this.pos + 2 >= this.buf.length) {
        let b = Buffer.allocUnsafe(2);
        b[0] = value;
        b[1] = value >>> 8;
        this.writeBuffer(b, 0, 2);
        return;
      }
      this.buf[this.pos] = value;
      this.buf[this.pos + 1] = value >> 8;
      this.pos += 2;
    }
    writeInt16AtPos(initPos) {
      this.buf[initPos] = this.pos - initPos - 2;
      this.buf[initPos + 1] = this.pos - initPos - 2 >> 8;
    }
    writeInt24(value) {
      if (this.pos + 3 >= this.buf.length) {
        let arr = Buffer.allocUnsafe(3);
        arr[0] = value;
        arr[1] = value >> 8;
        arr[2] = value >> 16;
        this.writeBuffer(arr, 0, 3);
        return;
      }
      this.buf[this.pos] = value;
      this.buf[this.pos + 1] = value >> 8;
      this.buf[this.pos + 2] = value >> 16;
      this.pos += 3;
    }
    writeInt32(value) {
      if (this.pos + 4 >= this.buf.length) {
        let arr = Buffer.allocUnsafe(4);
        arr.writeInt32LE(value, 0);
        this.writeBuffer(arr, 0, 4);
        return;
      }
      this.buf[this.pos] = value;
      this.buf[this.pos + 1] = value >> 8;
      this.buf[this.pos + 2] = value >> 16;
      this.buf[this.pos + 3] = value >> 24;
      this.pos += 4;
    }
    writeBigInt(value) {
      if (this.pos + 8 >= this.buf.length) {
        let arr = Buffer.allocUnsafe(8);
        arr.writeBigInt64LE(value, 0);
        this.writeBuffer(arr, 0, 8);
        return;
      }
      this.buf.writeBigInt64LE(value, this.pos);
      this.pos += 8;
    }
    writeDouble(value) {
      if (this.pos + 8 >= this.buf.length) {
        let arr = Buffer.allocUnsafe(8);
        arr.writeDoubleLE(value, 0);
        this.writeBuffer(arr, 0, 8);
        return;
      }
      this.buf.writeDoubleLE(value, this.pos);
      this.pos += 8;
    }
    writeLengthCoded(len) {
      if (len < 251) {
        this.writeInt8(len);
        return;
      }
      if (len < 65536) {
        this.writeInt8(252);
        this.writeInt16(len);
      } else if (len < 16777216) {
        this.writeInt8(253);
        this.writeInt24(len);
      } else {
        this.writeInt8(254);
        this.writeBigInt(BigInt(len));
      }
    }
    writeBuffer(arr, off, len) {
      if (len > this.buf.length - this.pos) {
        if (this.buf.length !== MAX_BUFFER_SIZE) {
          this.growBuffer(len);
        }
        if (len > this.buf.length - this.pos) {
          if (this.markPos !== -1) {
            this.growBuffer(len);
            if (this.markPos !== -1) {
              this.flushBufferStopAtMark();
            }
          }
          if (len > this.buf.length - this.pos) {
            let remainingLen = len;
            while (true) {
              let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);
              arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);
              remainingLen -= lenToFillBuffer;
              off += lenToFillBuffer;
              this.pos += lenToFillBuffer;
              if (remainingLen === 0) return;
              this.flushBuffer(false, remainingLen);
            }
          }
        }
      }
      if (len > 50) {
        arr.copy(this.buf, this.pos, off, off + len);
        this.pos += len;
      } else {
        for (let i = 0; i < len; ) {
          this.buf[this.pos++] = arr[off + i++];
        }
      }
    }
    /**
     * Write ascii string to socket (no escaping)
     *
     * @param str                string
     */
    writeStringAscii(str2) {
      let len = str2.length;
      if (len >= this.buf.length - this.pos) {
        let strBuf = Buffer.from(str2, "ascii");
        this.writeBuffer(strBuf, 0, strBuf.length);
        return;
      }
      for (let off = 0; off < len; ) {
        this.buf[this.pos++] = str2.charCodeAt(off++);
      }
    }
    writeLengthEncodedBuffer(buffer) {
      const len = buffer.length;
      this.writeLengthCoded(len);
      this.writeBuffer(buffer, 0, len);
    }
    writeUtf8StringEscapeQuote(str2) {
      const charsLength = str2.length;
      if (charsLength * 3 + 2 >= this.buf.length - this.pos) {
        const arr = Buffer.from(str2, "utf8");
        this.writeInt8(QUOTE);
        this.writeBufferEscape(arr);
        this.writeInt8(QUOTE);
        return;
      }
      let charsOffset = 0;
      let currChar;
      this.buf[this.pos++] = QUOTE;
      for (; charsOffset < charsLength && (currChar = str2.charCodeAt(charsOffset)) < 128; charsOffset++) {
        if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {
          this.buf[this.pos++] = SLASH;
        }
        this.buf[this.pos++] = currChar;
      }
      while (charsOffset < charsLength) {
        currChar = str2.charCodeAt(charsOffset++);
        if (currChar < 128) {
          if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {
            this.buf[this.pos++] = SLASH;
          }
          this.buf[this.pos++] = currChar;
        } else if (currChar < 2048) {
          this.buf[this.pos++] = 192 | currChar >> 6;
          this.buf[this.pos++] = 128 | currChar & 63;
        } else if (currChar >= 55296 && currChar < 57344) {
          if (currChar < 56320) {
            if (charsOffset + 1 > charsLength) {
              this.buf[this.pos++] = 63;
            } else {
              const nextChar = str2.charCodeAt(charsOffset);
              if (nextChar >= 56320 && nextChar < 57344) {
                const surrogatePairs = (currChar << 10) + nextChar + (65536 - (55296 << 10) - 56320);
                this.buf[this.pos++] = 240 | surrogatePairs >> 18;
                this.buf[this.pos++] = 128 | surrogatePairs >> 12 & 63;
                this.buf[this.pos++] = 128 | surrogatePairs >> 6 & 63;
                this.buf[this.pos++] = 128 | surrogatePairs & 63;
                charsOffset++;
              } else {
                this.buf[this.pos++] = 63;
              }
            }
          } else {
            this.buf[this.pos++] = 63;
          }
        } else {
          this.buf[this.pos++] = 224 | currChar >> 12;
          this.buf[this.pos++] = 128 | currChar >> 6 & 63;
          this.buf[this.pos++] = 128 | currChar & 63;
        }
      }
      this.buf[this.pos++] = QUOTE;
    }
    encodeIconvString(str2) {
      return Iconv.encode(str2, this.encoding);
    }
    encodeNodeString(str2) {
      return Buffer.from(str2, this.encoding);
    }
    writeDefaultBufferString(str2) {
      if (str2.length * 3 < this.buf.length - this.pos) {
        this.pos += this.buf.write(str2, this.pos, this.encoding);
        return;
      }
      let byteLength = Buffer.byteLength(str2, this.encoding);
      if (byteLength > this.buf.length - this.pos) {
        if (this.buf.length < MAX_BUFFER_SIZE) {
          this.growBuffer(byteLength);
        }
        if (byteLength > this.buf.length - this.pos) {
          let strBuf = Buffer.from(str2, this.encoding);
          this.writeBuffer(strBuf, 0, strBuf.length);
          return;
        }
      }
      this.pos += this.buf.write(str2, this.pos, this.encoding);
    }
    writeDefaultBufferLengthEncodedString(str2) {
      let byteLength = Buffer.byteLength(str2, this.encoding);
      this.writeLengthCoded(byteLength);
      if (byteLength > this.buf.length - this.pos) {
        if (this.buf.length < MAX_BUFFER_SIZE) {
          this.growBuffer(byteLength);
        }
        if (byteLength > this.buf.length - this.pos) {
          let strBuf = Buffer.from(str2, this.encoding);
          this.writeBuffer(strBuf, 0, strBuf.length);
          return;
        }
      }
      this.pos += this.buf.write(str2, this.pos, this.encoding);
    }
    writeDefaultIconvString(str2) {
      let buf = Iconv.encode(str2, this.encoding);
      this.writeBuffer(buf, 0, buf.length);
    }
    writeDefaultIconvLengthEncodedString(str2) {
      let buf = Iconv.encode(str2, this.encoding);
      this.writeLengthCoded(buf.length);
      this.writeBuffer(buf, 0, buf.length);
    }
    /**
     * Parameters need to be properly escaped :
     * following characters are to be escaped by "\" :
     * - \0
     * - \\
     * - \'
     * - \"
     * - \032
     * regex split part of string writing part, and escaping special char.
     * Those chars are <= 7f meaning that this will work even with multibyte encoding
     *
     * @param str string to escape.
     */
    writeDefaultStringEscapeQuote(str2) {
      this.writeInt8(QUOTE);
      let match;
      let lastIndex = 0;
      while ((match = CHARS_GLOBAL_REGEXP.exec(str2)) !== null) {
        this.writeString(str2.slice(lastIndex, match.index));
        this.writeInt8(SLASH);
        this.writeInt8(match[0].charCodeAt(0));
        lastIndex = CHARS_GLOBAL_REGEXP.lastIndex;
      }
      if (lastIndex === 0) {
        this.writeString(str2);
        this.writeInt8(QUOTE);
        return;
      }
      if (lastIndex < str2.length) {
        this.writeString(str2.slice(lastIndex));
      }
      this.writeInt8(QUOTE);
    }
    writeBinaryDate(date) {
      const year = date.getFullYear();
      const mon = date.getMonth() + 1;
      const day = date.getDate();
      const hour = date.getHours();
      const min = date.getMinutes();
      const sec = date.getSeconds();
      const ms2 = date.getMilliseconds();
      let len = ms2 === 0 ? 7 : 11;
      if (len + 1 > this.buf.length - this.pos) {
        let tmpBuf = Buffer.allocUnsafe(len + 1);
        tmpBuf[0] = len;
        tmpBuf[1] = year;
        tmpBuf[2] = year >>> 8;
        tmpBuf[3] = mon;
        tmpBuf[4] = day;
        tmpBuf[5] = hour;
        tmpBuf[6] = min;
        tmpBuf[7] = sec;
        if (ms2 !== 0) {
          const micro = ms2 * 1e3;
          tmpBuf[8] = micro;
          tmpBuf[9] = micro >>> 8;
          tmpBuf[10] = micro >>> 16;
          tmpBuf[11] = micro >>> 24;
        }
        this.writeBuffer(tmpBuf, 0, len + 1);
        return;
      }
      this.buf[this.pos] = len;
      this.buf[this.pos + 1] = year;
      this.buf[this.pos + 2] = year >>> 8;
      this.buf[this.pos + 3] = mon;
      this.buf[this.pos + 4] = day;
      this.buf[this.pos + 5] = hour;
      this.buf[this.pos + 6] = min;
      this.buf[this.pos + 7] = sec;
      if (ms2 !== 0) {
        const micro = ms2 * 1e3;
        this.buf[this.pos + 8] = micro;
        this.buf[this.pos + 9] = micro >>> 8;
        this.buf[this.pos + 10] = micro >>> 16;
        this.buf[this.pos + 11] = micro >>> 24;
      }
      this.pos += len + 1;
    }
    writeBufferEscape(val) {
      let valLen = val.length;
      if (valLen * 2 > this.buf.length - this.pos) {
        if (this.buf.length !== MAX_BUFFER_SIZE) this.growBuffer(valLen * 2);
        if (valLen * 2 > this.buf.length - this.pos) {
          for (let i = 0; i < valLen; i++) {
            switch (val[i]) {
              case QUOTE:
              case SLASH:
              case DBL_QUOTE:
              case ZERO_BYTE:
                if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);
                this.buf[this.pos++] = SLASH;
            }
            if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);
            this.buf[this.pos++] = val[i];
          }
          return;
        }
      }
      for (let i = 0; i < valLen; i++) {
        switch (val[i]) {
          case QUOTE:
          case SLASH:
          case DBL_QUOTE:
          case ZERO_BYTE:
            this.buf[this.pos++] = SLASH;
        }
        this.buf[this.pos++] = val[i];
      }
    }
    /**
     * Count query size. If query size is greater than max_allowed_packet and nothing has been already
     * send, throw an exception to avoid having the connection closed.
     *
     * @param length additional length to query size
     * @param info current connection information
     * @throws Error if query has not to be sent.
     */
    checkMaxAllowedLength(length, info) {
      if (this.opts.maxAllowedPacket && this.cmdLength + length >= this.maxAllowedPacket) {
        return Errors.createError(
          `query size (${this.cmdLength + length}) is >= to max_allowed_packet (${this.maxAllowedPacket})`,
          Errors.ER_MAX_ALLOWED_PACKET,
          info
        );
      }
      return null;
    }
    /**
     * Indicate if buffer contain any data.
     * @returns {boolean}
     */
    isEmpty() {
      return this.pos <= 4;
    }
    /**
     * Flush the internal buffer.
     */
    flushBufferDebug(commandEnd, remainingLen) {
      if (this.pos > 4) {
        this.buf[0] = this.pos - 4;
        this.buf[1] = this.pos - 4 >>> 8;
        this.buf[2] = this.pos - 4 >>> 16;
        this.buf[3] = ++this.cmd.sequenceNo;
        this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);
        this.stream.flush(true, this.cmd);
        this.cmdLength += this.pos - 4;
        this.opts.logger.network(
          `==> conn:${this.info.threadId ? this.info.threadId : -1} ${this.cmd.constructor.name + "(0," + this.pos + ")"}
${Utils.log(this.opts, this.buf, 0, this.pos)}`
        );
        if (commandEnd && this.pos === MAX_BUFFER_SIZE) {
          this.writeEmptyPacket();
        }
        this.buf = this.createBufferWithMinSize(remainingLen);
        this.pos = 4;
      }
    }
    /**
     * Flush to last mark.
     */
    flushBufferStopAtMark() {
      const end = this.pos;
      this.pos = this.markPos;
      const tmpBuf = Buffer.allocUnsafe(Math.max(SMALL_BUFFER_SIZE, end + 4 - this.pos));
      this.buf.copy(tmpBuf, 4, this.markPos, end);
      this.flushBuffer(true, end - this.pos);
      this.cmdLength = 0;
      this.buf = tmpBuf;
      this.pos = 4 + end - this.markPos;
      this.markPos = -1;
      this.bufContainDataAfterMark = true;
    }
    flushBufferBasic(commandEnd, remainingLen) {
      this.buf[0] = this.pos - 4;
      this.buf[1] = this.pos - 4 >>> 8;
      this.buf[2] = this.pos - 4 >>> 16;
      this.buf[3] = ++this.cmd.sequenceNo;
      this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);
      this.stream.flush(true, this.cmd);
      this.cmdLength += this.pos - 4;
      if (commandEnd && this.pos === MAX_BUFFER_SIZE) {
        this.writeEmptyPacket();
      }
      this.buf = this.createBufferWithMinSize(remainingLen);
      this.pos = 4;
    }
    createBufferWithMinSize(remainingLen) {
      let newCapacity;
      if (remainingLen + 4 < SMALL_BUFFER_SIZE) {
        newCapacity = SMALL_BUFFER_SIZE;
      } else if (remainingLen + 4 < MEDIUM_BUFFER_SIZE) {
        newCapacity = MEDIUM_BUFFER_SIZE;
      } else if (remainingLen + 4 < LARGE_BUFFER_SIZE) {
        newCapacity = LARGE_BUFFER_SIZE;
      } else if (remainingLen + 4 < BIG_BUFFER_SIZE) {
        newCapacity = BIG_BUFFER_SIZE;
      } else {
        newCapacity = MAX_BUFFER_SIZE;
      }
      return Buffer.allocUnsafe(newCapacity);
    }
    fastFlushDebug(cmd, packet2) {
      this.stream.writeBuf(packet2, cmd);
      this.stream.flush(true, cmd);
      this.cmdLength += packet2.length;
      this.opts.logger.network(
        `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd.constructor.name + "(0," + packet2.length + ")"}
${Utils.log(this.opts, packet2, 0, packet2.length)}`
      );
      this.cmdLength = 0;
      this.markPos = -1;
    }
    fastFlushBasic(cmd, packet2) {
      this.stream.writeBuf(packet2, cmd);
      this.stream.flush(true, cmd);
      this.cmdLength = 0;
      this.markPos = -1;
    }
    writeEmptyPacket() {
      const emptyBuf = Buffer.from([0, 0, 0, ++this.cmd.sequenceNo]);
      if (this.debug) {
        this.opts.logger.network(
          `==> conn:${this.info.threadId ? this.info.threadId : -1} ${this.cmd.constructor.name}(0,4)
${Utils.log(
            this.opts,
            emptyBuf,
            0,
            4
          )}`
        );
      }
      this.stream.writeBuf(emptyBuf, this.cmd);
      this.stream.flush(true, this.cmd);
      this.cmdLength = 0;
    }
  }
  packetOutputStream = PacketOutputStream;
  return packetOutputStream;
}
var compressionInputStream;
var hasRequiredCompressionInputStream;
function requireCompressionInputStream() {
  if (hasRequiredCompressionInputStream) return compressionInputStream;
  hasRequiredCompressionInputStream = 1;
  const ZLib = require$$0$2;
  const Utils = requireUtils$2();
  class CompressionInputStream {
    constructor(reader, receiveQueue, opts, info) {
      this.reader = reader;
      this.receiveQueue = receiveQueue;
      this.info = info;
      this.opts = opts;
      this.header = Buffer.allocUnsafe(7);
      this.headerLen = 0;
      this.compressPacketLen = null;
      this.packetLen = null;
      this.remainingLen = null;
      this.parts = null;
      this.partsTotalLen = 0;
    }
    receivePacket(chunk) {
      let cmd = this.currentCmd();
      if (this.opts.debugCompress) {
        this.opts.logger.network(
          `<== conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.onPacketReceive ? cmd.constructor.name + "." + cmd.onPacketReceive.name : cmd.constructor.name : "no command"} (compress)
${Utils.log(this.opts, chunk, 0, chunk.length, this.header)}`
        );
      }
      if (cmd) cmd.compressSequenceNo = this.header[3];
      const unCompressLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;
      if (unCompressLen === 0) {
        this.reader.onData(chunk);
      } else {
        const unCompressChunk = ZLib.inflateSync(chunk);
        this.reader.onData(unCompressChunk);
      }
    }
    currentCmd() {
      let cmd;
      while (cmd = this.receiveQueue.peek()) {
        if (cmd.onPacketReceive) return cmd;
        this.receiveQueue.shift();
      }
      return null;
    }
    resetHeader() {
      this.remainingLen = null;
      this.headerLen = 0;
    }
    onData(chunk) {
      let pos = 0;
      let length;
      const chunkLen = chunk.length;
      do {
        if (this.remainingLen) {
          length = this.remainingLen;
        } else if (this.headerLen === 0 && chunkLen - pos >= 7) {
          this.header[0] = chunk[pos];
          this.header[1] = chunk[pos + 1];
          this.header[2] = chunk[pos + 2];
          this.header[3] = chunk[pos + 3];
          this.header[4] = chunk[pos + 4];
          this.header[5] = chunk[pos + 5];
          this.header[6] = chunk[pos + 6];
          this.headerLen = 7;
          pos += 7;
          this.compressPacketLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);
          this.packetLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;
          if (this.packetLen === 0) this.packetLen = this.compressPacketLen;
          length = this.compressPacketLen;
        } else {
          length = null;
          while (chunkLen - pos > 0) {
            this.header[this.headerLen++] = chunk[pos++];
            if (this.headerLen === 7) {
              this.compressPacketLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);
              this.packetLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;
              if (this.packetLen === 0) this.packetLen = this.compressPacketLen;
              length = this.compressPacketLen;
              break;
            }
          }
        }
        if (length) {
          if (chunkLen - pos >= length) {
            const buf = chunk.subarray(pos, pos + length);
            pos += length;
            if (this.parts) {
              this.parts.push(buf);
              this.partsTotalLen += length;
              if (this.compressPacketLen < 16777215) {
                let buf2 = Buffer.concat(this.parts, this.partsTotalLen);
                this.parts = null;
                this.receivePacket(buf2);
              }
            } else {
              if (this.compressPacketLen < 16777215) {
                this.receivePacket(buf);
              } else {
                this.parts = [buf];
                this.partsTotalLen = length;
              }
            }
            this.resetHeader();
          } else {
            const buf = chunk.subarray(pos, chunkLen);
            if (!this.parts) {
              this.parts = [buf];
              this.partsTotalLen = chunkLen - pos;
            } else {
              this.parts.push(buf);
              this.partsTotalLen += chunkLen - pos;
            }
            this.remainingLen = length - (chunkLen - pos);
            return;
          }
        }
      } while (pos < chunkLen);
    }
  }
  compressionInputStream = CompressionInputStream;
  return compressionInputStream;
}
var compressionOutputStream;
var hasRequiredCompressionOutputStream;
function requireCompressionOutputStream() {
  if (hasRequiredCompressionOutputStream) return compressionOutputStream;
  hasRequiredCompressionOutputStream = 1;
  const Utils = requireUtils$2();
  const ZLib = require$$0$2;
  const SMALL_BUFFER_SIZE = 2048;
  const MEDIUM_BUFFER_SIZE = 131072;
  const LARGE_BUFFER_SIZE = 1048576;
  const MAX_BUFFER_SIZE = 16777222;
  class CompressionOutputStream {
    /**
     * Constructor
     *
     * @param socket    current socket
     * @param opts      current connection options
     * @param info      current connection information
     * @constructor
     */
    constructor(socket, opts, info) {
      this.info = info;
      this.opts = opts;
      this.pos = 7;
      this.header = Buffer.allocUnsafe(7);
      this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
      this.writer = (buffer) => {
        socket.write(buffer);
      };
    }
    growBuffer(len) {
      let newCapacity;
      if (len + this.pos < MEDIUM_BUFFER_SIZE) {
        newCapacity = MEDIUM_BUFFER_SIZE;
      } else if (len + this.pos < LARGE_BUFFER_SIZE) {
        newCapacity = LARGE_BUFFER_SIZE;
      } else newCapacity = MAX_BUFFER_SIZE;
      let newBuf = Buffer.allocUnsafe(newCapacity);
      this.buf.copy(newBuf, 0, 0, this.pos);
      this.buf = newBuf;
    }
    writeBuf(arr, cmd) {
      let off = 0, len = arr.length;
      if (arr instanceof Uint8Array) {
        arr = Buffer.from(arr);
      }
      if (len > this.buf.length - this.pos) {
        if (this.buf.length !== MAX_BUFFER_SIZE) {
          this.growBuffer(len);
        }
        if (len > this.buf.length - this.pos) {
          let remainingLen = len;
          while (true) {
            let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);
            arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);
            remainingLen -= lenToFillBuffer;
            off += lenToFillBuffer;
            this.pos += lenToFillBuffer;
            if (remainingLen === 0) return;
            this.flush(false, cmd, remainingLen);
          }
        }
      }
      arr.copy(this.buf, this.pos, off, off + len);
      this.pos += len;
    }
    /**
     * Flush the internal buffer.
     */
    flush(cmdEnd, cmd, remainingLen) {
      if (this.pos < 1536) {
        this.buf[0] = this.pos - 7;
        this.buf[1] = this.pos - 7 >>> 8;
        this.buf[2] = this.pos - 7 >>> 16;
        this.buf[3] = ++cmd.compressSequenceNo;
        this.buf[4] = 0;
        this.buf[5] = 0;
        this.buf[6] = 0;
        if (this.opts.debugCompress) {
          this.opts.logger.network(
            `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.constructor.name + "(0," + this.pos + ")" : "unknown"} (compress)
${Utils.log(this.opts, this.buf, 0, this.pos)}`
          );
        }
        this.writer(this.buf.subarray(0, this.pos));
      } else {
        const compressChunk = ZLib.deflateSync(this.buf.subarray(7, this.pos));
        const compressChunkLen = compressChunk.length;
        this.header[0] = compressChunkLen;
        this.header[1] = compressChunkLen >>> 8;
        this.header[2] = compressChunkLen >>> 16;
        this.header[3] = ++cmd.compressSequenceNo;
        this.header[4] = this.pos - 7;
        this.header[5] = this.pos - 7 >>> 8;
        this.header[6] = this.pos - 7 >>> 16;
        if (this.opts.debugCompress) {
          this.opts.logger.network(
            `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.constructor.name + "(0," + this.pos + "=>" + compressChunkLen + ")" : "unknown"} (compress)
${Utils.log(this.opts, compressChunk, 0, compressChunkLen, this.header)}`
          );
        }
        this.writer(this.header);
        this.writer(compressChunk);
        if (cmdEnd && compressChunkLen === MAX_BUFFER_SIZE) this.writeEmptyPacket(cmd);
        this.header = Buffer.allocUnsafe(7);
      }
      this.buf = remainingLen ? CompressionOutputStream.allocateBuffer(remainingLen) : Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
      this.pos = 7;
    }
    static allocateBuffer(len) {
      if (len + 4 < SMALL_BUFFER_SIZE) {
        return Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
      } else if (len + 4 < MEDIUM_BUFFER_SIZE) {
        return Buffer.allocUnsafe(MEDIUM_BUFFER_SIZE);
      } else if (len + 4 < LARGE_BUFFER_SIZE) {
        return Buffer.allocUnsafe(LARGE_BUFFER_SIZE);
      }
      return Buffer.allocUnsafe(MAX_BUFFER_SIZE);
    }
    writeEmptyPacket(cmd) {
      const emptyBuf = Buffer.from([0, 0, 0, cmd.compressSequenceNo, 0, 0, 0]);
      if (this.opts.debugCompress) {
        this.opts.logger.network(
          `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.constructor.name + "(0," + this.pos + ")" : "unknown"} (compress)
${Utils.log(this.opts, emptyBuf, 0, 7)}`
        );
      }
      this.writer(emptyBuf);
    }
  }
  compressionOutputStream = CompressionOutputStream;
  return compressionOutputStream;
}
var serverStatus = {};
var hasRequiredServerStatus;
function requireServerStatus() {
  if (hasRequiredServerStatus) return serverStatus;
  hasRequiredServerStatus = 1;
  serverStatus.STATUS_IN_TRANS = 1;
  serverStatus.STATUS_AUTOCOMMIT = 2;
  serverStatus.MORE_RESULTS_EXISTS = 8;
  serverStatus.QUERY_NO_GOOD_INDEX_USED = 16;
  serverStatus.QUERY_NO_INDEX_USED = 32;
  serverStatus.STATUS_CURSOR_EXISTS = 64;
  serverStatus.STATUS_LAST_ROW_SENT = 128;
  serverStatus.STATUS_DB_DROPPED = 1 << 8;
  serverStatus.STATUS_NO_BACKSLASH_ESCAPES = 1 << 9;
  serverStatus.STATUS_METADATA_CHANGED = 1 << 10;
  serverStatus.QUERY_WAS_SLOW = 1 << 11;
  serverStatus.PS_OUT_PARAMS = 1 << 12;
  serverStatus.STATUS_IN_TRANS_READONLY = 1 << 13;
  serverStatus.SESSION_STATE_CHANGED = 1 << 14;
  return serverStatus;
}
var connectionInformation;
var hasRequiredConnectionInformation;
function requireConnectionInformation() {
  var _redirectFct;
  if (hasRequiredConnectionInformation) return connectionInformation;
  hasRequiredConnectionInformation = 1;
  class ConnectionInformation {
    constructor(opts, redirectFct) {
      __privateAdd(this, _redirectFct);
      this.threadId = -1;
      this.status = null;
      this.serverVersion = null;
      this.serverCapabilities = null;
      this.database = opts.database;
      this.port = opts.port;
      __privateSet(this, _redirectFct, redirectFct);
      this.redirectRequest = null;
    }
    hasMinVersion(major, minor, patch) {
      if (!this.serverVersion) throw new Error("cannot know if server version until connection is established");
      if (!major) throw new Error("a major version must be set");
      if (!minor) minor = 0;
      if (!patch) patch = 0;
      let ver = this.serverVersion;
      return ver.major > major || ver.major === major && ver.minor > minor || ver.major === major && ver.minor === minor && ver.patch >= patch;
    }
    redirect(value, resolve) {
      return __privateGet(this, _redirectFct).call(this, value, resolve);
    }
    isMariaDB() {
      if (!this.serverVersion) throw new Error("cannot know if server is MariaDB until connection is established");
      return this.serverVersion.mariaDb;
    }
    /**
     * Parse raw info to set server major/minor/patch values
     * @param info
     */
    static parseVersionString(info) {
      let car;
      let offset = 0;
      let type2 = 0;
      let val = 0;
      for (; offset < info.serverVersion.raw.length; offset++) {
        car = info.serverVersion.raw.charCodeAt(offset);
        if (car < 48 || car > 57) {
          switch (type2) {
            case 0:
              info.serverVersion.major = val;
              break;
            case 1:
              info.serverVersion.minor = val;
              break;
            case 2:
              info.serverVersion.patch = val;
              return;
          }
          type2++;
          val = 0;
        } else {
          val = val * 10 + car - 48;
        }
      }
      if (type2 === 2) info.serverVersion.patch = val;
    }
  }
  _redirectFct = new WeakMap();
  connectionInformation = ConnectionInformation;
  return connectionInformation;
}
var capabilities = {};
var hasRequiredCapabilities;
function requireCapabilities() {
  if (hasRequiredCapabilities) return capabilities;
  hasRequiredCapabilities = 1;
  capabilities.MYSQL = 1n;
  capabilities.FOUND_ROWS = 2n;
  capabilities.LONG_FLAG = 4n;
  capabilities.CONNECT_WITH_DB = 8n;
  capabilities.NO_SCHEMA = 1n << 4n;
  capabilities.COMPRESS = 1n << 5n;
  capabilities.ODBC = 1n << 6n;
  capabilities.LOCAL_FILES = 1n << 7n;
  capabilities.IGNORE_SPACE = 1n << 8n;
  capabilities.PROTOCOL_41 = 1n << 9n;
  capabilities.INTERACTIVE = 1n << 10n;
  capabilities.SSL = 1n << 11n;
  capabilities.IGNORE_SIGPIPE = 1n << 12n;
  capabilities.TRANSACTIONS = 1n << 13n;
  capabilities.RESERVED = 1n << 14n;
  capabilities.SECURE_CONNECTION = 1n << 15n;
  capabilities.MULTI_STATEMENTS = 1n << 16n;
  capabilities.MULTI_RESULTS = 1n << 17n;
  capabilities.PS_MULTI_RESULTS = 1n << 18n;
  capabilities.PLUGIN_AUTH = 1n << 19n;
  capabilities.CONNECT_ATTRS = 1n << 20n;
  capabilities.PLUGIN_AUTH_LENENC_CLIENT_DATA = 1n << 21n;
  capabilities.CAN_HANDLE_EXPIRED_PASSWORDS = 1n << 22n;
  capabilities.SESSION_TRACK = 1n << 23n;
  capabilities.DEPRECATE_EOF = 1n << 24n;
  capabilities.SSL_VERIFY_SERVER_CERT = 1n << 30n;
  capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS = 1n << 34n;
  capabilities.MARIADB_CLIENT_EXTENDED_TYPE_INFO = 1n << 35n;
  capabilities.MARIADB_CLIENT_CACHE_METADATA = 1n << 36n;
  return capabilities;
}
var connectionOptions;
var hasRequiredConnectionOptions;
function requireConnectionOptions() {
  if (hasRequiredConnectionOptions) return connectionOptions;
  hasRequiredConnectionOptions = 1;
  const Collations = requireCollations();
  const urlFormat = /mariadb:\/\/(([^/@:]+)?(:([^/]+))?@)?(([^/:]+)(:([0-9]+))?)\/([^?]+)(\?(.*))?$/;
  class ConnectionOptions {
    constructor(opts) {
      if (typeof opts === "string") {
        opts = ConnectionOptions.parse(opts);
      }
      if (!opts) opts = {};
      this.host = opts.host || "localhost";
      this.port = opts.port || 3306;
      this.keepEof = opts.keepEof || false;
      this.user = opts.user || process.env.USERNAME;
      this.password = opts.password;
      this.database = opts.database;
      this.stream = opts.stream;
      this.debug = opts.debug || false;
      this.debugCompress = opts.debugCompress || false;
      this.debugLen = opts.debugLen || 256;
      this.logParam = opts.logParam === void 0 ? true : opts.logParam === true;
      if (opts.logger) {
        if (typeof opts.logger === "function") {
          this.logger = {
            network: opts.logger,
            query: opts.logger,
            error: opts.logger,
            warning: opts.logger
          };
        } else {
          this.logger = {
            network: opts.logger.network,
            query: opts.logger.query,
            error: opts.logger.error,
            warning: opts.logger.warning || console.log
          };
          if (opts.logger.logParam !== void 0) this.logParam = opts.logger.logParam;
        }
      } else {
        this.logger = {
          network: this.debug || this.debugCompress ? console.log : null,
          query: null,
          error: null,
          warning: console.log
        };
      }
      this.debug = !!this.logger.network;
      if (opts.charset && typeof opts.charset === "string") {
        this.collation = Collations.fromCharset(opts.charset.toLowerCase());
        if (this.collation === void 0) {
          this.collation = Collations.fromName(opts.charset.toUpperCase());
          if (this.collation !== void 0) {
            this.logger.warning(
              "warning: please use option 'collation' in replacement of 'charset' when using a collation name ('" + opts.charset + "')\n(collation looks like 'UTF8MB4_UNICODE_CI', charset like 'utf8')."
            );
          } else {
            this.charset = opts.charset;
          }
        }
      } else if (opts.collation && typeof opts.collation === "string") {
        this.collation = Collations.fromName(opts.collation.toUpperCase());
        if (this.collation === void 0) throw new RangeError("Unknown collation '" + opts.collation + "'");
      } else {
        this.collation = opts.charsetNumber ? Collations.fromIndex(opts.charsetNumber) : void 0;
      }
      this.permitRedirect = opts.permitRedirect === void 0 ? true : opts.permitRedirect;
      this.initSql = opts.initSql;
      this.connectTimeout = opts.connectTimeout === void 0 ? 1e3 : opts.connectTimeout;
      this.connectAttributes = opts.connectAttributes || false;
      this.compress = opts.compress || false;
      this.rsaPublicKey = opts.rsaPublicKey;
      this.cachingRsaPublicKey = opts.cachingRsaPublicKey;
      this.allowPublicKeyRetrieval = opts.allowPublicKeyRetrieval || false;
      this.forceVersionCheck = opts.forceVersionCheck || false;
      this.maxAllowedPacket = opts.maxAllowedPacket;
      this.permitConnectionWhenExpired = opts.permitConnectionWhenExpired || false;
      this.pipelining = opts.pipelining;
      this.timezone = opts.timezone || "local";
      this.socketPath = opts.socketPath;
      this.sessionVariables = opts.sessionVariables;
      this.infileStreamFactory = opts.infileStreamFactory;
      this.ssl = opts.ssl;
      if (opts.ssl) {
        if (typeof opts.ssl !== "boolean" && typeof opts.ssl !== "string") {
          this.ssl.rejectUnauthorized = opts.ssl.rejectUnauthorized !== false;
        }
      }
      this.queryTimeout = opts.queryTimeout === void 0 ? 0 : opts.queryTimeout;
      this.socketTimeout = opts.socketTimeout === void 0 ? 0 : opts.socketTimeout;
      this.keepAliveDelay = opts.keepAliveDelay === void 0 ? 0 : opts.keepAliveDelay;
      if (!opts.keepAliveDelay) {
        if (opts.enableKeepAlive === true && opts.keepAliveInitialDelay !== void 0) {
          this.keepAliveDelay = opts.keepAliveInitialDelay;
        }
      }
      this.trace = opts.trace || false;
      this.checkDuplicate = opts.checkDuplicate === void 0 ? true : opts.checkDuplicate;
      this.dateStrings = opts.dateStrings || false;
      this.foundRows = opts.foundRows === void 0 || opts.foundRows;
      this.metaAsArray = opts.metaAsArray || false;
      this.metaEnumerable = opts.metaEnumerable || false;
      this.multipleStatements = opts.multipleStatements || false;
      this.namedPlaceholders = opts.namedPlaceholders || false;
      this.nestTables = opts.nestTables;
      this.autoJsonMap = opts.autoJsonMap === void 0 ? true : opts.autoJsonMap;
      this.jsonStrings = opts.jsonStrings || false;
      if (opts.jsonStrings !== void 0) {
        this.autoJsonMap = !this.jsonStrings;
      }
      this.bitOneIsBoolean = opts.bitOneIsBoolean === void 0 ? true : opts.bitOneIsBoolean;
      this.arrayParenthesis = opts.arrayParenthesis || false;
      this.permitSetMultiParamEntries = opts.permitSetMultiParamEntries || false;
      this.rowsAsArray = opts.rowsAsArray || false;
      this.typeCast = opts.typeCast;
      if (this.typeCast !== void 0 && typeof this.typeCast !== "function") {
        this.typeCast = void 0;
      }
      this.bulk = opts.bulk === void 0 || opts.bulk;
      this.checkNumberRange = opts.checkNumberRange || false;
      if (opts.pipelining === void 0) {
        this.permitLocalInfile = opts.permitLocalInfile || false;
        this.pipelining = !this.permitLocalInfile;
      } else {
        this.pipelining = opts.pipelining;
        if (opts.permitLocalInfile === true && this.pipelining) {
          throw new Error(
            "enabling options `permitLocalInfile` and `pipelining` is not possible, options are incompatible."
          );
        }
        this.permitLocalInfile = this.pipelining ? false : opts.permitLocalInfile || false;
      }
      this.prepareCacheLength = opts.prepareCacheLength === void 0 ? 256 : opts.prepareCacheLength;
      this.restrictedAuth = opts.restrictedAuth;
      if (this.restrictedAuth != null) {
        if (!Array.isArray(this.restrictedAuth)) {
          this.restrictedAuth = this.restrictedAuth.split(",");
        }
      }
      this.bigIntAsNumber = opts.bigIntAsNumber || false;
      this.insertIdAsNumber = opts.insertIdAsNumber || false;
      this.decimalAsNumber = opts.decimalAsNumber || false;
      this.supportBigNumbers = opts.supportBigNumbers || false;
      this.bigNumberStrings = opts.bigNumberStrings || false;
      if (this.maxAllowedPacket && !Number.isInteger(this.maxAllowedPacket)) {
        throw new RangeError("maxAllowedPacket must be an integer. was '" + this.maxAllowedPacket + "'");
      }
    }
    /**
     * When parsing from String, correcting type.
     *
     * @param opts options
     * @return {opts}
     */
    static parseOptionDataType(opts) {
      if (opts.bulk) opts.bulk = opts.bulk === "true";
      if (opts.allowPublicKeyRetrieval) opts.allowPublicKeyRetrieval = opts.allowPublicKeyRetrieval === "true";
      if (opts.insertIdAsNumber) opts.insertIdAsNumber = opts.insertIdAsNumber === "true";
      if (opts.decimalAsNumber) opts.decimalAsNumber = opts.decimalAsNumber === "true";
      if (opts.bigIntAsNumber) opts.bigIntAsNumber = opts.bigIntAsNumber === "true";
      if (opts.charsetNumber && !isNaN(Number.parseInt(opts.charsetNumber))) {
        opts.charsetNumber = Number.parseInt(opts.charsetNumber);
      }
      if (opts.permitRedirect) opts.permitRedirect = opts.permitRedirect === "true";
      if (opts.logParam) opts.logParam = opts.logParam === "true";
      if (opts.compress) opts.compress = opts.compress === "true";
      if (opts.connectAttributes) opts.connectAttributes = JSON.parse(opts.connectAttributes);
      if (opts.connectTimeout) opts.connectTimeout = parseInt(opts.connectTimeout);
      if (opts.keepAliveDelay) opts.keepAliveDelay = parseInt(opts.keepAliveDelay);
      if (opts.socketTimeout) opts.socketTimeout = parseInt(opts.socketTimeout);
      if (opts.dateStrings) opts.dateStrings = opts.dateStrings === "true";
      if (opts.debug) opts.debug = opts.debug === "true";
      if (opts.autoJsonMap) opts.autoJsonMap = opts.autoJsonMap === "true";
      if (opts.arrayParenthesis) opts.arrayParenthesis = opts.arrayParenthesis === "true";
      if (opts.checkDuplicate) opts.checkDuplicate = opts.checkDuplicate === "true";
      if (opts.debugCompress) opts.debugCompress = opts.debugCompress === "true";
      if (opts.debugLen) opts.debugLen = parseInt(opts.debugLen);
      if (opts.prepareCacheLength) opts.prepareCacheLength = parseInt(opts.prepareCacheLength);
      if (opts.queryTimeout) opts.queryTimeout = parseInt(opts.queryTimeout);
      if (opts.foundRows) opts.foundRows = opts.foundRows === "true";
      if (opts.maxAllowedPacket && !isNaN(Number.parseInt(opts.maxAllowedPacket)))
        opts.maxAllowedPacket = parseInt(opts.maxAllowedPacket);
      if (opts.metaAsArray) opts.metaAsArray = opts.metaAsArray === "true";
      if (opts.metaEnumerable) opts.metaEnumerable = opts.metaEnumerable === "true";
      if (opts.multipleStatements) opts.multipleStatements = opts.multipleStatements === "true";
      if (opts.namedPlaceholders) opts.namedPlaceholders = opts.namedPlaceholders === "true";
      if (opts.nestTables) opts.nestTables = opts.nestTables === "true";
      if (opts.permitSetMultiParamEntries) opts.permitSetMultiParamEntries = opts.permitSetMultiParamEntries === "true";
      if (opts.pipelining) opts.pipelining = opts.pipelining === "true";
      if (opts.forceVersionCheck) opts.forceVersionCheck = opts.forceVersionCheck === "true";
      if (opts.rowsAsArray) opts.rowsAsArray = opts.rowsAsArray === "true";
      if (opts.trace) opts.trace = opts.trace === "true";
      if (opts.ssl && (opts.ssl === "true" || opts.ssl === "false")) opts.ssl = opts.ssl === "true";
      if (opts.bitOneIsBoolean) opts.bitOneIsBoolean = opts.bitOneIsBoolean === "true";
      if (opts.jsonStrings) opts.jsonStrings = opts.jsonStrings === "true";
      if (opts.enableKeepAlive) opts.enableKeepAlive = opts.enableKeepAlive === "true";
      if (opts.keepAliveInitialDelay) opts.keepAliveInitialDelay = parseInt(opts.keepAliveInitialDelay);
      return opts;
    }
    static parse(opts) {
      const matchResults = opts.match(urlFormat);
      if (!matchResults) {
        throw new Error(
          `error parsing connection string '${opts}'. format must be 'mariadb://[<user>[:<password>]@]<host>[:<port>]/[<db>[?<opt1>=<value1>[&<opt2>=<value2>]]]'`
        );
      }
      const options = {
        user: matchResults[2] ? decodeURIComponent(matchResults[2]) : void 0,
        password: matchResults[4] ? decodeURIComponent(matchResults[4]) : void 0,
        host: matchResults[6] ? decodeURIComponent(matchResults[6]) : matchResults[6],
        port: matchResults[8] ? parseInt(matchResults[8]) : void 0,
        database: matchResults[9] ? decodeURIComponent(matchResults[9]) : matchResults[9]
      };
      const variousOptsString = matchResults[11];
      if (variousOptsString) {
        const keyValues = variousOptsString.split("&");
        keyValues.forEach(function(keyVal) {
          const equalIdx = keyVal.indexOf("=");
          if (equalIdx !== 1) {
            let val = keyVal.substring(equalIdx + 1);
            val = val ? decodeURIComponent(val) : void 0;
            options[keyVal.substring(0, equalIdx)] = val;
          }
        });
      }
      return this.parseOptionDataType(options);
    }
  }
  connectionOptions = ConnectionOptions;
  return connectionOptions;
}
var command;
var hasRequiredCommand;
function requireCommand() {
  if (hasRequiredCommand) return command;
  hasRequiredCommand = 1;
  const EventEmitter = require$$0$3;
  const Errors = requireErrors();
  class Command extends EventEmitter {
    constructor(cmdParam, resolve, reject) {
      super();
      this.cmdParam = cmdParam;
      this.sequenceNo = -1;
      this.compressSequenceNo = -1;
      this.resolve = resolve;
      this.reject = reject;
      this.sending = false;
      this.unexpectedError = this.throwUnexpectedError.bind(this);
    }
    displaySql() {
      return null;
    }
    /**
     * Throw an unexpected error.
     * server exchange will still be read to keep connection in a good state, but promise will be rejected.
     *
     * @param msg message
     * @param fatal is error fatal for connection
     * @param info current server state information
     * @param sqlState error sqlState
     * @param errno error number
     */
    throwUnexpectedError(msg, fatal, info, sqlState, errno) {
      const err = Errors.createError(
        msg,
        errno,
        info,
        sqlState,
        this.opts && this.opts.logParam ? this.displaySql() : this.sql,
        fatal,
        this.cmdParam ? this.cmdParam.stack : null,
        false
      );
      if (this.reject) {
        process.nextTick(this.reject, err);
        this.resolve = null;
        this.reject = null;
      }
      return err;
    }
    /**
     * Create and throw new Error from error information
     * only first called throwing an error or successfully end will be executed.
     *
     * @param msg message
     * @param fatal is error fatal for connection
     * @param info current server state information
     * @param sqlState error sqlState
     * @param errno error number
     */
    throwNewError(msg, fatal, info, sqlState, errno) {
      this.onPacketReceive = null;
      const err = this.throwUnexpectedError(msg, fatal, info, sqlState, errno);
      this.emit("end");
      return err;
    }
    /**
     * When command cannot be sent due to error.
     * (this is only on start command)
     *
     * @param msg error message
     * @param errno error number
     * @param info connection information
     */
    sendCancelled(msg, errno, info) {
      const err = Errors.createError(msg, errno, info, "HY000", this.opts.logParam ? this.displaySql() : this.sql);
      this.emit("send_end");
      this.throwError(err, info);
    }
    /**
     * Throw Error
     *  only first called throwing an error or successfully end will be executed.
     *
     * @param err error to be thrown
     * @param info current server state information
     */
    throwError(err, info) {
      this.onPacketReceive = null;
      if (this.reject) {
        if (this.cmdParam && this.cmdParam.stack) {
          err = Errors.createError(
            err.text ? err.text : err.message,
            err.errno,
            info,
            err.sqlState,
            err.sql,
            err.fatal,
            this.cmdParam.stack,
            false
          );
        }
        this.resolve = null;
        process.nextTick(this.reject, err);
        this.reject = null;
      }
      this.emit("end", err);
    }
    /**
     * Successfully end command.
     * only first called throwing an error or successfully end will be executed.
     *
     * @param val return value.
     */
    successEnd(val) {
      this.onPacketReceive = null;
      if (this.resolve) {
        this.reject = null;
        process.nextTick(this.resolve, val);
        this.resolve = null;
      }
      this.emit("end");
    }
  }
  command = Command;
  return command;
}
var pluginAuth;
var hasRequiredPluginAuth;
function requirePluginAuth() {
  if (hasRequiredPluginAuth) return pluginAuth;
  hasRequiredPluginAuth = 1;
  const Command = requireCommand();
  class PluginAuth extends Command {
    constructor(cmdParam, multiAuthResolver, reject) {
      super(cmdParam, multiAuthResolver, reject);
      this.onPacketReceive = multiAuthResolver;
    }
    permitHash() {
      return true;
    }
    hash(conf) {
      return null;
    }
  }
  pluginAuth = PluginAuth;
  return pluginAuth;
}
var initialHandshake;
var hasRequiredInitialHandshake;
function requireInitialHandshake() {
  if (hasRequiredInitialHandshake) return initialHandshake;
  hasRequiredInitialHandshake = 1;
  const Capabilities = requireCapabilities();
  const Collations = requireCollations();
  const ConnectionInformation = requireConnectionInformation();
  class InitialHandshake {
    constructor(packet2, info) {
      packet2.skip(1);
      info.serverVersion = {};
      info.serverVersion.raw = packet2.readStringNullEnded();
      info.threadId = packet2.readUInt32();
      let seed1 = packet2.readBuffer(8);
      packet2.skip(1);
      let serverCapabilities = BigInt(packet2.readUInt16());
      info.collation = Collations.fromIndex(packet2.readUInt8());
      info.status = packet2.readUInt16();
      serverCapabilities += BigInt(packet2.readUInt16()) << 16n;
      let saltLength = 0;
      if (serverCapabilities & Capabilities.PLUGIN_AUTH) {
        saltLength = Math.max(12, packet2.readUInt8() - 9);
      } else {
        packet2.skip(1);
      }
      if (serverCapabilities & Capabilities.MYSQL) {
        packet2.skip(10);
      } else {
        packet2.skip(6);
        serverCapabilities += BigInt(packet2.readUInt32()) << 32n;
      }
      if (serverCapabilities & Capabilities.SECURE_CONNECTION) {
        let seed2 = packet2.readBuffer(saltLength);
        info.seed = Buffer.concat([seed1, seed2]);
      } else {
        info.seed = seed1;
      }
      packet2.skip(1);
      info.serverCapabilities = serverCapabilities;
      if (info.serverVersion.raw.startsWith("5.5.5-")) {
        info.serverVersion.mariaDb = true;
        info.serverVersion.raw = info.serverVersion.raw.substring("5.5.5-".length);
      } else {
        info.serverVersion.mariaDb = info.serverVersion.raw.includes("MariaDB") || (serverCapabilities & Capabilities.MYSQL) === 0n;
      }
      if (serverCapabilities & Capabilities.PLUGIN_AUTH) {
        this.pluginName = packet2.readStringNullEnded();
      } else {
        this.pluginName = "";
      }
      ConnectionInformation.parseVersionString(info);
    }
  }
  initialHandshake = InitialHandshake;
  return initialHandshake;
}
var clientCapabilities = {};
var hasRequiredClientCapabilities;
function requireClientCapabilities() {
  if (hasRequiredClientCapabilities) return clientCapabilities;
  hasRequiredClientCapabilities = 1;
  const Capabilities = requireCapabilities();
  clientCapabilities.init = function(opts, info) {
    let capabilities2 = Capabilities.IGNORE_SPACE | Capabilities.PROTOCOL_41 | Capabilities.TRANSACTIONS | Capabilities.SECURE_CONNECTION | Capabilities.MULTI_RESULTS | Capabilities.PS_MULTI_RESULTS | Capabilities.SESSION_TRACK | Capabilities.CONNECT_ATTRS | Capabilities.PLUGIN_AUTH_LENENC_CLIENT_DATA | Capabilities.MARIADB_CLIENT_EXTENDED_TYPE_INFO | Capabilities.PLUGIN_AUTH;
    if (opts.foundRows) {
      capabilities2 |= Capabilities.FOUND_ROWS;
    }
    if (opts.permitLocalInfile) {
      capabilities2 |= Capabilities.LOCAL_FILES;
    }
    if (opts.multipleStatements) {
      capabilities2 |= Capabilities.MULTI_STATEMENTS;
    }
    info.eofDeprecated = !opts.keepEof && (info.serverCapabilities & Capabilities.DEPRECATE_EOF) > 0;
    if (info.eofDeprecated) {
      capabilities2 |= Capabilities.DEPRECATE_EOF;
    }
    if (opts.database && info.serverCapabilities & Capabilities.CONNECT_WITH_DB) {
      capabilities2 |= Capabilities.CONNECT_WITH_DB;
    }
    info.serverPermitSkipMeta = (info.serverCapabilities & Capabilities.MARIADB_CLIENT_CACHE_METADATA) > 0;
    if (info.serverPermitSkipMeta) {
      capabilities2 |= Capabilities.MARIADB_CLIENT_CACHE_METADATA;
    }
    if (opts.compress) {
      if (info.serverCapabilities & Capabilities.COMPRESS) {
        capabilities2 |= Capabilities.COMPRESS;
      } else {
        opts.compress = false;
      }
    }
    if (opts.bulk && info.serverCapabilities & Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS) {
      capabilities2 |= Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS;
    }
    if (opts.permitConnectionWhenExpired) {
      capabilities2 |= Capabilities.CAN_HANDLE_EXPIRED_PASSWORDS;
    }
    info.clientCapabilities = capabilities2 & info.serverCapabilities;
  };
  return clientCapabilities;
}
var sslRequest = {};
var hasRequiredSslRequest;
function requireSslRequest() {
  if (hasRequiredSslRequest) return sslRequest;
  hasRequiredSslRequest = 1;
  const Capabilities = requireCapabilities();
  sslRequest.send = function sendSSLRequest(cmd, out2, info, opts) {
    out2.startPacket(cmd);
    out2.writeInt32(Number(info.clientCapabilities & BigInt(4294967295)));
    out2.writeInt32(1024 * 1024 * 1024);
    out2.writeInt8(opts.collation && opts.collation.index <= 255 ? opts.collation.index : 224);
    for (let i = 0; i < 19; i++) {
      out2.writeInt8(0);
    }
    if (info.serverCapabilities & Capabilities.MYSQL) {
      out2.writeInt32(0);
    } else {
      out2.writeInt32(Number(info.clientCapabilities >> 32n));
    }
    out2.flushPacket();
  };
  return sslRequest;
}
var nativePasswordAuth;
var hasRequiredNativePasswordAuth;
function requireNativePasswordAuth() {
  if (hasRequiredNativePasswordAuth) return nativePasswordAuth;
  hasRequiredNativePasswordAuth = 1;
  const PluginAuth = requirePluginAuth();
  const Crypto = require$$1$3;
  class NativePasswordAuth extends PluginAuth {
    constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
      super(cmdParam, multiAuthResolver, reject);
      this.pluginData = pluginData;
      this.sequenceNo = packSeq;
      this.compressSequenceNo = compressPackSeq;
    }
    start(out2, opts, info) {
      const data = this.pluginData.slice(0, 20);
      let authToken = NativePasswordAuth.encryptSha1Password(opts.password, data);
      out2.startPacket(this);
      if (authToken.length > 0) {
        out2.writeBuffer(authToken, 0, authToken.length);
        out2.flushPacket();
      } else {
        out2.writeEmptyPacket(true);
      }
      this.emit("send_end");
    }
    static encryptSha1Password(password, seed2) {
      if (!password) return Buffer.alloc(0);
      let hash = Crypto.createHash("sha1");
      let stage1 = hash.update(password, "utf8").digest();
      hash = Crypto.createHash("sha1");
      let stage2 = hash.update(stage1).digest();
      hash = Crypto.createHash("sha1");
      hash.update(seed2);
      hash.update(stage2);
      let digest = hash.digest();
      let returnBytes = Buffer.allocUnsafe(digest.length);
      for (let i = 0; i < digest.length; i++) {
        returnBytes[i] = stage1[i] ^ digest[i];
      }
      return returnBytes;
    }
    permitHash() {
      return true;
    }
    hash(conf) {
      let hash = Crypto.createHash("sha1");
      let stage1 = hash.update(conf.password, "utf8").digest();
      hash = Crypto.createHash("sha1");
      return hash.update(stage1).digest();
    }
  }
  nativePasswordAuth = NativePasswordAuth;
  return nativePasswordAuth;
}
var handshake;
var hasRequiredHandshake;
function requireHandshake() {
  if (hasRequiredHandshake) return handshake;
  hasRequiredHandshake = 1;
  const PluginAuth = requirePluginAuth();
  const InitialHandshake = requireInitialHandshake();
  const ClientCapabilities = requireClientCapabilities();
  const Capabilities = requireCapabilities();
  const SslRequest = requireSslRequest();
  const Errors = requireErrors();
  const NativePasswordAuth = requireNativePasswordAuth();
  const os = require$$2$1;
  const Iconv = requireLib$1();
  const Crypto = require$$1$3;
  const driverVersion = require$$8.version;
  class Handshake extends PluginAuth {
    constructor(auth, getSocket, multiAuthResolver, reject) {
      super(null, multiAuthResolver, reject);
      this.sequenceNo = 0;
      this.compressSequenceNo = 0;
      this.auth = auth;
      this.getSocket = getSocket;
      this.counter = 0;
      this.onPacketReceive = this.parseHandshakeInit;
    }
    start(out2, opts, info) {
    }
    parseHandshakeInit(packet2, out2, opts, info) {
      if (packet2.peek() === 255) {
        const authErr = packet2.readError(info);
        authErr.fatal = true;
        return this.throwError(authErr, info);
      }
      let handshake2 = new InitialHandshake(packet2, info);
      ClientCapabilities.init(opts, info);
      this.pluginName = handshake2.pluginName;
      if (opts.ssl) {
        if (info.serverCapabilities & Capabilities.SSL) {
          info.clientCapabilities |= Capabilities.SSL;
          SslRequest.send(this, out2, info, opts);
          this.auth._createSecureContext(info, () => {
            const secureSocket = this.getSocket();
            info.selfSignedCertificate = !secureSocket.authorized;
            info.tlsAuthorizationError = secureSocket.authorizationError;
            const serverCert = secureSocket.getPeerCertificate(false);
            info.tlsCert = serverCert;
            info.tlsFingerprint = serverCert ? serverCert.fingerprint256.replace(/:/gi, "").toLowerCase() : null;
            Handshake.send.call(this, this, out2, opts, handshake2.pluginName, info);
          });
        } else {
          return this.throwNewError(
            "Trying to connect with ssl, but ssl not enabled in the server",
            true,
            info,
            "08S01",
            Errors.ER_SERVER_SSL_DISABLED
          );
        }
      } else {
        Handshake.send(this, out2, opts, handshake2.pluginName, info);
      }
      this.onPacketReceive = this.auth.handshakeResult.bind(this.auth);
    }
    permitHash() {
      return this.pluginName !== "mysql_clear_password";
    }
    hash(conf) {
      let hash = Crypto.createHash("sha1");
      let stage1 = hash.update(conf.password, "utf8").digest();
      hash = Crypto.createHash("sha1");
      return hash.update(stage1).digest();
    }
    /**
     * Send Handshake response packet
     * see https://mariadb.com/kb/en/library/1-connecting-connecting/#handshake-response-packet
     *
     * @param cmd         current handshake command
     * @param out         output writer
     * @param opts        connection options
     * @param pluginName  plugin name
     * @param info        connection information
     */
    static send(cmd, out2, opts, pluginName, info) {
      out2.startPacket(cmd);
      info.defaultPluginName = pluginName;
      const pwd = Array.isArray(opts.password) ? opts.password[0] : opts.password;
      let authToken;
      let authPlugin;
      switch (pluginName) {
        case "mysql_clear_password":
          authToken = Buffer.from(pwd);
          authPlugin = "mysql_clear_password";
          break;
        default:
          authToken = NativePasswordAuth.encryptSha1Password(pwd, info.seed);
          authPlugin = "mysql_native_password";
          break;
      }
      out2.writeInt32(Number(info.clientCapabilities & BigInt(4294967295)));
      out2.writeInt32(1024 * 1024 * 1024);
      out2.writeInt8(opts.collation && opts.collation.index <= 255 ? opts.collation.index : 224);
      for (let i = 0; i < 19; i++) {
        out2.writeInt8(0);
      }
      out2.writeInt32(Number(info.clientCapabilities >> 32n));
      out2.writeString(opts.user || "");
      out2.writeInt8(0);
      if (info.serverCapabilities & Capabilities.PLUGIN_AUTH_LENENC_CLIENT_DATA) {
        out2.writeLengthCoded(authToken.length);
        out2.writeBuffer(authToken, 0, authToken.length);
      } else if (info.serverCapabilities & Capabilities.SECURE_CONNECTION) {
        out2.writeInt8(authToken.length);
        out2.writeBuffer(authToken, 0, authToken.length);
      } else {
        out2.writeBuffer(authToken, 0, authToken.length);
        out2.writeInt8(0);
      }
      if (info.clientCapabilities & Capabilities.CONNECT_WITH_DB) {
        out2.writeString(opts.database);
        out2.writeInt8(0);
        info.database = opts.database;
      }
      if (info.clientCapabilities & Capabilities.PLUGIN_AUTH) {
        out2.writeString(authPlugin);
        out2.writeInt8(0);
      }
      if (info.clientCapabilities & Capabilities.CONNECT_ATTRS) {
        out2.writeInt8(252);
        let initPos = out2.pos;
        out2.writeInt16(0);
        const encoding = info.collation ? info.collation.charset : "utf8";
        Handshake.writeAttribute(out2, "_client_name", encoding);
        Handshake.writeAttribute(out2, "MariaDB connector/Node", encoding);
        Handshake.writeAttribute(out2, "_client_version", encoding);
        Handshake.writeAttribute(out2, driverVersion, encoding);
        const address = cmd.getSocket().address().address;
        if (address) {
          Handshake.writeAttribute(out2, "_server_host", encoding);
          Handshake.writeAttribute(out2, address, encoding);
        }
        Handshake.writeAttribute(out2, "_os", encoding);
        Handshake.writeAttribute(out2, process.platform, encoding);
        Handshake.writeAttribute(out2, "_client_host", encoding);
        Handshake.writeAttribute(out2, os.hostname(), encoding);
        Handshake.writeAttribute(out2, "_node_version", encoding);
        Handshake.writeAttribute(out2, process.versions.node, encoding);
        if (opts.connectAttributes !== true) {
          let attrNames = Object.keys(opts.connectAttributes);
          for (let k = 0; k < attrNames.length; ++k) {
            Handshake.writeAttribute(out2, attrNames[k], encoding);
            Handshake.writeAttribute(out2, opts.connectAttributes[attrNames[k]], encoding);
          }
        }
        out2.writeInt16AtPos(initPos);
      }
      out2.flushPacket();
    }
    static writeAttribute(out2, val, encoding) {
      let param = Buffer.isEncoding(encoding) ? Buffer.from(val, encoding) : Iconv.encode(val, encoding);
      out2.writeLengthCoded(param.length);
      out2.writeBuffer(param, 0, param.length);
    }
  }
  handshake = Handshake;
  return handshake;
}
var stateChange = {};
var hasRequiredStateChange;
function requireStateChange() {
  if (hasRequiredStateChange) return stateChange;
  hasRequiredStateChange = 1;
  stateChange.SESSION_TRACK_SYSTEM_VARIABLES = 0;
  stateChange.SESSION_TRACK_SCHEMA = 1;
  stateChange.SESSION_TRACK_STATE_CHANGE = 2;
  stateChange.SESSION_TRACK_GTIDS = 3;
  stateChange.SESSION_TRACK_TRANSACTION_CHARACTERISTICS = 4;
  stateChange.SESSION_TRACK_TRANSACTION_STATE = 5;
  return stateChange;
}
var clearPasswordAuth;
var hasRequiredClearPasswordAuth;
function requireClearPasswordAuth() {
  if (hasRequiredClearPasswordAuth) return clearPasswordAuth;
  hasRequiredClearPasswordAuth = 1;
  const PluginAuth = requirePluginAuth();
  class ClearPasswordAuth extends PluginAuth {
    constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
      super(cmdParam, multiAuthResolver, reject);
      this.sequenceNo = packSeq;
      this.compressSequenceNo = compressPackSeq;
      this.counter = 0;
      this.multiAuthResolver = multiAuthResolver;
    }
    start(out2, opts, info) {
      out2.startPacket(this);
      const pwd = opts.password;
      if (pwd) {
        if (Array.isArray(pwd)) {
          out2.writeString(pwd[this.counter++]);
        } else {
          out2.writeString(pwd);
        }
      }
      out2.writeInt8(0);
      out2.flushPacket();
      this.onPacketReceive = this.response;
    }
    response(packet2, out2, opts, info) {
      const marker = packet2.peek();
      switch (marker) {
        //*********************************************************************************************************
        //* OK_Packet and Err_Packet ending packet
        //*********************************************************************************************************
        case 0:
        case 255:
          this.emit("send_end");
          return this.multiAuthResolver(packet2, out2, opts, info);
        default:
          packet2.readBuffer();
          out2.startPacket(this);
          out2.writeString("password");
          out2.writeInt8(0);
          out2.flushPacket();
      }
    }
  }
  clearPasswordAuth = ClearPasswordAuth;
  return clearPasswordAuth;
}
var ed25519PasswordAuth;
var hasRequiredEd25519PasswordAuth;
function requireEd25519PasswordAuth() {
  if (hasRequiredEd25519PasswordAuth) return ed25519PasswordAuth;
  hasRequiredEd25519PasswordAuth = 1;
  const PluginAuth = requirePluginAuth();
  const Crypto = require$$1$3;
  class Ed25519PasswordAuth extends PluginAuth {
    constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
      super(cmdParam, multiAuthResolver, reject);
      this.pluginData = pluginData;
      this.sequenceNo = packSeq;
      this.compressSequenceNo = compressPackSeq;
    }
    start(out2, opts, info) {
      const data = this.pluginData;
      const sign = Ed25519PasswordAuth.encryptPassword(opts.password, data);
      out2.startPacket(this);
      out2.writeBuffer(sign, 0, sign.length);
      out2.flushPacket();
      this.emit("send_end");
    }
    static encryptPassword(password, seed2) {
      if (!password) return Buffer.alloc(0);
      let i, j;
      let p = [gf(), gf(), gf(), gf()];
      const signedMsg = Buffer.alloc(96);
      const bytePwd = Buffer.from(password);
      let hash = Crypto.createHash("sha512");
      const d = hash.update(bytePwd).digest();
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      for (i = 0; i < 32; i++) signedMsg[64 + i] = seed2[i];
      for (i = 0; i < 32; i++) signedMsg[32 + i] = d[32 + i];
      hash = Crypto.createHash("sha512");
      const r = hash.update(signedMsg.subarray(32, 96)).digest();
      reduce(r);
      scalarbase(p, r);
      pack(signedMsg, p);
      p = [gf(), gf(), gf(), gf()];
      scalarbase(p, d);
      const tt = Buffer.alloc(32);
      pack(tt, p);
      for (i = 32; i < 64; i++) signedMsg[i] = tt[i - 32];
      hash = Crypto.createHash("sha512");
      const h = hash.update(signedMsg).digest();
      reduce(h);
      const x = new Float64Array(64);
      for (i = 0; i < 64; i++) x[i] = 0;
      for (i = 0; i < 32; i++) x[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(signedMsg.subarray(32), x);
      return signedMsg.subarray(0, 64);
    }
    permitHash() {
      return true;
    }
    hash(conf) {
      let i;
      let p = [gf(), gf(), gf(), gf()];
      const signedMsg = Buffer.alloc(96);
      const bytePwd = Buffer.from(conf.password);
      let hash = Crypto.createHash("sha512");
      const d = hash.update(bytePwd).digest();
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      for (i = 0; i < 32; i++) signedMsg[64 + i] = seed[i];
      for (i = 0; i < 32; i++) signedMsg[32 + i] = d[32 + i];
      hash = Crypto.createHash("sha512");
      const r = hash.update(signedMsg.subarray(32, 96)).digest();
      reduce(r);
      scalarbase(p, r);
      return r;
    }
  }
  const gf = function(init) {
    const r = new Float64Array(16);
    if (init) for (let i = 0; i < init.length; i++) r[i] = init[i];
    return r;
  };
  const gf0 = gf(), gf1 = gf([1]), D2 = gf([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), X = gf([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), Y = gf([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]);
  const L = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function reduce(r) {
    const x = new Float64Array(64);
    let i;
    for (i = 0; i < 64; i++) x[i] = r[i];
    for (i = 0; i < 64; i++) r[i] = 0;
    modL(r, x);
  }
  function modL(r, x) {
    let carry, i, j, k;
    for (i = 63; i >= 32; --i) {
      carry = 0;
      for (j = i - 32, k = i - 12; j < k; ++j) {
        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
        carry = x[j] + 128 >> 8;
        x[j] -= carry * 256;
      }
      x[j] += carry;
      x[i] = 0;
    }
    carry = 0;
    for (j = 0; j < 32; j++) {
      x[j] += carry - (x[31] >> 4) * L[j];
      carry = x[j] >> 8;
      x[j] &= 255;
    }
    for (j = 0; j < 32; j++) x[j] -= carry * L[j];
    for (i = 0; i < 32; i++) {
      x[i + 1] += x[i] >> 8;
      r[i] = x[i] & 255;
    }
  }
  function scalarbase(p, s) {
    const q = [gf(), gf(), gf(), gf()];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    M(q[3], X, Y);
    scalarmult(p, q, s);
  }
  function set25519(r, a) {
    for (let i = 0; i < 16; i++) r[i] = a[i] | 0;
  }
  function M(o, a, b) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0;
    const b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
  }
  function scalarmult(p, q, s) {
    let b, i;
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for (i = 255; i >= 0; --i) {
      b = s[i / 8 | 0] >> (i & 7) & 1;
      cswap(p, q, b);
      add(q, p);
      add(p, p);
      cswap(p, q, b);
    }
  }
  function pack(r, p) {
    const tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
  }
  function inv25519(o, i) {
    const c = gf();
    let a;
    for (a = 0; a < 16; a++) c[a] = i[a];
    for (a = 253; a >= 0; a--) {
      S(c, c);
      if (a !== 2 && a !== 4) M(c, c, i);
    }
    for (a = 0; a < 16; a++) o[a] = c[a];
  }
  function S(o, a) {
    M(o, a, a);
  }
  function par25519(a) {
    const d = new Uint8Array(32);
    pack25519(d, a);
    return d[0] & 1;
  }
  function car25519(o) {
    let i, v, c = 1;
    for (i = 0; i < 16; i++) {
      v = o[i] + c + 65535;
      c = Math.floor(v / 65536);
      o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
  }
  function pack25519(o, n) {
    let i, j, b;
    const m = gf(), t = gf();
    for (i = 0; i < 16; i++) t[i] = n[i];
    car25519(t);
    car25519(t);
    car25519(t);
    for (j = 0; j < 2; j++) {
      m[0] = t[0] - 65517;
      for (i = 1; i < 15; i++) {
        m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
        m[i - 1] &= 65535;
      }
      m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
      b = m[15] >> 16 & 1;
      m[14] &= 65535;
      sel25519(t, m, 1 - b);
    }
    for (i = 0; i < 16; i++) {
      o[2 * i] = t[i] & 255;
      o[2 * i + 1] = t[i] >> 8;
    }
  }
  function cswap(p, q, b) {
    for (let i = 0; i < 4; i++) {
      sel25519(p[i], q[i], b);
    }
  }
  function A(o, a, b) {
    for (let i = 0; i < 16; i++) o[i] = a[i] + b[i];
  }
  function Z(o, a, b) {
    for (let i = 0; i < 16; i++) o[i] = a[i] - b[i];
  }
  function add(p, q) {
    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);
    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
  }
  function sel25519(p, q, b) {
    const c = ~(b - 1);
    let t;
    for (let i = 0; i < 16; i++) {
      t = c & (p[i] ^ q[i]);
      p[i] ^= t;
      q[i] ^= t;
    }
  }
  ed25519PasswordAuth = Ed25519PasswordAuth;
  return ed25519PasswordAuth;
}
var parsecAuth;
var hasRequiredParsecAuth;
function requireParsecAuth() {
  if (hasRequiredParsecAuth) return parsecAuth;
  hasRequiredParsecAuth = 1;
  const PluginAuth = requirePluginAuth();
  const crypto = require$$1$3;
  const Errors = requireErrors();
  class ParsecAuth extends PluginAuth {
    constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
      super(cmdParam, multiAuthResolver, reject);
      this.multiAuthResolver = multiAuthResolver;
      this.pluginData = pluginData;
      this.sequenceNo = packSeq;
      this.compressSequenceNo = compressPackSeq;
    }
    start(out2, opts, info) {
      if (!info.extSalt) {
        out2.startPacket(this);
        out2.writeEmptyPacket(true);
        this.onPacketReceive = this.requestForSalt;
      } else {
        this.parseExtSalt(Buffer.from(info.extSalt, "hex"), info);
        this.sendScramble(out2, opts, info);
      }
    }
    requestForSalt(packet2, out2, opts, info) {
      this.parseExtSalt(packet2.readBufferRemaining(), info);
      this.sendScramble(out2, opts, info);
    }
    parseExtSalt(extSalt, info) {
      if (extSalt.length < 2 || extSalt[0] !== 80 || extSalt[1] > 3) {
        return this.throwError(
          Errors.createFatalError("Wrong parsec authentication format", Errors.ER_AUTHENTICATION_BAD_PACKET, info),
          info
        );
      }
      this.iterations = extSalt[1];
      this.salt = extSalt.slice(2);
    }
    sendScramble(out2, opts, info) {
      const derivedKey = crypto.pbkdf2Sync(opts.password || "", this.salt, 1024 << this.iterations, 32, "sha512");
      const privateKey = toPkcs8der(derivedKey);
      const client_scramble = crypto.randomBytes(32);
      const message = Buffer.concat([this.pluginData, client_scramble]);
      const signature = crypto.sign(null, message, privateKey);
      out2.startPacket(this);
      out2.writeBuffer(client_scramble, 0, 32);
      out2.writeBuffer(signature, 0, 64);
      out2.flushPacket();
      this.emit("send_end");
      this.onPacketReceive = this.multiAuthResolver;
    }
  }
  const toPkcs8der = (rawB64) => {
    const prefixPrivateEd25519 = Buffer.from("302e020100300506032b657004220420", "hex");
    const der = Buffer.concat([prefixPrivateEd25519, rawB64]);
    return crypto.createPrivateKey({ key: der, format: "der", type: "pkcs8" });
  };
  parsecAuth = ParsecAuth;
  return parsecAuth;
}
var pamPasswordAuth;
var hasRequiredPamPasswordAuth;
function requirePamPasswordAuth() {
  if (hasRequiredPamPasswordAuth) return pamPasswordAuth;
  hasRequiredPamPasswordAuth = 1;
  const PluginAuth = requirePluginAuth();
  class PamPasswordAuth extends PluginAuth {
    constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
      super(cmdParam, multiAuthResolver, reject);
      this.pluginData = pluginData;
      this.sequenceNo = packSeq;
      this.compressSequenceNo = compressPackSeq;
      this.counter = 0;
      this.multiAuthResolver = multiAuthResolver;
    }
    start(out2, opts, info) {
      this.exchange(this.pluginData, out2, opts, info);
      this.onPacketReceive = this.response;
    }
    exchange(buffer, out2, opts, info) {
      out2.startPacket(this);
      let pwd;
      if (Array.isArray(opts.password)) {
        pwd = opts.password[this.counter];
        this.counter++;
      } else {
        pwd = opts.password;
      }
      if (pwd) out2.writeString(pwd);
      out2.writeInt8(0);
      out2.flushPacket();
    }
    response(packet2, out2, opts, info) {
      const marker = packet2.peek();
      switch (marker) {
        //*********************************************************************************************************
        //* OK_Packet and Err_Packet ending packet
        //*********************************************************************************************************
        case 0:
        case 255:
          this.emit("send_end");
          return this.multiAuthResolver(packet2, out2, opts, info);
        default:
          let promptData = packet2.readBuffer();
          this.exchange(promptData, out2, opts, info);
          this.onPacketReceive = this.response;
      }
    }
  }
  pamPasswordAuth = PamPasswordAuth;
  return pamPasswordAuth;
}
var sha256PasswordAuth;
var hasRequiredSha256PasswordAuth;
function requireSha256PasswordAuth() {
  if (hasRequiredSha256PasswordAuth) return sha256PasswordAuth;
  hasRequiredSha256PasswordAuth = 1;
  const PluginAuth = requirePluginAuth();
  const fs2 = require$$1$2;
  const crypto = require$$1$3;
  const Errors = requireErrors();
  const Crypto = require$$1$3;
  class Sha256PasswordAuth extends PluginAuth {
    constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
      super(cmdParam, multiAuthResolver, reject);
      this.pluginData = pluginData;
      this.sequenceNo = packSeq;
      this.compressSequenceNo = compressPackSeq;
      this.counter = 0;
      this.counter = 0;
      this.initialState = true;
      this.multiAuthResolver = multiAuthResolver;
    }
    start(out2, opts, info) {
      this.exchange(this.pluginData, out2, opts, info);
      this.onPacketReceive = this.response;
    }
    exchange(buffer, out2, opts, info) {
      if (this.initialState) {
        if (!opts.password) {
          out2.startPacket(this);
          out2.writeEmptyPacket(true);
          return;
        } else if (opts.ssl) {
          out2.startPacket(this);
          if (opts.password) {
            out2.writeString(opts.password);
          }
          out2.writeInt8(0);
          out2.flushPacket();
          return;
        } else {
          if (opts.rsaPublicKey) {
            try {
              let key = opts.rsaPublicKey;
              if (!key.includes("-----BEGIN")) {
                key = fs2.readFileSync(key, "utf8");
              }
              this.publicKey = Sha256PasswordAuth.retrievePublicKey(key);
            } catch (err) {
              return this.throwError(err, info);
            }
          } else {
            if (!opts.allowPublicKeyRetrieval) {
              return this.throwError(
                Errors.createFatalError(
                  "RSA public key is not available client side. Either set option `rsaPublicKey` to indicate public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`",
                  Errors.ER_CANNOT_RETRIEVE_RSA_KEY,
                  info
                ),
                info
              );
            }
            this.initialState = false;
            out2.startPacket(this);
            out2.writeInt8(1);
            out2.flushPacket();
            return;
          }
        }
        Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out2);
      } else {
        this.publicKey = Sha256PasswordAuth.retrievePublicKey(buffer.toString("utf8", 1));
        Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out2);
      }
    }
    static retrievePublicKey(key) {
      return key.replace("(-+BEGIN PUBLIC KEY-+\\r?\\n|\\n?-+END PUBLIC KEY-+\\r?\\n?)", "");
    }
    static sendSha256PwdPacket(cmd, pluginData, publicKey, password, out2) {
      const truncatedSeed = pluginData.slice(0, pluginData.length - 1);
      out2.startPacket(cmd);
      const enc = Sha256PasswordAuth.encrypt(truncatedSeed, password, publicKey);
      out2.writeBuffer(enc, 0, enc.length);
      out2.flushPacket();
    }
    static encryptSha256Password(password, seed2) {
      if (!password) return Buffer.alloc(0);
      let hash = Crypto.createHash("sha256");
      let stage1 = hash.update(password, "utf8").digest();
      hash = Crypto.createHash("sha256");
      let stage2 = hash.update(stage1).digest();
      hash = Crypto.createHash("sha256");
      hash.update(stage2);
      hash.update(seed2);
      let digest = hash.digest();
      let returnBytes = Buffer.allocUnsafe(digest.length);
      for (let i = 0; i < digest.length; i++) {
        returnBytes[i] = stage1[i] ^ digest[i];
      }
      return returnBytes;
    }
    // encrypt password with public key
    static encrypt(seed2, password, publicKey) {
      const nullFinishedPwd = Buffer.from(password + "\0");
      const xorBytes = Buffer.allocUnsafe(nullFinishedPwd.length);
      const seedLength = seed2.length;
      for (let i = 0; i < xorBytes.length; i++) {
        xorBytes[i] = nullFinishedPwd[i] ^ seed2[i % seedLength];
      }
      return crypto.publicEncrypt({ key: publicKey, padding: crypto.constants.RSA_PKCS1_OAEP_PADDING }, xorBytes);
    }
    response(packet2, out2, opts, info) {
      const marker = packet2.peek();
      switch (marker) {
        //*********************************************************************************************************
        //* OK_Packet and Err_Packet ending packet
        //*********************************************************************************************************
        case 0:
        case 255:
          this.emit("send_end");
          return this.multiAuthResolver(packet2, out2, opts, info);
        default:
          let promptData = packet2.readBufferRemaining();
          this.exchange(promptData, out2, opts, info);
          this.onPacketReceive = this.response;
      }
    }
  }
  sha256PasswordAuth = Sha256PasswordAuth;
  return sha256PasswordAuth;
}
var cachingSha2PasswordAuth;
var hasRequiredCachingSha2PasswordAuth;
function requireCachingSha2PasswordAuth() {
  if (hasRequiredCachingSha2PasswordAuth) return cachingSha2PasswordAuth;
  hasRequiredCachingSha2PasswordAuth = 1;
  const PluginAuth = requirePluginAuth();
  const fs2 = require$$1$2;
  const Errors = requireErrors();
  const Sha256PasswordAuth = requireSha256PasswordAuth();
  const State = {
    INIT: "INIT",
    FAST_AUTH_RESULT: "FAST_AUTH_RESULT",
    REQUEST_SERVER_KEY: "REQUEST_SERVER_KEY",
    SEND_AUTH: "SEND_AUTH"
  };
  class CachingSha2PasswordAuth extends PluginAuth {
    constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
      super(cmdParam, multiAuthResolver, reject);
      this.multiAuthResolver = multiAuthResolver;
      this.pluginData = pluginData;
      this.sequenceNo = packSeq;
      this.compressSequenceNo = compressPackSeq;
      this.counter = 0;
      this.state = State.INIT;
    }
    start(out2, opts, info) {
      this.exchange(this.pluginData, out2, opts, info);
      this.onPacketReceive = this.response;
    }
    exchange(packet2, out2, opts, info) {
      switch (this.state) {
        case State.INIT:
          const truncatedSeed = this.pluginData.slice(0, this.pluginData.length - 1);
          const encPwd = Sha256PasswordAuth.encryptSha256Password(opts.password, truncatedSeed);
          out2.startPacket(this);
          if (encPwd.length > 0) {
            out2.writeBuffer(encPwd, 0, encPwd.length);
            out2.flushPacket();
          } else {
            out2.writeEmptyPacket(true);
          }
          this.state = State.FAST_AUTH_RESULT;
          return;
        case State.FAST_AUTH_RESULT:
          const fastAuthResult = packet2[1];
          switch (fastAuthResult) {
            case 3:
              return;
            case 4:
              if (opts.ssl) {
                out2.startPacket(this);
                out2.writeString(opts.password);
                out2.writeInt8(0);
                out2.flushPacket();
                return;
              }
              if (opts.cachingRsaPublicKey) {
                try {
                  let key = opts.cachingRsaPublicKey;
                  if (!key.includes("-----BEGIN")) {
                    key = fs2.readFileSync(key, "utf8");
                  }
                  this.publicKey = Sha256PasswordAuth.retrievePublicKey(key);
                } catch (err) {
                  return this.throwError(err, info);
                }
                Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out2);
              } else {
                if (!opts.allowPublicKeyRetrieval) {
                  return this.throwError(
                    Errors.createFatalError(
                      "RSA public key is not available client side. Either set option `cachingRsaPublicKey` to indicate public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`",
                      Errors.ER_CANNOT_RETRIEVE_RSA_KEY,
                      info
                    ),
                    info
                  );
                }
                this.state = State.REQUEST_SERVER_KEY;
                out2.startPacket(this);
                out2.writeInt8(2);
                out2.flushPacket();
              }
          }
          return;
        case State.REQUEST_SERVER_KEY:
          this.publicKey = Sha256PasswordAuth.retrievePublicKey(packet2.toString(void 0, 1));
          this.state = State.SEND_AUTH;
          Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out2);
          return;
      }
    }
    response(packet2, out2, opts, info) {
      const marker = packet2.peek();
      switch (marker) {
        //*********************************************************************************************************
        //* OK_Packet and Err_Packet ending packet
        //*********************************************************************************************************
        case 0:
        case 255:
          this.emit("send_end");
          return this.multiAuthResolver(packet2, out2, opts, info);
        default:
          let promptData = packet2.readBufferRemaining();
          this.exchange(promptData, out2, opts, info);
          this.onPacketReceive = this.response;
      }
    }
  }
  cachingSha2PasswordAuth = CachingSha2PasswordAuth;
  return cachingSha2PasswordAuth;
}
var authentication;
var hasRequiredAuthentication;
function requireAuthentication() {
  if (hasRequiredAuthentication) return authentication;
  hasRequiredAuthentication = 1;
  const Command = requireCommand();
  const Errors = requireErrors();
  const Capabilities = requireCapabilities();
  const Handshake = requireHandshake();
  const ServerStatus = requireServerStatus();
  const StateChange = requireStateChange();
  const Collations = requireCollations();
  const Crypto = require$$1$3;
  const utils2 = requireUtils$2();
  const tls = require$$9;
  const authenticationPlugins = {
    mysql_native_password: requireNativePasswordAuth(),
    mysql_clear_password: requireClearPasswordAuth(),
    client_ed25519: requireEd25519PasswordAuth(),
    parsec: requireParsecAuth(),
    dialog: requirePamPasswordAuth(),
    sha256_password: requireSha256PasswordAuth(),
    caching_sha2_password: requireCachingSha2PasswordAuth()
  };
  class Authentication extends Command {
    constructor(cmdParam, resolve, reject, _createSecureContext, getSocket) {
      super(cmdParam, resolve, reject);
      this.cmdParam = cmdParam;
      this._createSecureContext = _createSecureContext;
      this.getSocket = getSocket;
      this.plugin = new Handshake(this, getSocket, this.handshakeResult, reject);
    }
    onPacketReceive(packet2, out2, opts, info) {
      this.plugin.sequenceNo = this.sequenceNo;
      this.plugin.compressSequenceNo = this.compressSequenceNo;
      this.plugin.onPacketReceive(packet2, out2, opts, info);
    }
    /**
     * Fast-path handshake results :
     *  - if plugin was the one expected by server, server will send OK_Packet / ERR_Packet.
     *  - if not, server send an AuthSwitchRequest packet, indicating the specific PLUGIN to use with this user.
     *    dispatching to plugin handler then.
     *
     * @param packet    current packet
     * @param out       output buffer
     * @param opts      options
     * @param info      connection info
     * @returns {*}     return null if authentication succeed, depending on plugin conversation if not finished
     */
    handshakeResult(packet2, out2, opts, info) {
      const marker = packet2.peek();
      switch (marker) {
        //*********************************************************************************************************
        //* AuthSwitchRequest packet
        //*********************************************************************************************************
        case 254:
          this.dispatchAuthSwitchRequest(packet2, out2, opts, info);
          return;
        //*********************************************************************************************************
        //* OK_Packet - authentication succeeded
        //*********************************************************************************************************
        case 0:
          this.plugin.onPacketReceive = null;
          packet2.skip(1);
          packet2.skipLengthCodedNumber();
          packet2.skipLengthCodedNumber();
          info.status = packet2.readUInt16();
          if (info.requireValidCert) {
            if (info.selfSignedCertificate) {
              packet2.skip(2);
              if (packet2.remaining()) {
                const validationHash = packet2.readBufferLengthEncoded();
                if (validationHash.length > 0) {
                  if (!this.plugin.permitHash() || !this.cmdParam.opts.password || this.cmdParam.opts.password === "") {
                    return this.throwNewError(
                      "Self signed certificates. Either set `ssl: { rejectUnauthorized: false }` (trust mode) or provide server certificate to client",
                      true,
                      info,
                      "08000",
                      Errors.ER_SELF_SIGNED_NO_PWD
                    );
                  }
                  if (this.validateFingerPrint(validationHash, info)) {
                    return this.successEnd();
                  }
                }
              }
              return this.throwNewError("self-signed certificate", true, info, "08000", Errors.ER_SELF_SIGNED);
            } else if (info.requireIdentifyCheck) {
              const identityError = tls.checkServerIdentity(opts.host, info.tlsCert);
              if (identityError) {
                return this.throwNewError(
                  "certificate identify Error: " + identityError.message,
                  true,
                  info,
                  "08000",
                  Errors.ER_TLS_IDENTITY_ERROR
                );
              }
            }
          }
          let mustRedirect = false;
          if (info.status & ServerStatus.SESSION_STATE_CHANGED) {
            packet2.skip(2);
            packet2.skipLengthCodedNumber();
            while (packet2.remaining()) {
              const len = packet2.readUnsignedLength();
              if (len > 0) {
                const subPacket = packet2.subPacketLengthEncoded(len);
                while (subPacket.remaining()) {
                  const type2 = subPacket.readUInt8();
                  switch (type2) {
                    case StateChange.SESSION_TRACK_SYSTEM_VARIABLES:
                      let subSubPacket;
                      do {
                        subSubPacket = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                        const variable = subSubPacket.readStringLengthEncoded();
                        const value = subSubPacket.readStringLengthEncoded();
                        switch (variable) {
                          case "character_set_client":
                            info.collation = Collations.fromCharset(value);
                            if (info.collation === void 0) {
                              this.throwError(new Error("unknown charset : '" + value + "'"), info);
                              return;
                            }
                            opts.emit("collation", info.collation);
                            break;
                          case "redirect_url":
                            if (value !== "") {
                              mustRedirect = true;
                              info.redirect(value, this.successEnd);
                            }
                            break;
                          case "maxscale":
                            info.maxscaleVersion = value;
                            break;
                          case "connection_id":
                            info.threadId = parseInt(value);
                            break;
                        }
                      } while (subSubPacket.remaining() > 0);
                      break;
                    case StateChange.SESSION_TRACK_SCHEMA:
                      const subSubPacket2 = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                      info.database = subSubPacket2.readStringLengthEncoded();
                      break;
                  }
                }
              }
            }
          }
          if (!mustRedirect) this.successEnd();
          return;
        //*********************************************************************************************************
        //* ERR_Packet
        //*********************************************************************************************************
        case 255:
          this.plugin.onPacketReceive = null;
          const authErr = packet2.readError(info, this.displaySql(), void 0);
          authErr.fatal = true;
          if (info.requireValidCert && info.selfSignedCertificate) {
            return this.plugin.throwNewError(
              "Self signed certificates. Either set `ssl: { rejectUnauthorized: false }` (trust mode) or provide server certificate to client",
              true,
              info,
              "08000",
              Errors.ER_SELF_SIGNED_NO_PWD
            );
          }
          return this.plugin.throwError(authErr, info);
        //*********************************************************************************************************
        //* unexpected
        //*********************************************************************************************************
        default:
          this.throwNewError(
            `Unexpected type of packet during handshake phase : ${marker}`,
            true,
            info,
            "42000",
            Errors.ER_AUTHENTICATION_BAD_PACKET
          );
      }
    }
    validateFingerPrint(validationHash, info) {
      if (validationHash.length === 0 || !info.tlsFingerprint) return false;
      if (validationHash[0] !== 1) {
        const err = Errors.createFatalError(
          `Unexpected hash format for fingerprint hash encoding`,
          Errors.ER_UNEXPECTED_PACKET,
          this.info
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        return false;
      }
      const pwdHash = this.plugin.hash(this.cmdParam.opts);
      let hash = Crypto.createHash("sha256");
      let digest = hash.update(pwdHash).update(info.seed).update(Buffer.from(info.tlsFingerprint, "hex")).digest();
      const hashHex = utils2.toHexString(digest);
      const serverValidationHex = validationHash.toString("ascii", 1, validationHash.length).toLowerCase();
      return hashHex === serverValidationHex;
    }
    /**
     * Handle authentication switch request : dispatch to plugin handler.
     *
     * @param packet  packet
     * @param out     output writer
     * @param opts    options
     * @param info    connection information
     */
    dispatchAuthSwitchRequest(packet2, out2, opts, info) {
      let pluginName, pluginData;
      if (info.clientCapabilities & Capabilities.PLUGIN_AUTH) {
        packet2.skip(1);
        if (packet2.remaining()) {
          pluginName = packet2.readStringNullEnded();
          pluginData = packet2.readBufferRemaining();
        } else {
          pluginName = "mysql_old_password";
          pluginData = info.seed.subarray(0, 8);
        }
      } else {
        pluginName = packet2.readStringNullEnded("ascii");
        pluginData = packet2.readBufferRemaining();
      }
      if (opts.restrictedAuth && !opts.restrictedAuth.includes(pluginName)) {
        this.throwNewError(
          `Unsupported authentication plugin ${pluginName}. Authorized plugin: ${opts.restrictedAuth.toString()}`,
          true,
          info,
          "42000",
          Errors.ER_NOT_SUPPORTED_AUTH_PLUGIN
        );
        return;
      }
      try {
        this.plugin.emit("end");
        this.plugin.onPacketReceive = null;
        this.plugin = Authentication.pluginHandler(
          pluginName,
          this.plugin.sequenceNo,
          this.plugin.compressSequenceNo,
          pluginData,
          info,
          opts,
          out2,
          this.cmdParam,
          this.reject,
          this.handshakeResult.bind(this)
        );
        this.plugin.start(out2, opts, info);
      } catch (err) {
        this.reject(err);
      }
    }
    static pluginHandler(pluginName, packSeq, compressPackSeq, pluginData, info, opts, out2, cmdParam, authReject, multiAuthResolver) {
      let pluginAuth2 = authenticationPlugins[pluginName];
      if (!pluginAuth2) {
        throw Errors.createFatalError(
          `Client does not support authentication protocol '${pluginName}' requested by server.`,
          Errors.ER_AUTHENTICATION_PLUGIN_NOT_SUPPORTED,
          info,
          "08004"
        );
      }
      return new pluginAuth2(packSeq, compressPackSeq, pluginData, cmdParam, authReject, multiAuthResolver);
    }
  }
  authentication = Authentication;
  return authentication;
}
var quit;
var hasRequiredQuit;
function requireQuit() {
  if (hasRequiredQuit) return quit;
  hasRequiredQuit = 1;
  const Command = requireCommand();
  const QUIT_COMMAND = new Uint8Array([1, 0, 0, 0, 1]);
  class Quit extends Command {
    constructor(cmdParam, resolve, reject) {
      super(cmdParam, resolve, reject);
    }
    start(out2, opts, info) {
      if (opts.logger.query) opts.logger.query("QUIT");
      this.onPacketReceive = this.skipResults;
      out2.fastFlush(this, QUIT_COMMAND);
      this.emit("send_end");
      this.successEnd();
    }
    skipResults(packet2, out2, opts, info) {
    }
  }
  quit = Quit;
  return quit;
}
var ping;
var hasRequiredPing;
function requirePing() {
  if (hasRequiredPing) return ping;
  hasRequiredPing = 1;
  const Command = requireCommand();
  const ServerStatus = requireServerStatus();
  const PING_COMMAND = new Uint8Array([1, 0, 0, 0, 14]);
  class Ping extends Command {
    constructor(cmdParam, resolve, reject) {
      super(cmdParam, resolve, reject);
    }
    start(out2, opts, info) {
      if (opts.logger.query) opts.logger.query("PING");
      this.onPacketReceive = this.readPingResponsePacket;
      out2.fastFlush(this, PING_COMMAND);
      this.emit("send_end");
    }
    /**
     * Read ping response packet.
     * packet can be :
     * - an ERR_Packet
     * - an OK_Packet
     *
     * @param packet  query response
     * @param out     output writer
     * @param opts    connection options
     * @param info    connection info
     */
    readPingResponsePacket(packet2, out2, opts, info) {
      packet2.skip(1);
      packet2.skipLengthCodedNumber();
      packet2.skipLengthCodedNumber();
      info.status = packet2.readUInt16();
      if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0) {
        info.redirect(info.redirectRequest, this.successEnd.bind(this, null));
      } else {
        this.successEnd(null);
      }
    }
  }
  ping = Ping;
  return ping;
}
var reset;
var hasRequiredReset;
function requireReset() {
  if (hasRequiredReset) return reset;
  hasRequiredReset = 1;
  const Command = requireCommand();
  const ServerStatus = requireServerStatus();
  const RESET_COMMAND = new Uint8Array([1, 0, 0, 0, 31]);
  class Reset extends Command {
    constructor(cmdParam, resolve, reject) {
      super(cmdParam, resolve, reject);
    }
    start(out2, opts, info) {
      if (opts.logger.query) opts.logger.query("RESET");
      this.onPacketReceive = this.readResetResponsePacket;
      out2.fastFlush(this, RESET_COMMAND);
      this.emit("send_end");
    }
    /**
     * Read response packet.
     * packet can be :
     * - an ERR_Packet
     * - a OK_Packet
     *
     * @param packet  query response
     * @param out     output writer
     * @param opts    connection options
     * @param info    connection info
     */
    readResetResponsePacket(packet2, out2, opts, info) {
      packet2.skip(1);
      packet2.skipLengthCodedNumber();
      packet2.skipLengthCodedNumber();
      info.status = packet2.readUInt16();
      if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0) {
        info.redirect(info.redirectRequest, this.successEnd.bind(this));
      } else {
        this.successEnd();
      }
    }
  }
  reset = Reset;
  return reset;
}
var fieldType = {};
var hasRequiredFieldType;
function requireFieldType() {
  if (hasRequiredFieldType) return fieldType;
  hasRequiredFieldType = 1;
  fieldType.DECIMAL = 0;
  fieldType.TINY = 1;
  fieldType.SHORT = 2;
  fieldType.INT = 3;
  fieldType.FLOAT = 4;
  fieldType.DOUBLE = 5;
  fieldType.NULL = 6;
  fieldType.TIMESTAMP = 7;
  fieldType.BIGINT = 8;
  fieldType.INT24 = 9;
  fieldType.DATE = 10;
  fieldType.TIME = 11;
  fieldType.DATETIME = 12;
  fieldType.YEAR = 13;
  fieldType.NEWDATE = 14;
  fieldType.VARCHAR = 15;
  fieldType.BIT = 16;
  fieldType.TIMESTAMP2 = 17;
  fieldType.DATETIME2 = 18;
  fieldType.TIME2 = 19;
  fieldType.JSON = 245;
  fieldType.NEWDECIMAL = 246;
  fieldType.ENUM = 247;
  fieldType.SET = 248;
  fieldType.TINY_BLOB = 249;
  fieldType.MEDIUM_BLOB = 250;
  fieldType.LONG_BLOB = 251;
  fieldType.BLOB = 252;
  fieldType.VAR_STRING = 253;
  fieldType.STRING = 254;
  fieldType.GEOMETRY = 255;
  const typeNames = [];
  typeNames[0] = "DECIMAL";
  typeNames[1] = "TINY";
  typeNames[2] = "SHORT";
  typeNames[3] = "INT";
  typeNames[4] = "FLOAT";
  typeNames[5] = "DOUBLE";
  typeNames[6] = "NULL";
  typeNames[7] = "TIMESTAMP";
  typeNames[8] = "BIGINT";
  typeNames[9] = "INT24";
  typeNames[10] = "DATE";
  typeNames[11] = "TIME";
  typeNames[12] = "DATETIME";
  typeNames[13] = "YEAR";
  typeNames[14] = "NEWDATE";
  typeNames[15] = "VARCHAR";
  typeNames[16] = "BIT";
  typeNames[17] = "TIMESTAMP2";
  typeNames[18] = "DATETIME2";
  typeNames[19] = "TIME2";
  typeNames[245] = "JSON";
  typeNames[246] = "NEWDECIMAL";
  typeNames[247] = "ENUM";
  typeNames[248] = "SET";
  typeNames[249] = "TINY_BLOB";
  typeNames[250] = "MEDIUM_BLOB";
  typeNames[251] = "LONG_BLOB";
  typeNames[252] = "BLOB";
  typeNames[253] = "VAR_STRING";
  typeNames[254] = "STRING";
  typeNames[255] = "GEOMETRY";
  fieldType.TYPES = typeNames;
  return fieldType;
}
var fieldDetail = {};
var hasRequiredFieldDetail;
function requireFieldDetail() {
  if (hasRequiredFieldDetail) return fieldDetail;
  hasRequiredFieldDetail = 1;
  fieldDetail.NOT_NULL = 1;
  fieldDetail.PRIMARY_KEY = 2;
  fieldDetail.UNIQUE_KEY = 4;
  fieldDetail.MULTIPLE_KEY = 8;
  fieldDetail.BLOB = 1 << 4;
  fieldDetail.UNSIGNED = 1 << 5;
  fieldDetail.ZEROFILL_FLAG = 1 << 6;
  fieldDetail.BINARY_COLLATION = 1 << 7;
  fieldDetail.ENUM = 1 << 8;
  fieldDetail.AUTO_INCREMENT = 1 << 9;
  fieldDetail.TIMESTAMP = 1 << 10;
  fieldDetail.SET = 1 << 11;
  fieldDetail.NO_DEFAULT_VALUE_FLAG = 1 << 12;
  fieldDetail.ON_UPDATE_NOW_FLAG = 1 << 13;
  fieldDetail.NUM_FLAG = 1 << 14;
  return fieldDetail;
}
var columnDefinition;
var hasRequiredColumnDefinition;
function requireColumnDefinition() {
  var _stringParser;
  if (hasRequiredColumnDefinition) return columnDefinition;
  hasRequiredColumnDefinition = 1;
  const Collations = requireCollations();
  const FieldType = requireFieldType();
  const FieldDetails = requireFieldDetail();
  const Capabilities = requireCapabilities();
  class ColumnDef {
    constructor(packet2, info, skipName) {
      __privateAdd(this, _stringParser);
      __privateSet(this, _stringParser, skipName ? new StringParser(packet2) : new StringParserWithName(packet2));
      if (info.clientCapabilities & Capabilities.MARIADB_CLIENT_EXTENDED_TYPE_INFO) {
        const len = packet2.readUnsignedLength();
        if (len > 0) {
          const subPacket = packet2.subPacketLengthEncoded(len);
          while (subPacket.remaining()) {
            switch (subPacket.readUInt8()) {
              case 0:
                this.dataTypeName = subPacket.readAsciiStringLengthEncoded();
                break;
              case 1:
                this.dataTypeFormat = subPacket.readAsciiStringLengthEncoded();
                break;
              default:
                subPacket.skip(subPacket.readUnsignedLength());
                break;
            }
          }
        }
      }
      packet2.skip(1);
      this.collation = Collations.fromIndex(packet2.readUInt16());
      this.columnLength = packet2.readUInt32();
      this.columnType = packet2.readUInt8();
      this.flags = packet2.readUInt16();
      this.scale = packet2.readUInt8();
      this.type = FieldType.TYPES[this.columnType];
    }
    __getDefaultGeomVal() {
      if (this.dataTypeName) {
        switch (this.dataTypeName) {
          case "point":
            return { type: "Point" };
          case "linestring":
            return { type: "LineString" };
          case "polygon":
            return { type: "Polygon" };
          case "multipoint":
            return { type: "MultiPoint" };
          case "multilinestring":
            return { type: "MultiLineString" };
          case "multipolygon":
            return { type: "MultiPolygon" };
          default:
            return { type: this.dataTypeName };
        }
      }
      return null;
    }
    db() {
      return __privateGet(this, _stringParser).db();
    }
    schema() {
      return __privateGet(this, _stringParser).schema();
    }
    table() {
      return __privateGet(this, _stringParser).table();
    }
    orgTable() {
      return __privateGet(this, _stringParser).orgTable();
    }
    name() {
      return __privateGet(this, _stringParser).name();
    }
    orgName() {
      return __privateGet(this, _stringParser).orgName();
    }
    signed() {
      return (this.flags & FieldDetails.UNSIGNED) === 0;
    }
    isSet() {
      return (this.flags & FieldDetails.SET) !== 0;
    }
  }
  _stringParser = new WeakMap();
  class BaseStringParser {
    constructor(encoding, readFct, saveBuf, initialPos) {
      this.buf = saveBuf;
      this.encoding = encoding;
      this.readString = readFct;
      this.initialPos = initialPos;
    }
    _readIdentifier(skip) {
      let pos = this.initialPos;
      while (skip-- > 0) {
        const type3 = this.buf[pos++];
        pos += type3 < 251 ? type3 : 2 + this.buf[pos] + this.buf[pos + 1] * 2 ** 8;
      }
      let len;
      const type2 = this.buf[pos++];
      len = type2 < 251 ? type2 : this.buf[pos++] + this.buf[pos++] * 2 ** 8;
      return this.readString(this.encoding, this.buf, pos, len);
    }
    name() {
      return this._readIdentifier(3);
    }
    db() {
      return this._readIdentifier(0);
    }
    schema() {
      return this.db();
    }
    table() {
      return this._readIdentifier(1);
    }
    orgTable() {
      return this._readIdentifier(2);
    }
    orgName() {
      return this._readIdentifier(4);
    }
  }
  class StringParser extends BaseStringParser {
    constructor(packet2) {
      packet2.skip(packet2.readMetadataLength());
      const initPos = packet2.pos;
      packet2.skip(packet2.readMetadataLength());
      packet2.skip(packet2.readMetadataLength());
      packet2.skip(packet2.readMetadataLength());
      packet2.skip(packet2.readMetadataLength());
      packet2.skip(packet2.readMetadataLength());
      super(packet2.encoding, packet2.constructor.readString, packet2.buf, initPos);
    }
  }
  class StringParserWithName extends BaseStringParser {
    constructor(packet2) {
      packet2.skip(packet2.readMetadataLength());
      const initPos = packet2.pos;
      packet2.skip(packet2.readMetadataLength());
      packet2.skip(packet2.readMetadataLength());
      packet2.skip(packet2.readMetadataLength());
      const colName = packet2.readStringLengthEncoded();
      packet2.skip(packet2.readMetadataLength());
      super(packet2.encoding, packet2.constructor.readString, packet2.buf, initPos);
      __publicField(this, "colName");
      this.colName = colName;
    }
    name() {
      return this.colName;
    }
  }
  columnDefinition = ColumnDef;
  return columnDefinition;
}
var parse = {};
var hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse;
  hasRequiredParse$1 = 1;
  const Errors = requireErrors();
  const State = {
    Normal: 1,
    String: 2,
    SlashStarComment: 3,
    Escape: 4,
    EOLComment: 5,
    Backtick: 6
    /* found backtick */
  };
  const SLASH_BYTE = "/".charCodeAt(0);
  const STAR_BYTE = "*".charCodeAt(0);
  const BACKSLASH_BYTE = "\\".charCodeAt(0);
  const HASH_BYTE = "#".charCodeAt(0);
  const MINUS_BYTE = "-".charCodeAt(0);
  const LINE_FEED_BYTE = "\n".charCodeAt(0);
  const DBL_QUOTE_BYTE = '"'.charCodeAt(0);
  const QUOTE_BYTE = "'".charCodeAt(0);
  const RADICAL_BYTE = "`".charCodeAt(0);
  const QUESTION_MARK_BYTE = "?".charCodeAt(0);
  const COLON_BYTE = ":".charCodeAt(0);
  const SEMICOLON_BYTE = ";".charCodeAt(0);
  parse.splitQuery = function(query2) {
    let paramPositions = [];
    let state = State.Normal;
    let lastChar = 0;
    let singleQuotes = false;
    const len = query2.length;
    for (let i = 0; i < len; i++) {
      if (state === State.Escape && !(query2[i] === QUOTE_BYTE && singleQuotes || query2[i] === DBL_QUOTE_BYTE && !singleQuotes)) {
        state = State.String;
        lastChar = query2[i];
        continue;
      }
      switch (query2[i]) {
        case STAR_BYTE:
          if (state === State.Normal && lastChar === SLASH_BYTE) {
            state = State.SlashStarComment;
          }
          break;
        case SLASH_BYTE:
          if (state === State.SlashStarComment && lastChar === STAR_BYTE) {
            state = State.Normal;
          } else if (state === State.Normal && lastChar === SLASH_BYTE) {
            state = State.EOLComment;
          }
          break;
        case HASH_BYTE:
          if (state === State.Normal) {
            state = State.EOLComment;
          }
          break;
        case MINUS_BYTE:
          if (state === State.Normal && lastChar === MINUS_BYTE) {
            state = State.EOLComment;
          }
          break;
        case LINE_FEED_BYTE:
          if (state === State.EOLComment) {
            state = State.Normal;
          }
          break;
        case DBL_QUOTE_BYTE:
          if (state === State.Normal) {
            state = State.String;
            singleQuotes = false;
          } else if (state === State.String && !singleQuotes) {
            state = State.Normal;
          } else if (state === State.Escape) {
            state = State.String;
          }
          break;
        case QUOTE_BYTE:
          if (state === State.Normal) {
            state = State.String;
            singleQuotes = true;
          } else if (state === State.String && singleQuotes) {
            state = State.Normal;
          } else if (state === State.Escape) {
            state = State.String;
          }
          break;
        case BACKSLASH_BYTE:
          if (state === State.String) {
            state = State.Escape;
          }
          break;
        case QUESTION_MARK_BYTE:
          if (state === State.Normal) {
            paramPositions.push(i, ++i);
          }
          break;
        case RADICAL_BYTE:
          if (state === State.Backtick) {
            state = State.Normal;
          } else if (state === State.Normal) {
            state = State.Backtick;
          }
          break;
      }
      lastChar = query2[i];
    }
    return paramPositions;
  };
  parse.splitQueryPlaceholder = function(query2, info, initialValues, displaySql) {
    let paramPositions = [];
    let values = [];
    let state = State.Normal;
    let lastChar = 0;
    let singleQuotes = false;
    let car;
    const len = query2.length;
    for (let i = 0; i < len; i++) {
      car = query2[i];
      if (state === State.Escape && !(car === QUOTE_BYTE && singleQuotes || car === DBL_QUOTE_BYTE && !singleQuotes)) {
        state = State.String;
        lastChar = car;
        continue;
      }
      switch (car) {
        case STAR_BYTE:
          if (state === State.Normal && lastChar === SLASH_BYTE) {
            state = State.SlashStarComment;
          }
          break;
        case SLASH_BYTE:
          if (state === State.SlashStarComment && lastChar === STAR_BYTE) {
            state = State.Normal;
          } else if (state === State.Normal && lastChar === SLASH_BYTE) {
            state = State.EOLComment;
          }
          break;
        case HASH_BYTE:
          if (state === State.Normal) {
            state = State.EOLComment;
          }
          break;
        case MINUS_BYTE:
          if (state === State.Normal && lastChar === MINUS_BYTE) {
            state = State.EOLComment;
          }
          break;
        case LINE_FEED_BYTE:
          if (state === State.EOLComment) {
            state = State.Normal;
          }
          break;
        case DBL_QUOTE_BYTE:
          if (state === State.Normal) {
            state = State.String;
            singleQuotes = false;
          } else if (state === State.String && !singleQuotes) {
            state = State.Normal;
          } else if (state === State.Escape) {
            state = State.String;
          }
          break;
        case QUOTE_BYTE:
          if (state === State.Normal) {
            state = State.String;
            singleQuotes = true;
          } else if (state === State.String && singleQuotes) {
            state = State.Normal;
          } else if (state === State.Escape) {
            state = State.String;
          }
          break;
        case BACKSLASH_BYTE:
          if (state === State.String) {
            state = State.Escape;
          }
          break;
        case QUESTION_MARK_BYTE:
          if (state === State.Normal) {
            paramPositions.push(i);
            paramPositions.push(++i);
          }
          break;
        case COLON_BYTE:
          if (state === State.Normal) {
            let j = 1;
            while (i + j < len && query2[i + j] >= "0".charCodeAt(0) && query2[i + j] <= "9".charCodeAt(0) || query2[i + j] >= "A".charCodeAt(0) && query2[i + j] <= "Z".charCodeAt(0) || query2[i + j] >= "a".charCodeAt(0) && query2[i + j] <= "z".charCodeAt(0) || query2[i + j] === "-".charCodeAt(0) || query2[i + j] === "_".charCodeAt(0)) {
              j++;
            }
            paramPositions.push(i, i + j);
            const placeholderName = query2.toString("utf8", i + 1, i + j);
            i += j;
            const val = initialValues[placeholderName];
            if (val === void 0) {
              throw Errors.createError(
                `Placeholder '${placeholderName}' is not defined`,
                Errors.ER_PLACEHOLDER_UNDEFINED,
                info,
                "HY000",
                displaySql.call()
              );
            }
            values.push(val);
          }
          break;
        case RADICAL_BYTE:
          if (state === State.Backtick) {
            state = State.Normal;
          } else if (state === State.Normal) {
            state = State.Backtick;
          }
          break;
      }
      lastChar = car;
    }
    return { paramPositions, values };
  };
  parse.searchPlaceholder = function(sql) {
    let sqlPlaceHolder = "";
    let placeHolderIndex = [];
    let state = State.Normal;
    let lastChar = "\0";
    let singleQuotes = false;
    let lastParameterPosition = 0;
    let idx = 0;
    let car = sql.charAt(idx++);
    let placeholderName;
    while (car !== "") {
      if (state === State.Escape && !(car === "'" && singleQuotes || car === '"' && !singleQuotes)) {
        state = State.String;
        lastChar = car;
        car = sql.charAt(idx++);
        continue;
      }
      switch (car) {
        case "*":
          if (state === State.Normal && lastChar === "/") state = State.SlashStarComment;
          break;
        case "/":
          if (state === State.SlashStarComment && lastChar === "*") state = State.Normal;
          break;
        case "#":
          if (state === State.Normal) state = State.EOLComment;
          break;
        case "-":
          if (state === State.Normal && lastChar === "-") {
            state = State.EOLComment;
          }
          break;
        case "\n":
          if (state === State.EOLComment) {
            state = State.Normal;
          }
          break;
        case '"':
          if (state === State.Normal) {
            state = State.String;
            singleQuotes = false;
          } else if (state === State.String && !singleQuotes) {
            state = State.Normal;
          } else if (state === State.Escape && !singleQuotes) {
            state = State.String;
          }
          break;
        case "'":
          if (state === State.Normal) {
            state = State.String;
            singleQuotes = true;
          } else if (state === State.String && singleQuotes) {
            state = State.Normal;
            singleQuotes = false;
          } else if (state === State.Escape && singleQuotes) {
            state = State.String;
          }
          break;
        case "\\":
          if (state === State.String) state = State.Escape;
          break;
        case ":":
          if (state === State.Normal) {
            sqlPlaceHolder += sql.substring(lastParameterPosition, idx - 1) + "?";
            placeholderName = "";
            while ((car = sql.charAt(idx++)) !== "" && car >= "0" && car <= "9" || car >= "A" && car <= "Z" || car >= "a" && car <= "z" || car === "-" || car === "_") {
              placeholderName += car;
            }
            idx--;
            placeHolderIndex.push(placeholderName);
            lastParameterPosition = idx;
          }
          break;
        case "`":
          if (state === State.Backtick) {
            state = State.Normal;
          } else if (state === State.Normal) {
            state = State.Backtick;
          }
      }
      lastChar = car;
      car = sql.charAt(idx++);
    }
    if (lastParameterPosition === 0) {
      sqlPlaceHolder = sql;
    } else {
      sqlPlaceHolder += sql.substring(lastParameterPosition);
    }
    return { sql: sqlPlaceHolder, placeHolderIndex };
  };
  parse.validateFileName = function(sql, parameters, fileName) {
    let queryValidator = new RegExp(
      "^(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*\\s*LOAD\\s+DATA\\s+((LOW_PRIORITY|CONCURRENT)\\s+)?LOCAL\\s+INFILE\\s+'" + fileName.replace(/\\/g, "\\\\\\\\").replace(".", "\\.") + "'",
      "i"
    );
    if (queryValidator.test(sql)) return true;
    if (parameters != null) {
      queryValidator = new RegExp(
        "^(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*\\s*LOAD\\s+DATA\\s+((LOW_PRIORITY|CONCURRENT)\\s+)?LOCAL\\s+INFILE\\s+\\?",
        "i"
      );
      if (queryValidator.test(sql) && parameters.length > 0) {
        if (Array.isArray(parameters)) {
          return parameters[0].toLowerCase() === fileName.toLowerCase();
        }
        return parameters.toLowerCase() === fileName.toLowerCase();
      }
    }
    return false;
  };
  parse.parseQueries = function(bufState) {
    let state = State.Normal;
    let lastChar = 0;
    let currByte;
    let queries = [];
    let singleQuotes = false;
    for (let i = bufState.offset; i < bufState.end; i++) {
      currByte = bufState.buffer[i];
      if (state === State.Escape && !(currByte === QUOTE_BYTE && singleQuotes || currByte === DBL_QUOTE_BYTE && !singleQuotes)) {
        state = State.String;
        lastChar = currByte;
        continue;
      }
      switch (currByte) {
        case STAR_BYTE:
          if (state === State.Normal && lastChar === SLASH_BYTE) {
            state = State.SlashStarComment;
          }
          break;
        case SLASH_BYTE:
          if (state === State.SlashStarComment && lastChar === STAR_BYTE) {
            state = State.Normal;
          } else if (state === State.Normal && lastChar === SLASH_BYTE) {
            state = State.EOLComment;
          }
          break;
        case HASH_BYTE:
          if (state === State.Normal) {
            state = State.EOLComment;
          }
          break;
        case MINUS_BYTE:
          if (state === State.Normal && lastChar === MINUS_BYTE) {
            state = State.EOLComment;
          }
          break;
        case LINE_FEED_BYTE:
          if (state === State.EOLComment) {
            state = State.Normal;
          }
          break;
        case DBL_QUOTE_BYTE:
          if (state === State.Normal) {
            state = State.String;
            singleQuotes = false;
          } else if (state === State.String && !singleQuotes) {
            state = State.Normal;
          } else if (state === State.Escape) {
            state = State.String;
          }
          break;
        case QUOTE_BYTE:
          if (state === State.Normal) {
            state = State.String;
            singleQuotes = true;
          } else if (state === State.String && singleQuotes) {
            state = State.Normal;
          } else if (state === State.Escape) {
            state = State.String;
          }
          break;
        case BACKSLASH_BYTE:
          if (state === State.String) {
            state = State.Escape;
          }
          break;
        case SEMICOLON_BYTE:
          if (state === State.Normal) {
            queries.push(bufState.buffer.toString("utf8", bufState.offset, i));
            bufState.offset = i + 1;
          }
          break;
        case RADICAL_BYTE:
          if (state === State.Backtick) {
            state = State.Normal;
          } else if (state === State.Normal) {
            state = State.Backtick;
          }
          break;
      }
      lastChar = currByte;
    }
    return queries;
  };
  return parse;
}
var binaryDecoder = {};
var hasRequiredBinaryDecoder;
function requireBinaryDecoder() {
  if (hasRequiredBinaryDecoder) return binaryDecoder;
  hasRequiredBinaryDecoder = 1;
  const FieldType = requireFieldType();
  const Errors = requireErrors();
  binaryDecoder.newRow = function(packet2, columns) {
    packet2.skip(1);
    const len = ~~((columns.length + 9) / 8);
    const nullBitMap = new Array(len);
    for (let i = 0; i < len; i++) nullBitMap[i] = packet2.readUInt8();
    return nullBitMap;
  };
  binaryDecoder.castWrapper = function(column, packet2, opts, nullBitmap, index) {
    column.string = () => isNullBitmap(index, nullBitmap) ? null : packet2.readStringLengthEncoded();
    column.buffer = () => isNullBitmap(index, nullBitmap) ? null : packet2.readBufferLengthEncoded();
    column.float = () => isNullBitmap(index, nullBitmap) ? null : packet2.readFloat();
    column.tiny = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet2.readInt8() : packet2.readUInt8();
    column.short = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet2.readInt16() : packet2.readUInt16();
    column.int = () => isNullBitmap(index, nullBitmap) ? null : packet2.readInt32();
    column.long = () => isNullBitmap(index, nullBitmap) ? null : packet2.readBigInt64();
    column.decimal = () => isNullBitmap(index, nullBitmap) ? null : packet2.readDecimalLengthEncoded();
    column.date = () => isNullBitmap(index, nullBitmap) ? null : packet2.readBinaryDate(opts);
    column.datetime = () => isNullBitmap(index, nullBitmap) ? null : packet2.readBinaryDateTime();
    column.geometry = () => {
      let defaultVal = null;
      if (column.dataTypeName) {
        switch (column.dataTypeName) {
          case "point":
            defaultVal = { type: "Point" };
            break;
          case "linestring":
            defaultVal = { type: "LineString" };
            break;
          case "polygon":
            defaultVal = { type: "Polygon" };
            break;
          case "multipoint":
            defaultVal = { type: "MultiPoint" };
            break;
          case "multilinestring":
            defaultVal = { type: "MultiLineString" };
            break;
          case "multipolygon":
            defaultVal = { type: "MultiPolygon" };
            break;
          default:
            defaultVal = { type: column.dataTypeName };
            break;
        }
      }
      if (isNullBitmap(index, nullBitmap)) {
        return defaultVal;
      }
      return packet2.readGeometry(defaultVal);
    };
  };
  binaryDecoder.parser = function(col, opts) {
    const defaultParser = col.signed() ? DEFAULT_SIGNED_PARSER_TYPE[col.columnType] : DEFAULT_UNSIGNED_PARSER_TYPE[col.columnType];
    if (defaultParser) return defaultParser;
    switch (col.columnType) {
      case FieldType.BIGINT:
        if (col.signed()) {
          return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinarySigned : readBigintBinarySigned;
        }
        return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinaryUnsigned : readBigintBinaryUnsigned;
      case FieldType.DATETIME:
      case FieldType.TIMESTAMP:
        return opts.dateStrings ? readTimestampStringBinary.bind(null, col.scale) : readTimestampBinary;
      case FieldType.DECIMAL:
      case FieldType.NEWDECIMAL:
        return col.scale === 0 ? readDecimalAsIntBinary : readDecimalBinary;
      case FieldType.GEOMETRY:
        let defaultVal = col.__getDefaultGeomVal();
        return readGeometryBinary.bind(null, defaultVal);
      case FieldType.BIT:
        if (col.columnLength === 1 && opts.bitOneIsBoolean) {
          return readBitBinaryBoolean;
        }
        return readBinaryBuffer;
      case FieldType.JSON:
        return opts.jsonStrings ? readStringBinary : readJsonBinary;
      default:
        if (col.dataTypeFormat && col.dataTypeFormat === "json" && opts.autoJsonMap) {
          return readJsonBinary;
        }
        if (col.collation.index === 63) {
          return readBinaryBuffer;
        }
        if (col.isSet()) {
          return readBinarySet;
        }
        return readStringBinary;
    }
  };
  const isNullBitmap = (index, nullBitmap) => {
    return (nullBitmap[~~((index + 2) / 8)] & 1 << (index + 2) % 8) > 0;
  };
  const readTinyBinarySigned = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readInt8();
  const readTinyBinaryUnsigned = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readUInt8();
  const readShortBinarySigned = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readInt16();
  const readShortBinaryUnsigned = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readUInt16();
  const readMediumBinarySigned = (packet2, opts, throwUnexpectedError, nullBitmap, index) => {
    if (isNullBitmap(index, nullBitmap)) {
      return null;
    }
    const result = packet2.readInt24();
    packet2.skip(1);
    return result;
  };
  const readMediumBinaryUnsigned = (packet2, opts, throwUnexpectedError, nullBitmap, index) => {
    if (isNullBitmap(index, nullBitmap)) {
      return null;
    }
    const result = packet2.readUInt24();
    packet2.skip(1);
    return result;
  };
  const readIntBinarySigned = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readInt32();
  const readIntBinaryUnsigned = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readUInt32();
  const readFloatBinary = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readFloat();
  const readDoubleBinary = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readDouble();
  const readBigintBinaryUnsigned = function(packet2, opts, throwUnexpectedError, nullBitmap, index) {
    if (isNullBitmap(index, nullBitmap)) return null;
    return packet2.readBigUInt64();
  };
  const readBigintBinarySigned = function(packet2, opts, throwUnexpectedError, nullBitmap, index) {
    if (isNullBitmap(index, nullBitmap)) return null;
    return packet2.readBigInt64();
  };
  const readBigintAsIntBinaryUnsigned = function(packet2, opts, throwUnexpectedError, nullBitmap, index) {
    if (isNullBitmap(index, nullBitmap)) return null;
    const val = packet2.readBigUInt64();
    if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {
      return throwUnexpectedError(
        `value ${val} can't safely be converted to number`,
        false,
        null,
        "42000",
        Errors.ER_PARSING_PRECISION
      );
    }
    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {
      return val.toString();
    }
    return Number(val);
  };
  const readBigintAsIntBinarySigned = function(packet2, opts, throwUnexpectedError, nullBitmap, index) {
    if (isNullBitmap(index, nullBitmap)) return null;
    const val = packet2.readBigInt64();
    if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {
      return throwUnexpectedError(
        `value ${val} can't safely be converted to number`,
        false,
        null,
        "42000",
        Errors.ER_PARSING_PRECISION
      );
    }
    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {
      return val.toString();
    }
    return Number(val);
  };
  const readGeometryBinary = (defaultVal, packet2, opts, throwUnexpectedError, nullBitmap, index) => {
    if (isNullBitmap(index, nullBitmap)) {
      return defaultVal;
    }
    return packet2.readGeometry(defaultVal);
  };
  const readDateBinary = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readBinaryDate(opts);
  const readTimestampBinary = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readBinaryDateTime();
  const readTimestampStringBinary = (scale, packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readBinaryDateTimeAsString(scale);
  const readTimeBinary = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readBinaryTime();
  const readDecimalAsIntBinary = (packet2, opts, throwUnexpectedError, nullBitmap, index) => {
    if (isNullBitmap(index, nullBitmap)) return null;
    const valDec = packet2.readDecimalLengthEncoded();
    if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
      if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {
        return throwUnexpectedError(
          `value ${valDec} can't safely be converted to number`,
          false,
          null,
          "42000",
          Errors.ER_PARSING_PRECISION
        );
      }
      if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {
        return valDec;
      }
      return Number(valDec);
    }
    return valDec;
  };
  const readDecimalBinary = (packet2, opts, throwUnexpectedError, nullBitmap, index) => {
    if (isNullBitmap(index, nullBitmap)) return null;
    const valDec = packet2.readDecimalLengthEncoded();
    if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
      const numberValue = Number(valDec);
      if (opts.supportBigNumbers && (opts.bigNumberStrings || Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue))) {
        return valDec;
      }
      return numberValue;
    }
    return valDec;
  };
  const readJsonBinary = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : JSON.parse(packet2.readStringLengthEncoded());
  const readBitBinaryBoolean = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readBufferLengthEncoded()[0] === 1;
  const readBinaryBuffer = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readBufferLengthEncoded();
  const readBinarySet = (packet2, opts, throwUnexpectedError, nullBitmap, index) => {
    if (isNullBitmap(index, nullBitmap)) return null;
    const string = packet2.readStringLengthEncoded();
    return string == null ? null : string === "" ? [] : string.split(",");
  };
  const readStringBinary = (packet2, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet2.readStringLengthEncoded();
  const DEFAULT_SIGNED_PARSER_TYPE = Array(256);
  DEFAULT_SIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinarySigned;
  DEFAULT_SIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinarySigned;
  DEFAULT_SIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinarySigned;
  DEFAULT_SIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinarySigned;
  DEFAULT_SIGNED_PARSER_TYPE[FieldType.INT] = readIntBinarySigned;
  DEFAULT_SIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;
  DEFAULT_SIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;
  DEFAULT_SIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;
  DEFAULT_SIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;
  const DEFAULT_UNSIGNED_PARSER_TYPE = Array(256);
  DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinaryUnsigned;
  DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinaryUnsigned;
  DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinaryUnsigned;
  DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinaryUnsigned;
  DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT] = readIntBinaryUnsigned;
  DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;
  DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;
  DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;
  DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;
  return binaryDecoder;
}
var textDecoder = {};
var hasRequiredTextDecoder;
function requireTextDecoder() {
  if (hasRequiredTextDecoder) return textDecoder;
  hasRequiredTextDecoder = 1;
  const FieldType = requireFieldType();
  const Errors = requireErrors();
  textDecoder.parser = function(col, opts) {
    const defaultParser = DEFAULT_PARSER_TYPE[col.columnType];
    if (defaultParser) return defaultParser;
    switch (col.columnType) {
      case FieldType.DECIMAL:
      case FieldType.NEWDECIMAL:
        return col.scale === 0 ? readDecimalAsIntLengthCoded : readDecimalLengthCoded;
      case FieldType.BIGINT:
        if (opts.bigIntAsNumber || opts.supportBigNumbers) return readBigIntAsNumberLengthCoded;
        return readBigIntLengthCoded;
      case FieldType.GEOMETRY:
        let defaultVal = col.__getDefaultGeomVal();
        return readGeometry.bind(null, defaultVal);
      case FieldType.BIT:
        if (col.columnLength === 1 && opts.bitOneIsBoolean) {
          return readBitAsBoolean;
        }
        return readBufferLengthEncoded;
      case FieldType.JSON:
        return opts.jsonStrings ? readStringLengthEncoded : readJson;
      default:
        if (col.dataTypeFormat && col.dataTypeFormat === "json" && opts.autoJsonMap) {
          return readJson;
        }
        if (col.collation.index === 63) {
          return readBufferLengthEncoded;
        }
        if (col.isSet()) {
          return readSet;
        }
        return readStringLengthEncoded;
    }
  };
  textDecoder.castWrapper = function(column, packet2, opts, nullBitmap, index) {
    column.string = () => packet2.readStringLengthEncoded();
    column.buffer = () => packet2.readBufferLengthEncoded();
    column.float = () => packet2.readFloatLengthCoded();
    column.tiny = () => packet2.readIntLengthEncoded();
    column.short = () => packet2.readIntLengthEncoded();
    column.int = () => packet2.readIntLengthEncoded();
    column.long = () => packet2.readBigIntLengthEncoded();
    column.decimal = () => packet2.readDecimalLengthEncoded();
    column.date = () => packet2.readDate(opts);
    column.datetime = () => packet2.readDateTime();
    column.geometry = () => {
      let defaultVal = null;
      if (column.dataTypeName) {
        switch (column.dataTypeName) {
          case "point":
            defaultVal = { type: "Point" };
            break;
          case "linestring":
            defaultVal = { type: "LineString" };
            break;
          case "polygon":
            defaultVal = { type: "Polygon" };
            break;
          case "multipoint":
            defaultVal = { type: "MultiPoint" };
            break;
          case "multilinestring":
            defaultVal = { type: "MultiLineString" };
            break;
          case "multipolygon":
            defaultVal = { type: "MultiPolygon" };
            break;
          default:
            defaultVal = { type: column.dataTypeName };
            break;
        }
      }
      return packet2.readGeometry(defaultVal);
    };
  };
  const readGeometry = (defaultVal, packet2, opts, throwUnexpectedError) => packet2.readGeometry(defaultVal);
  const readIntLengthEncoded = (packet2, opts, throwUnexpectedError) => packet2.readIntLengthEncoded();
  const readStringLengthEncoded = (packet2, opts, throwUnexpectedError) => packet2.readStringLengthEncoded();
  const readFloatLengthCoded = (packet2, opts, throwUnexpectedError) => packet2.readFloatLengthCoded();
  const readBigIntLengthCoded = (packet2, opts, throwUnexpectedError) => packet2.readBigIntLengthEncoded();
  const readBigIntAsNumberLengthCoded = (packet2, opts, throwUnexpectedError) => {
    const len = packet2.readUnsignedLength();
    if (len === null) return null;
    if (len < 16) {
      const val2 = packet2._atoi(len);
      if (opts.supportBigNumbers && opts.bigNumberStrings) {
        return `${val2}`;
      }
      return val2;
    }
    const val = packet2.readBigIntFromLen(len);
    if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {
      return throwUnexpectedError(
        `value ${val} can't safely be converted to number`,
        false,
        null,
        "42000",
        Errors.ER_PARSING_PRECISION
      );
    }
    if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {
      return val.toString();
    }
    return Number(val);
  };
  const readDecimalAsIntLengthCoded = (packet2, opts, throwUnexpectedError) => {
    const valDec = packet2.readDecimalLengthEncoded();
    if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
      if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {
        return throwUnexpectedError(
          `value ${valDec} can't safely be converted to number`,
          false,
          null,
          "42000",
          Errors.ER_PARSING_PRECISION
        );
      }
      if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {
        return valDec;
      }
      return Number(valDec);
    }
    return valDec;
  };
  const readDecimalLengthCoded = (packet2, opts, throwUnexpectedError) => {
    const valDec = packet2.readDecimalLengthEncoded();
    if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
      const numberValue = Number(valDec);
      if (opts.supportBigNumbers && (opts.bigNumberStrings || Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue))) {
        return valDec;
      }
      return numberValue;
    }
    return valDec;
  };
  const readDate = (packet2, opts, throwUnexpectedError) => {
    if (opts.dateStrings) {
      return packet2.readAsciiStringLengthEncoded();
    }
    return packet2.readDate();
  };
  const readTimestamp = (packet2, opts, throwUnexpectedError) => {
    if (opts.dateStrings) {
      return packet2.readAsciiStringLengthEncoded();
    }
    return packet2.readDateTime();
  };
  const readAsciiStringLengthEncoded = (packet2, opts, throwUnexpectedError) => packet2.readAsciiStringLengthEncoded();
  const readBitAsBoolean = (packet2, opts, throwUnexpectedError) => {
    const val = packet2.readBufferLengthEncoded();
    return val == null ? null : val[0] === 1;
  };
  const readBufferLengthEncoded = (packet2, opts, throwUnexpectedError) => packet2.readBufferLengthEncoded();
  const readJson = (packet2, opts, throwUnexpectedError) => JSON.parse(packet2.readStringLengthEncoded());
  const readSet = (packet2, opts, throwUnexpectedError) => {
    const string = packet2.readStringLengthEncoded();
    return string == null ? null : string === "" ? [] : string.split(",");
  };
  const DEFAULT_PARSER_TYPE = Array(256);
  DEFAULT_PARSER_TYPE[FieldType.TINY] = readIntLengthEncoded;
  DEFAULT_PARSER_TYPE[FieldType.SHORT] = readIntLengthEncoded;
  DEFAULT_PARSER_TYPE[FieldType.INT] = readIntLengthEncoded;
  DEFAULT_PARSER_TYPE[FieldType.INT24] = readIntLengthEncoded;
  DEFAULT_PARSER_TYPE[FieldType.YEAR] = readIntLengthEncoded;
  DEFAULT_PARSER_TYPE[FieldType.FLOAT] = readFloatLengthCoded;
  DEFAULT_PARSER_TYPE[FieldType.DOUBLE] = readFloatLengthCoded;
  DEFAULT_PARSER_TYPE[FieldType.DATE] = readDate;
  DEFAULT_PARSER_TYPE[FieldType.DATETIME] = readTimestamp;
  DEFAULT_PARSER_TYPE[FieldType.TIMESTAMP] = readTimestamp;
  DEFAULT_PARSER_TYPE[FieldType.TIME] = readAsciiStringLengthEncoded;
  return textDecoder;
}
var okPacket;
var hasRequiredOkPacket;
function requireOkPacket() {
  if (hasRequiredOkPacket) return okPacket;
  hasRequiredOkPacket = 1;
  class OkPacket {
    constructor(affectedRows, insertId, warningStatus) {
      this.affectedRows = affectedRows;
      this.insertId = insertId;
      this.warningStatus = warningStatus;
    }
  }
  okPacket = OkPacket;
  return okPacket;
}
var parser;
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  const Command = requireCommand();
  const ServerStatus = requireServerStatus();
  const ColumnDefinition = requireColumnDefinition();
  const Errors = requireErrors();
  const fs2 = require$$1$2;
  const Parse = requireParse$1();
  const BinaryDecoder = requireBinaryDecoder();
  const TextDecoder = requireTextDecoder();
  const OkPacket = requireOkPacket();
  const StateChange = requireStateChange();
  const Collations = requireCollations();
  class Parser extends Command {
    constructor(resolve, reject, connOpts, cmdParam) {
      super(cmdParam, resolve, reject);
      this._responseIndex = 0;
      this._rows = [];
      this.opts = cmdParam.opts ? Object.assign({}, connOpts, cmdParam.opts) : connOpts;
      this.sql = cmdParam.sql;
      this.initialValues = cmdParam.values;
      this.canSkipMeta = false;
    }
    /**
     * Read Query response packet.
     * packet can be :
     * - a result-set
     * - an ERR_Packet
     * - a OK_Packet
     * - LOCAL_INFILE Packet
     *
     * @param packet  query response
     * @param out     output writer
     * @param opts    connection options
     * @param info    connection info
     */
    readResponsePacket(packet2, out2, opts, info) {
      switch (packet2.peek()) {
        //*********************************************************************************************************
        //* OK response
        //*********************************************************************************************************
        case 0:
          return this.readOKPacket(packet2, out2, opts, info);
        //*********************************************************************************************************
        //* ERROR response
        //*********************************************************************************************************
        case 255:
          this._columns = null;
          this._rows = [];
          const err = packet2.readError(info, opts.logParam ? this.displaySql() : this.sql, this.cmdParam.stack);
          info.status |= ServerStatus.STATUS_IN_TRANS;
          return this.throwError(err, info);
        //*********************************************************************************************************
        //* LOCAL INFILE response
        //*********************************************************************************************************
        case 251:
          return this.readLocalInfile(packet2, out2, opts, info);
        //*********************************************************************************************************
        //* Parser
        //*********************************************************************************************************
        default:
          return this.readResultSet(packet2, info);
      }
    }
    /**
     * Read result-set packets :
     * see https://mariadb.com/kb/en/library/resultset/
     *
     * @param packet    Column count packet
     * @param info      current connection information
     * @returns {Parser.readColumn} next packet handler
     */
    readResultSet(packet2, info) {
      this._columnCount = packet2.readUnsignedLength();
      this._rows.push([]);
      if (this.canSkipMeta && info.serverPermitSkipMeta && packet2.readUInt8() === 0) {
        this._columns = this.prepare.columns;
        this.emit("fields", this._columns);
        this.setParser();
        return this.onPacketReceive = info.eofDeprecated ? this.readResultSetRow : this.readIntermediateEOF;
      }
      this._columns = [];
      this.onPacketReceive = this.readColumn;
    }
    /**
     * Read OK_Packet.
     * see https://mariadb.com/kb/en/library/ok_packet/
     *
     * @param packet    OK_Packet
     * @param opts      connection options
     * @param info      connection information
     * @param out       output writer
     * @returns {*}     null or {Result.readResponsePacket} in case of multi-result-set
     */
    readOKPacket(packet2, out2, opts, info) {
      packet2.skip(1);
      const affectedRows = packet2.readUnsignedLength();
      let insertId = packet2.readInsertId();
      info.status = packet2.readUInt16();
      if (this.opts.supportBigNumbers || this.opts.insertIdAsNumber) {
        if (this.opts.insertIdAsNumber && this.opts.checkNumberRange && !Number.isSafeInteger(Number(insertId))) {
          this.onPacketReceive = info.status & ServerStatus.MORE_RESULTS_EXISTS ? this.readResponsePacket : null;
          this.throwUnexpectedError(
            `last insert id value ${insertId} can't safely be converted to number`,
            false,
            info,
            "42000",
            Errors.ER_PARSING_PRECISION
          );
          return;
        }
        if (this.opts.supportBigNumbers && (this.opts.bigNumberStrings || !Number.isSafeInteger(Number(insertId)))) {
          insertId = insertId.toString();
        } else insertId = Number(insertId);
      }
      const okPacket2 = new OkPacket(affectedRows, insertId, packet2.readUInt16());
      let mustRedirect = false;
      if (info.status & ServerStatus.SESSION_STATE_CHANGED) {
        packet2.skipLengthCodedNumber();
        while (packet2.remaining()) {
          const len = packet2.readUnsignedLength();
          if (len > 0) {
            const subPacket = packet2.subPacketLengthEncoded(len);
            while (subPacket.remaining()) {
              const type2 = subPacket.readUInt8();
              switch (type2) {
                case StateChange.SESSION_TRACK_SYSTEM_VARIABLES:
                  let subSubPacket;
                  do {
                    subSubPacket = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                    const variable = subSubPacket.readStringLengthEncoded();
                    const value = subSubPacket.readStringLengthEncoded();
                    switch (variable) {
                      case "character_set_client":
                        info.collation = Collations.fromCharset(value);
                        if (info.collation === void 0) {
                          this.throwError(new Error("unknown charset : '" + value + "'"), info);
                          return;
                        }
                        opts.emit("collation", info.collation);
                        break;
                      case "redirect_url":
                        if (value !== "") {
                          mustRedirect = true;
                          info.redirect(value, this.okPacketSuccess.bind(this, okPacket2, info));
                        }
                        break;
                      case "connection_id":
                        info.threadId = parseInt(value);
                        break;
                    }
                  } while (subSubPacket.remaining() > 0);
                  break;
                case StateChange.SESSION_TRACK_SCHEMA:
                  const subSubPacket2 = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                  info.database = subSubPacket2.readStringLengthEncoded();
                  break;
              }
            }
          }
        }
      }
      if (this.inStream) {
        this.handleNewRows(okPacket2);
      }
      if (!mustRedirect) {
        if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0 && (info.status & ServerStatus.MORE_RESULTS_EXISTS) === 0) {
          info.redirect(info.redirectRequest, this.okPacketSuccess.bind(this, okPacket2, info));
        } else {
          this.okPacketSuccess(okPacket2, info);
        }
      }
    }
    okPacketSuccess(okPacket2, info) {
      if (this._responseIndex === 0) {
        if (info.status & ServerStatus.MORE_RESULTS_EXISTS) {
          this._rows.push(okPacket2);
          this._responseIndex++;
          return this.onPacketReceive = this.readResponsePacket;
        }
        return this.success(this.opts.metaAsArray ? [okPacket2, []] : okPacket2);
      }
      this._rows.push(okPacket2);
      if (info.status & ServerStatus.MORE_RESULTS_EXISTS) {
        this._responseIndex++;
        return this.onPacketReceive = this.readResponsePacket;
      }
      if (this.opts.metaAsArray) {
        if (!this._meta) {
          this._meta = new Array(this._responseIndex);
        }
        this._meta[this._responseIndex] = null;
        this.success([this._rows, this._meta]);
      } else {
        this.success(this._rows);
      }
    }
    success(val) {
      this.successEnd(val);
      this._columns = null;
      this._rows = [];
    }
    /**
     * Read column information metadata
     * see https://mariadb.com/kb/en/library/resultset/#column-definition-packet
     *
     * @param packet    column definition packet
     * @param out       output writer
     * @param opts      connection options
     * @param info      connection information
     * @returns {*}
     */
    readColumn(packet2, out2, opts, info) {
      this._columns.push(new ColumnDefinition(packet2, info, this.opts.rowsAsArray));
      if (this._columns.length === this._columnCount) {
        this.setParser();
        if (this.canSkipMeta && info.serverPermitSkipMeta && this.prepare != null) {
          this.prepare.columns = this._columns;
        }
        this.emit("fields", this._columns);
        return this.onPacketReceive = info.eofDeprecated ? this.readResultSetRow : this.readIntermediateEOF;
      }
    }
    setParser() {
      this._parseFunction = new Array(this._columnCount);
      if (this.opts.typeCast) {
        for (let i = 0; i < this._columnCount; i++) {
          this._parseFunction[i] = this.readCastValue.bind(this, this._columns[i]);
        }
      } else {
        const dataParser = this.binary ? BinaryDecoder.parser : TextDecoder.parser;
        for (let i = 0; i < this._columnCount; i++) {
          this._parseFunction[i] = dataParser(this._columns[i], this.opts);
        }
      }
      if (this.opts.rowsAsArray) {
        this.parseRow = this.parseRowAsArray;
      } else {
        this.tableHeader = new Array(this._columnCount);
        this.parseRow = this.binary ? this.parseRowStdBinary : this.parseRowStdText;
        if (this.opts.nestTables) {
          if (typeof this.opts.nestTables === "string") {
            for (let i = 0; i < this._columnCount; i++) {
              this.tableHeader[i] = this._columns[i].table() + this.opts.nestTables + this._columns[i].name();
            }
            this.checkDuplicates();
          } else if (this.opts.nestTables === true) {
            this.parseRow = this.parseRowNested;
            for (let i = 0; i < this._columnCount; i++) {
              this.tableHeader[i] = [this._columns[i].table(), this._columns[i].name()];
            }
            this.checkNestTablesDuplicatesAndPrivateFields();
          }
        } else {
          for (let i = 0; i < this._columnCount; i++) {
            this.tableHeader[i] = this._columns[i].name();
          }
          this.checkDuplicates();
        }
      }
    }
    checkDuplicates() {
      if (this.opts.checkDuplicate) {
        for (let i = 0; i < this._columnCount; i++) {
          if (this.tableHeader.indexOf(this.tableHeader[i], i + 1) > 0) {
            const dupes = this.tableHeader.reduce(
              (acc, v, i2, arr) => arr.indexOf(v) !== i2 && acc.indexOf(v) === -1 ? acc.concat(v) : acc,
              []
            );
            this.throwUnexpectedError(
              `Error in results, duplicate field name \`${dupes[0]}\`.
(see option \`checkDuplicate\`)`,
              false,
              null,
              "42000",
              Errors.ER_DUPLICATE_FIELD
            );
          }
        }
      }
    }
    checkNestTablesDuplicatesAndPrivateFields() {
      if (this.opts.checkDuplicate) {
        for (let i = 0; i < this._columnCount; i++) {
          for (let j = 0; j < i; j++) {
            if (this.tableHeader[j][0] === this.tableHeader[i][0] && this.tableHeader[j][1] === this.tableHeader[i][1]) {
              this.throwUnexpectedError(
                `Error in results, duplicate field name \`${this.tableHeader[i][0]}\`.\`${this.tableHeader[i][1]}\`
(see option \`checkDuplicate\`)`,
                false,
                null,
                "42000",
                Errors.ER_DUPLICATE_FIELD
              );
            }
          }
        }
      }
      for (let i = 0; i < this._columnCount; i++) {
        if (privateFields.has(this.tableHeader[i][0])) {
          this.throwUnexpectedError(
            `Use of \`${this.tableHeader[i][0]}\` is not permitted with option \`nestTables\``,
            false,
            null,
            "42000",
            Errors.ER_PRIVATE_FIELDS_USE
          );
          this.parseRow = () => {
            return {};
          };
        }
      }
    }
    /**
     * Read intermediate EOF.
     * _only for server before MariaDB 10.2 / MySQL 5.7 that doesn't have CLIENT_DEPRECATE_EOF capability_
     * see https://mariadb.com/kb/en/library/eof_packet/
     *
     * @param packet    EOF Packet
     * @param out       output writer
     * @param opts      connection options
     * @param info      connection information
     * @returns {*}
     */
    readIntermediateEOF(packet2, out2, opts, info) {
      if (packet2.peek() !== 254) {
        return this.throwNewError("Error in protocol, expected EOF packet", true, info, "42000", Errors.ER_EOF_EXPECTED);
      }
      packet2.skip(3);
      info.status = packet2.readUInt16();
      this.isOutParameter = info.status & ServerStatus.PS_OUT_PARAMS;
      this.onPacketReceive = this.readResultSetRow;
    }
    handleNewRows(row) {
      this._rows[this._responseIndex].push(row);
    }
    /**
     * Check if packet is result-set end = EOF of OK_Packet with EOF header according to CLIENT_DEPRECATE_EOF capability
     * or a result-set row
     *
     * @param packet    current packet
     * @param out       output writer
     * @param opts      connection options
     * @param info      connection information
     * @returns {*}
     */
    readResultSetRow(packet2, out2, opts, info) {
      if (packet2.peek() >= 254) {
        if (packet2.peek() === 255) {
          info.status |= ServerStatus.STATUS_IN_TRANS;
          return this.throwError(
            packet2.readError(info, this.opts.logParam ? this.displaySql() : this.sql, this.cmdParam.err),
            info
          );
        }
        if (!info.eofDeprecated && packet2.length() < 13 || info.eofDeprecated && packet2.length() < 16777215) {
          if (!info.eofDeprecated) {
            packet2.skip(3);
            info.status = packet2.readUInt16();
          } else {
            packet2.skip(1);
            packet2.skipLengthCodedNumber();
            packet2.skipLengthCodedNumber();
            info.status = packet2.readUInt16();
          }
          if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0 && (info.status & ServerStatus.MORE_RESULTS_EXISTS) === 0) {
            info.redirect(info.redirectRequest, this.resultSetEndingPacketResult.bind(this, info));
          } else {
            this.resultSetEndingPacketResult(info);
          }
          return;
        }
      }
      this.handleNewRows(this.parseRow(packet2));
    }
    resultSetEndingPacketResult(info) {
      if (this.opts.metaAsArray) {
        if (info.status & ServerStatus.MORE_RESULTS_EXISTS || this.isOutParameter) {
          if (!this._meta) this._meta = [];
          this._meta[this._responseIndex] = this._columns;
          this._responseIndex++;
          return this.onPacketReceive = this.readResponsePacket;
        }
        if (this._responseIndex === 0) {
          this.success([this._rows[0], this._columns]);
        } else {
          if (!this._meta) this._meta = [];
          this._meta[this._responseIndex] = this._columns;
          this.success([this._rows, this._meta]);
        }
      } else {
        Object.defineProperty(this._rows[this._responseIndex], "meta", {
          value: this._columns,
          writable: true,
          enumerable: this.opts.metaEnumerable
        });
        if (info.status & ServerStatus.MORE_RESULTS_EXISTS || this.isOutParameter) {
          this._responseIndex++;
          return this.onPacketReceive = this.readResponsePacket;
        }
        this.success(this._responseIndex === 0 ? this._rows[0] : this._rows);
      }
    }
    /**
     * Display current SQL with parameters (truncated if too big)
     *
     * @returns {string}
     */
    displaySql() {
      if (this.opts && this.initialValues) {
        if (this.sql.length > this.opts.debugLen) {
          return this.sql.substring(0, this.opts.debugLen) + "...";
        }
        let sqlMsg = this.sql + " - parameters:";
        return Parser.logParameters(this.opts, sqlMsg, this.initialValues);
      }
      if (this.sql.length > this.opts.debugLen) {
        return this.sql.substring(0, this.opts.debugLen) + "... - parameters:[]";
      }
      return this.sql + " - parameters:[]";
    }
    static logParameters(opts, sqlMsg, values) {
      if (opts.namedPlaceholders) {
        sqlMsg += "{";
        let first = true;
        for (let key in values) {
          if (first) {
            first = false;
          } else {
            sqlMsg += ",";
          }
          sqlMsg += "'" + key + "':";
          let param = values[key];
          sqlMsg = Parser.logParam(sqlMsg, param);
          if (sqlMsg.length > opts.debugLen) {
            return sqlMsg.substring(0, opts.debugLen) + "...";
          }
        }
        sqlMsg += "}";
      } else {
        sqlMsg += "[";
        if (Array.isArray(values)) {
          for (let i = 0; i < values.length; i++) {
            if (i !== 0) sqlMsg += ",";
            let param = values[i];
            sqlMsg = Parser.logParam(sqlMsg, param);
            if (sqlMsg.length > opts.debugLen) {
              return sqlMsg.substring(0, opts.debugLen) + "...";
            }
          }
        } else {
          sqlMsg = Parser.logParam(sqlMsg, values);
          if (sqlMsg.length > opts.debugLen) {
            return sqlMsg.substring(0, opts.debugLen) + "...";
          }
        }
        sqlMsg += "]";
      }
      return sqlMsg;
    }
    parseRowAsArray(packet2) {
      const row = new Array(this._columnCount);
      const nullBitMap = this.binary ? BinaryDecoder.newRow(packet2, this._columns) : null;
      for (let i = 0; i < this._columnCount; i++) {
        row[i] = this._parseFunction[i](packet2, this.opts, this.unexpectedError, nullBitMap, i);
      }
      return row;
    }
    parseRowNested(packet2) {
      const row = {};
      const nullBitMap = this.binary ? BinaryDecoder.newRow(packet2, this._columns) : null;
      for (let i = 0; i < this._columnCount; i++) {
        if (!row[this.tableHeader[i][0]]) row[this.tableHeader[i][0]] = {};
        row[this.tableHeader[i][0]][this.tableHeader[i][1]] = this._parseFunction[i](
          packet2,
          this.opts,
          this.unexpectedError,
          nullBitMap,
          i
        );
      }
      return row;
    }
    parseRowStdText(packet2) {
      const row = {};
      for (let i = 0; i < this._columnCount; i++) {
        row[this.tableHeader[i]] = this._parseFunction[i](packet2, this.opts, this.unexpectedError);
      }
      return row;
    }
    parseRowStdBinary(packet2) {
      const nullBitMap = BinaryDecoder.newRow(packet2, this._columns);
      const row = {};
      for (let i = 0; i < this._columnCount; i++) {
        row[this.tableHeader[i]] = this._parseFunction[i](packet2, this.opts, this.unexpectedError, nullBitMap, i);
      }
      return row;
    }
    readCastValue(column, packet2, opts, unexpectedError, nullBitmap, index) {
      if (this.binary) {
        BinaryDecoder.castWrapper(column, packet2, opts, nullBitmap, index);
      } else {
        TextDecoder.castWrapper(column, packet2, opts, nullBitmap, index);
      }
      const dataParser = this.binary ? BinaryDecoder.parser : TextDecoder.parser;
      return opts.typeCast(column, dataParser(column, opts).bind(null, packet2, opts, unexpectedError, nullBitmap, index));
    }
    readLocalInfile(packet2, out2, opts, info) {
      packet2.skip(1);
      out2.startPacket(this);
      const fileName = packet2.readStringRemaining();
      if (!Parse.validateFileName(this.sql, this.initialValues, fileName)) {
        out2.writeEmptyPacket();
        const error2 = Errors.createError(
          "LOCAL INFILE wrong filename. '" + fileName + "' doesn't correspond to query " + this.sql + ". Query cancelled. Check for malicious server / proxy",
          Errors.ER_LOCAL_INFILE_WRONG_FILENAME,
          info,
          "HY000",
          this.sql
        );
        process.nextTick(this.reject, error2);
        this.reject = null;
        this.resolve = null;
        return this.onPacketReceive = this.readResponsePacket;
      }
      let stream2;
      try {
        stream2 = this.opts.infileStreamFactory ? this.opts.infileStreamFactory(fileName) : fs2.createReadStream(fileName);
      } catch (e) {
        out2.writeEmptyPacket();
        const error2 = Errors.createError(
          `LOCAL INFILE infileStreamFactory failed`,
          Errors.ER_LOCAL_INFILE_NOT_READABLE,
          info,
          "22000",
          this.opts.logParam ? this.displaySql() : this.sql
        );
        error2.cause = e;
        process.nextTick(this.reject, error2);
        this.reject = null;
        this.resolve = null;
        return this.onPacketReceive = this.readResponsePacket;
      }
      stream2.on(
        "error",
        (function(err) {
          out2.writeEmptyPacket();
          const error2 = Errors.createError(
            `LOCAL INFILE command failed: ${err.message}`,
            Errors.ER_LOCAL_INFILE_NOT_READABLE,
            info,
            "22000",
            this.sql
          );
          process.nextTick(this.reject, error2);
          this.reject = null;
          this.resolve = null;
        }).bind(this)
      );
      stream2.on("data", (chunk) => {
        out2.writeBuffer(chunk, 0, chunk.length);
      });
      stream2.on("end", () => {
        if (!out2.isEmpty()) {
          out2.flushBuffer(false);
        }
        out2.writeEmptyPacket();
      });
      this.onPacketReceive = this.readResponsePacket;
    }
    static logParam(sqlMsg, param) {
      if (param == null) {
        sqlMsg += param === void 0 ? "undefined" : "null";
      } else {
        switch (param.constructor.name) {
          case "Buffer":
            sqlMsg += "0x" + param.toString("hex", 0, Math.min(1024, param.length));
            break;
          case "String":
            sqlMsg += "'" + param + "'";
            break;
          case "Date":
            sqlMsg += getStringDate(param);
            break;
          case "Object":
            sqlMsg += JSON.stringify(param);
            break;
          default:
            sqlMsg += param.toString();
        }
      }
      return sqlMsg;
    }
  }
  function getStringDate(param) {
    return "'" + ("00" + (param.getMonth() + 1)).slice(-2) + "/" + ("00" + param.getDate()).slice(-2) + "/" + param.getFullYear() + " " + ("00" + param.getHours()).slice(-2) + ":" + ("00" + param.getMinutes()).slice(-2) + ":" + ("00" + param.getSeconds()).slice(-2) + "." + ("000" + param.getMilliseconds()).slice(-3) + "'";
  }
  const privateFields = /* @__PURE__ */ new Set([
    "__defineGetter__",
    "__defineSetter__",
    "__lookupGetter__",
    "__lookupSetter__",
    "__proto__"
  ]);
  parser = Parser;
  return parser;
}
var query$1;
var hasRequiredQuery;
function requireQuery() {
  if (hasRequiredQuery) return query$1;
  hasRequiredQuery = 1;
  const Parser = requireParser();
  const Errors = requireErrors();
  const Parse = requireParse$1();
  const TextEncoder = requireTextEncoder();
  const { Readable } = require$$0$4;
  const QUOTE = 39;
  class Query extends Parser {
    constructor(resolve, reject, connOpts, cmdParam) {
      super(resolve, reject, connOpts, cmdParam);
      this.binary = false;
    }
    /**
     * Send COM_QUERY
     *
     * @param out   output writer
     * @param opts  connection options
     * @param info  connection information
     */
    start(out2, opts, info) {
      if (opts.logger.query) opts.logger.query(`QUERY: ${opts.logParam ? this.displaySql() : this.sql}`);
      this.onPacketReceive = this.readResponsePacket;
      if (this.initialValues === void 0) {
        out2.startPacket(this);
        out2.writeInt8(3);
        if (!this.handleTimeout(out2, info)) return;
        out2.writeString(this.sql);
        out2.flush();
        this.emit("send_end");
        return;
      }
      this.encodedSql = out2.encodeString(this.sql);
      if (this.opts.namedPlaceholders) {
        try {
          const parsed = Parse.splitQueryPlaceholder(
            this.encodedSql,
            info,
            this.initialValues,
            this.opts.logParam ? this.displaySql.bind(this) : () => this.sql
          );
          this.paramPositions = parsed.paramPositions;
          this.values = parsed.values;
        } catch (err) {
          this.emit("send_end");
          return this.throwError(err, info);
        }
      } else {
        this.paramPositions = Parse.splitQuery(this.encodedSql);
        this.values = Array.isArray(this.initialValues) ? this.initialValues : [this.initialValues];
        if (!this.validateParameters(info)) return;
      }
      out2.startPacket(this);
      out2.writeInt8(3);
      if (!this.handleTimeout(out2, info)) return;
      this.paramPos = 0;
      this.sqlPos = 0;
      const len = this.paramPositions.length / 2;
      for (this.valueIdx = 0; this.valueIdx < len; ) {
        out2.writeBuffer(this.encodedSql, this.sqlPos, this.paramPositions[this.paramPos++] - this.sqlPos);
        this.sqlPos = this.paramPositions[this.paramPos++];
        const value = this.values[this.valueIdx++];
        if (value == null) {
          out2.writeStringAscii("NULL");
          continue;
        }
        switch (typeof value) {
          case "boolean":
            out2.writeStringAscii(value ? "true" : "false");
            break;
          case "bigint":
          case "number":
            out2.writeStringAscii(`${value}`);
            break;
          case "string":
            out2.writeStringEscapeQuote(value);
            break;
          case "object":
            if (typeof value.pipe === "function" && typeof value.read === "function") {
              this.sending = true;
              this.paramWritten = this._paramWritten.bind(this, out2, info);
              out2.writeInt8(QUOTE);
              value.on("data", out2.writeBufferEscape.bind(out2));
              value.on(
                "end",
                (function() {
                  out2.writeInt8(QUOTE);
                  this.paramWritten();
                }).bind(this)
              );
              return;
            }
            if (Object.prototype.toString.call(value) === "[object Date]") {
              out2.writeStringAscii(TextEncoder.getLocalDate(value));
            } else if (Buffer.isBuffer(value)) {
              out2.writeStringAscii("_BINARY '");
              out2.writeBufferEscape(value);
              out2.writeInt8(QUOTE);
            } else if (typeof value.toSqlString === "function") {
              out2.writeStringEscapeQuote(String(value.toSqlString()));
            } else if (Array.isArray(value)) {
              if (opts.arrayParenthesis) {
                out2.writeStringAscii("(");
              }
              for (let i = 0; i < value.length; i++) {
                if (i !== 0) out2.writeStringAscii(",");
                if (value[i] == null) {
                  out2.writeStringAscii("NULL");
                } else TextEncoder.writeParam(out2, value[i], opts, info);
              }
              if (opts.arrayParenthesis) {
                out2.writeStringAscii(")");
              }
            } else {
              if (value.type != null && [
                "Point",
                "LineString",
                "Polygon",
                "MultiPoint",
                "MultiLineString",
                "MultiPolygon",
                "GeometryCollection"
              ].includes(value.type)) {
                let prefix = info.isMariaDB() && info.hasMinVersion(10, 1, 4) || !info.isMariaDB() && info.hasMinVersion(5, 7, 6) ? "ST_" : "";
                switch (value.type) {
                  case "Point":
                    out2.writeStringAscii(
                      prefix + "PointFromText('POINT(" + TextEncoder.geoPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "LineString":
                    out2.writeStringAscii(
                      prefix + "LineFromText('LINESTRING(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "Polygon":
                    out2.writeStringAscii(
                      prefix + "PolygonFromText('POLYGON(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "MultiPoint":
                    out2.writeStringAscii(
                      prefix + "MULTIPOINTFROMTEXT('MULTIPOINT(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "MultiLineString":
                    out2.writeStringAscii(
                      prefix + "MLineFromText('MULTILINESTRING(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "MultiPolygon":
                    out2.writeStringAscii(
                      prefix + "MPolyFromText('MULTIPOLYGON(" + TextEncoder.geoMultiPolygonToString(value.coordinates) + ")')"
                    );
                    break;
                  case "GeometryCollection":
                    out2.writeStringAscii(
                      prefix + "GeomCollFromText('GEOMETRYCOLLECTION(" + TextEncoder.geometricCollectionToString(value.geometries) + ")')"
                    );
                    break;
                }
              } else if (String === value.constructor) {
                out2.writeStringEscapeQuote(value);
                break;
              } else {
                if (opts.permitSetMultiParamEntries) {
                  let first = true;
                  for (let key in value) {
                    const val = value[key];
                    if (typeof val === "function") continue;
                    if (first) {
                      first = false;
                    } else {
                      out2.writeStringAscii(",");
                    }
                    out2.writeString("`" + key + "`");
                    if (val == null) {
                      out2.writeStringAscii("=NULL");
                    } else {
                      out2.writeStringAscii("=");
                      TextEncoder.writeParam(out2, val, opts, info);
                    }
                  }
                  if (first) out2.writeStringEscapeQuote(JSON.stringify(value));
                } else {
                  out2.writeStringEscapeQuote(JSON.stringify(value));
                }
              }
            }
            break;
        }
      }
      out2.writeBuffer(this.encodedSql, this.sqlPos, this.encodedSql.length - this.sqlPos);
      out2.flush();
      this.emit("send_end");
    }
    /**
     * If timeout is set, prepend query with SET STATEMENT max_statement_time=xx FOR, or throw an error
     * @param out buffer
     * @param info server information
     * @returns {boolean} false if an error has been thrown
     */
    handleTimeout(out2, info) {
      if (this.opts.timeout) {
        if (info.isMariaDB()) {
          if (info.hasMinVersion(10, 1, 2)) {
            out2.writeString(`SET STATEMENT max_statement_time=${this.opts.timeout / 1e3} FOR `);
            return true;
          } else {
            this.sendCancelled(
              `Cannot use timeout for xpand/MariaDB server before 10.1.2. timeout value: ${this.opts.timeout}`,
              Errors.ER_TIMEOUT_NOT_SUPPORTED,
              info
            );
            return false;
          }
        } else {
          this.sendCancelled(
            `Cannot use timeout for MySQL server. timeout value: ${this.opts.timeout}`,
            Errors.ER_TIMEOUT_NOT_SUPPORTED,
            info
          );
          return false;
        }
      }
      return true;
    }
    /**
     * Validate that parameters exists and are defined.
     *
     * @param info        connection info
     * @returns {boolean} return false if any error occur.
     */
    validateParameters(info) {
      if (this.paramPositions.length / 2 > this.values.length) {
        this.sendCancelled(
          `Parameter at position ${this.values.length + 1} is not set`,
          Errors.ER_MISSING_PARAMETER,
          info
        );
        return false;
      }
      return true;
    }
    _paramWritten(out2, info) {
      while (true) {
        if (this.valueIdx === this.paramPositions.length / 2) {
          out2.writeBuffer(this.encodedSql, this.sqlPos, this.encodedSql.length - this.sqlPos);
          out2.flush();
          this.sending = false;
          this.emit("send_end");
          return;
        } else {
          const value = this.values[this.valueIdx++];
          out2.writeBuffer(this.encodedSql, this.sqlPos, this.paramPositions[this.paramPos++] - this.sqlPos);
          this.sqlPos = this.paramPositions[this.paramPos++];
          if (value == null) {
            out2.writeStringAscii("NULL");
            continue;
          }
          if (typeof value === "object" && typeof value.pipe === "function" && typeof value.read === "function") {
            out2.writeInt8(QUOTE);
            value.once(
              "end",
              (function() {
                out2.writeInt8(QUOTE);
                this._paramWritten(out2, info);
              }).bind(this)
            );
            value.on("data", out2.writeBufferEscape.bind(out2));
            return;
          }
          TextEncoder.writeParam(out2, value, this.opts, info);
        }
      }
    }
    _stream(socket, options) {
      this.socket = socket;
      options = options || {};
      options.objectMode = true;
      options.read = () => {
        this.socket.resume();
      };
      this.inStream = new Readable(options);
      this.on("fields", function(meta) {
        this.inStream.emit("fields", meta);
      });
      this.on("error", function(err) {
        this.inStream.emit("error", err);
      });
      this.on("close", function(err) {
        this.inStream.emit("error", err);
      });
      this.on("end", function(err) {
        if (err) this.inStream.emit("error", err);
        this.socket.resume();
        this.inStream.push(null);
      });
      this.inStream.close = (function() {
        this.handleNewRows = () => {
        };
        this.socket.resume();
      }).bind(this);
      this.handleNewRows = function(row) {
        if (!this.inStream.push(row)) {
          this.socket.pause();
        }
      };
      return this.inStream;
    }
  }
  query$1 = Query;
  return query$1;
}
var binaryEncoder;
var hasRequiredBinaryEncoder;
function requireBinaryEncoder() {
  if (hasRequiredBinaryEncoder) return binaryEncoder;
  hasRequiredBinaryEncoder = 1;
  class BinaryEncoder {
    /**
     * Write (and escape) current parameter value to output writer
     *
     * @param out     output writer
     * @param value   current parameter
     * @param opts    connection options
     * @param info    connection information
     */
    static writeParam(out2, value, opts, info) {
      switch (typeof value) {
        case "boolean":
          out2.writeInt8(value ? 1 : 0);
          break;
        case "bigint":
          if (value >= 2n ** 63n) {
            out2.writeLengthEncodedString(value.toString());
          } else {
            out2.writeBigInt(value);
          }
          break;
        case "number":
          if (Number.isInteger(value) && value >= -2147483648 && value < 2147483647) {
            out2.writeInt32(value);
            break;
          }
          out2.writeDouble(value);
          break;
        case "string":
          out2.writeLengthEncodedString(value);
          break;
        case "object":
          if (Object.prototype.toString.call(value) === "[object Date]") {
            out2.writeBinaryDate(value);
          } else if (Buffer.isBuffer(value)) {
            out2.writeLengthEncodedBuffer(value);
          } else if (typeof value.toSqlString === "function") {
            out2.writeLengthEncodedString(String(value.toSqlString()));
          } else {
            out2.writeLengthEncodedString(JSON.stringify(value));
          }
          break;
        default:
          out2.writeLengthEncodedBuffer(value);
      }
    }
    static getBufferFromGeometryValue(value, headerType) {
      let geoBuff;
      let pos;
      let type2;
      if (!headerType) {
        switch (value.type) {
          case "Point":
            geoBuff = Buffer.allocUnsafe(21);
            geoBuff.writeInt8(1, 0);
            geoBuff.writeInt32LE(1, 1);
            if (value.coordinates && Array.isArray(value.coordinates) && value.coordinates.length >= 2 && !isNaN(value.coordinates[0]) && !isNaN(value.coordinates[1])) {
              geoBuff.writeDoubleLE(value.coordinates[0], 5);
              geoBuff.writeDoubleLE(value.coordinates[1], 13);
              return geoBuff;
            } else {
              return null;
            }
          case "LineString":
            if (value.coordinates && Array.isArray(value.coordinates)) {
              const pointNumber = value.coordinates.length;
              geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(2, 1);
              geoBuff.writeInt32LE(pointNumber, 5);
              for (let i = 0; i < pointNumber; i++) {
                if (value.coordinates[i] && Array.isArray(value.coordinates[i]) && value.coordinates[i].length >= 2 && !isNaN(value.coordinates[i][0]) && !isNaN(value.coordinates[i][1])) {
                  geoBuff.writeDoubleLE(value.coordinates[i][0], 9 + 16 * i);
                  geoBuff.writeDoubleLE(value.coordinates[i][1], 17 + 16 * i);
                } else {
                  return null;
                }
              }
              return geoBuff;
            } else {
              return null;
            }
          case "Polygon":
            if (value.coordinates && Array.isArray(value.coordinates)) {
              const numRings = value.coordinates.length;
              let size = 0;
              for (let i = 0; i < numRings; i++) {
                size += 4 + 16 * value.coordinates[i].length;
              }
              geoBuff = Buffer.allocUnsafe(9 + size);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(3, 1);
              geoBuff.writeInt32LE(numRings, 5);
              pos = 9;
              for (let i = 0; i < numRings; i++) {
                const lineString = value.coordinates[i];
                if (lineString && Array.isArray(lineString)) {
                  geoBuff.writeInt32LE(lineString.length, pos);
                  pos += 4;
                  for (let j = 0; j < lineString.length; j++) {
                    if (lineString[j] && Array.isArray(lineString[j]) && lineString[j].length >= 2 && !isNaN(lineString[j][0]) && !isNaN(lineString[j][1])) {
                      geoBuff.writeDoubleLE(lineString[j][0], pos);
                      geoBuff.writeDoubleLE(lineString[j][1], pos + 8);
                      pos += 16;
                    } else {
                      return null;
                    }
                  }
                }
              }
              return geoBuff;
            } else {
              return null;
            }
          case "MultiPoint":
            type2 = "MultiPoint";
            geoBuff = Buffer.allocUnsafe(9);
            geoBuff.writeInt8(1, 0);
            geoBuff.writeInt32LE(4, 1);
            break;
          case "MultiLineString":
            type2 = "MultiLineString";
            geoBuff = Buffer.allocUnsafe(9);
            geoBuff.writeInt8(1, 0);
            geoBuff.writeInt32LE(5, 1);
            break;
          case "MultiPolygon":
            type2 = "MultiPolygon";
            geoBuff = Buffer.allocUnsafe(9);
            geoBuff.writeInt8(1, 0);
            geoBuff.writeInt32LE(6, 1);
            break;
          case "GeometryCollection":
            geoBuff = Buffer.allocUnsafe(9);
            geoBuff.writeInt8(1, 0);
            geoBuff.writeInt32LE(7, 1);
            if (value.geometries && Array.isArray(value.geometries)) {
              const coordinateLength = value.geometries.length;
              const subArrays = [geoBuff];
              for (let i = 0; i < coordinateLength; i++) {
                const tmpBuf = this.getBufferFromGeometryValue(value.geometries[i]);
                if (tmpBuf == null) break;
                subArrays.push(tmpBuf);
              }
              geoBuff.writeInt32LE(subArrays.length - 1, 5);
              return Buffer.concat(subArrays);
            } else {
              geoBuff.writeInt32LE(0, 5);
              return geoBuff;
            }
          default:
            return null;
        }
        if (value.coordinates && Array.isArray(value.coordinates)) {
          const coordinateLength = value.coordinates.length;
          const subArrays = [geoBuff];
          for (let i = 0; i < coordinateLength; i++) {
            const tmpBuf = this.getBufferFromGeometryValue(value.coordinates[i], type2);
            if (tmpBuf == null) break;
            subArrays.push(tmpBuf);
          }
          geoBuff.writeInt32LE(subArrays.length - 1, 5);
          return Buffer.concat(subArrays);
        } else {
          geoBuff.writeInt32LE(0, 5);
          return geoBuff;
        }
      } else {
        switch (headerType) {
          case "MultiPoint":
            if (value && Array.isArray(value) && value.length >= 2 && !isNaN(value[0]) && !isNaN(value[1])) {
              geoBuff = Buffer.allocUnsafe(21);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(1, 1);
              geoBuff.writeDoubleLE(value[0], 5);
              geoBuff.writeDoubleLE(value[1], 13);
              return geoBuff;
            }
            return null;
          case "MultiLineString":
            if (value && Array.isArray(value)) {
              const pointNumber = value.length;
              geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(2, 1);
              geoBuff.writeInt32LE(pointNumber, 5);
              for (let i = 0; i < pointNumber; i++) {
                if (value[i] && Array.isArray(value[i]) && value[i].length >= 2 && !isNaN(value[i][0]) && !isNaN(value[i][1])) {
                  geoBuff.writeDoubleLE(value[i][0], 9 + 16 * i);
                  geoBuff.writeDoubleLE(value[i][1], 17 + 16 * i);
                } else {
                  return null;
                }
              }
              return geoBuff;
            }
            return null;
          case "MultiPolygon":
            if (value && Array.isArray(value)) {
              const numRings = value.length;
              let size = 0;
              for (let i = 0; i < numRings; i++) {
                size += 4 + 16 * value[i].length;
              }
              geoBuff = Buffer.allocUnsafe(9 + size);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(3, 1);
              geoBuff.writeInt32LE(numRings, 5);
              pos = 9;
              for (let i = 0; i < numRings; i++) {
                const lineString = value[i];
                if (lineString && Array.isArray(lineString)) {
                  geoBuff.writeInt32LE(lineString.length, pos);
                  pos += 4;
                  for (let j = 0; j < lineString.length; j++) {
                    if (lineString[j] && Array.isArray(lineString[j]) && lineString[j].length >= 2 && !isNaN(lineString[j][0]) && !isNaN(lineString[j][1])) {
                      geoBuff.writeDoubleLE(lineString[j][0], pos);
                      geoBuff.writeDoubleLE(lineString[j][1], pos + 8);
                      pos += 16;
                    } else {
                      return null;
                    }
                  }
                }
              }
              return geoBuff;
            }
            return null;
        }
        return null;
      }
    }
  }
  binaryEncoder = BinaryEncoder;
  return binaryEncoder;
}
var prepareWrapper;
var hasRequiredPrepareWrapper;
function requirePrepareWrapper() {
  var _closed, _cacheWrapper, _prepare, _conn;
  if (hasRequiredPrepareWrapper) return prepareWrapper;
  hasRequiredPrepareWrapper = 1;
  class PrepareWrapper {
    constructor(cacheWrapper, prepare2) {
      __privateAdd(this, _closed, false);
      __privateAdd(this, _cacheWrapper);
      __privateAdd(this, _prepare);
      __privateAdd(this, _conn);
      __privateSet(this, _cacheWrapper, cacheWrapper);
      __privateSet(this, _prepare, prepare2);
      __privateSet(this, _conn, prepare2.conn);
      this.execute = __privateGet(this, _prepare).execute;
      this.executeStream = __privateGet(this, _prepare).executeStream;
    }
    get conn() {
      return __privateGet(this, _conn);
    }
    get id() {
      return __privateGet(this, _prepare).id;
    }
    get parameterCount() {
      return __privateGet(this, _prepare).parameterCount;
    }
    get _placeHolderIndex() {
      return __privateGet(this, _prepare)._placeHolderIndex;
    }
    get columns() {
      return __privateGet(this, _prepare).columns;
    }
    set columns(columns) {
      __privateGet(this, _prepare).columns = columns;
    }
    get database() {
      return __privateGet(this, _prepare).database;
    }
    get query() {
      return __privateGet(this, _prepare).query;
    }
    isClose() {
      return __privateGet(this, _closed);
    }
    close() {
      if (!__privateGet(this, _closed)) {
        __privateSet(this, _closed, true);
        __privateGet(this, _cacheWrapper).decrementUse();
      }
    }
    toString() {
      return "PrepareWrapper{closed:" + __privateGet(this, _closed) + ",cache:" + __privateGet(this, _cacheWrapper) + "}";
    }
  }
  _closed = new WeakMap();
  _cacheWrapper = new WeakMap();
  _prepare = new WeakMap();
  _conn = new WeakMap();
  prepareWrapper = PrepareWrapper;
  return prepareWrapper;
}
var prepareCacheWrapper;
var hasRequiredPrepareCacheWrapper;
function requirePrepareCacheWrapper() {
  var _use, _cached, _prepare;
  if (hasRequiredPrepareCacheWrapper) return prepareCacheWrapper;
  hasRequiredPrepareCacheWrapper = 1;
  const PrepareWrapper = requirePrepareWrapper();
  class PrepareCacheWrapper {
    constructor(prepare2) {
      __privateAdd(this, _use, 0);
      __privateAdd(this, _cached);
      __privateAdd(this, _prepare);
      __privateSet(this, _prepare, prepare2);
      __privateSet(this, _cached, true);
    }
    incrementUse() {
      __privateSet(this, _use, __privateGet(this, _use) + 1);
      return new PrepareWrapper(this, __privateGet(this, _prepare));
    }
    unCache() {
      __privateSet(this, _cached, false);
      if (__privateGet(this, _use) === 0) {
        __privateGet(this, _prepare).close();
      }
    }
    decrementUse() {
      __privateSet(this, _use, __privateGet(this, _use) - 1);
      if (__privateGet(this, _use) === 0 && !__privateGet(this, _cached)) {
        __privateGet(this, _prepare).close();
      }
    }
    toString() {
      return "Prepare{use:" + __privateGet(this, _use) + ",cached:" + __privateGet(this, _cached) + "}";
    }
  }
  _use = new WeakMap();
  _cached = new WeakMap();
  _prepare = new WeakMap();
  prepareCacheWrapper = PrepareCacheWrapper;
  return prepareCacheWrapper;
}
var execute;
var hasRequiredExecute;
function requireExecute() {
  if (hasRequiredExecute) return execute;
  hasRequiredExecute = 1;
  const Parser = requireParser();
  const Errors = requireErrors();
  const BinaryEncoder = requireBinaryEncoder();
  const FieldType = requireFieldType();
  const Parse = requireParse$1();
  class Execute extends Parser {
    constructor(resolve, reject, connOpts, cmdParam, prepare2) {
      super(resolve, reject, connOpts, cmdParam);
      this.binary = true;
      this.prepare = prepare2;
      this.canSkipMeta = true;
    }
    /**
     * Send COM_QUERY
     *
     * @param out   output writer
     * @param opts  connection options
     * @param info  connection information
     */
    start(out2, opts, info) {
      this.onPacketReceive = this.readResponsePacket;
      this.values = [];
      if (this.opts.namedPlaceholders) {
        if (this.prepare) {
          this.values = new Array(this.prepare.parameterCount);
          this.placeHolderIndex = this.prepare._placeHolderIndex;
        } else {
          const res = Parse.searchPlaceholder(this.sql);
          this.placeHolderIndex = res.placeHolderIndex;
          this.values = new Array(this.placeHolderIndex.length);
        }
        if (this.initialValues) {
          for (let i = 0; i < this.placeHolderIndex.length; i++) {
            this.values[i] = this.initialValues[this.placeHolderIndex[i]];
          }
        }
      } else {
        if (this.initialValues)
          this.values = Array.isArray(this.initialValues) ? this.initialValues : [this.initialValues];
      }
      this.parameterCount = this.prepare ? this.prepare.parameterCount : this.values.length;
      if (!this.validateParameters(info)) return;
      this.parametersType = new Array(this.parameterCount);
      let hasLongData = false;
      let val;
      for (let i = 0; i < this.parameterCount; i++) {
        val = this.values[i];
        if (val && val.type != null && [
          "Point",
          "LineString",
          "Polygon",
          "MultiPoint",
          "MultiLineString",
          "MultiPolygon",
          "GeometryCollection"
        ].includes(val.type)) {
          const geoBuff = BinaryEncoder.getBufferFromGeometryValue(val);
          if (geoBuff == null) {
            this.values[i] = null;
            val = null;
          } else {
            this.values[i] = Buffer.concat([
              Buffer.from([0, 0, 0, 0]),
              // SRID
              geoBuff
              // WKB
            ]);
            val = this.values[i];
          }
        }
        if (val == null) {
          this.parametersType[i] = NULL_PARAM_TYPE;
        } else {
          switch (typeof val) {
            case "boolean":
              this.parametersType[i] = BOOLEAN_TYPE;
              break;
            case "bigint":
              if (val >= 2n ** 63n) {
                this.parametersType[i] = BIG_BIGINT_TYPE;
              } else {
                this.parametersType[i] = BIGINT_TYPE;
              }
              break;
            case "number":
              if (Number.isInteger(val) && val >= -2147483648 && val < 2147483647) {
                this.parametersType[i] = INT_TYPE;
                break;
              }
              this.parametersType[i] = DOUBLE_TYPE;
              break;
            case "string":
              this.parametersType[i] = STRING_TYPE;
              break;
            case "object":
              if (Object.prototype.toString.call(val) === "[object Date]") {
                this.parametersType[i] = DATE_TYPE;
              } else if (Buffer.isBuffer(val)) {
                if (val.length < 16384 || !this.prepare) {
                  this.parametersType[i] = BLOB_TYPE;
                } else {
                  this.parametersType[i] = LONGBLOB_TYPE;
                  hasLongData = true;
                }
              } else if (typeof val.toSqlString === "function") {
                this.parametersType[i] = STRING_FCT_TYPE;
              } else if (typeof val.pipe === "function" && typeof val.read === "function") {
                hasLongData = true;
                this.parametersType[i] = STREAM_TYPE;
              } else if (String === val.constructor) {
                this.parametersType[i] = STRING_TOSTR_TYPE;
              } else {
                this.parametersType[i] = STRINGIFY_TYPE;
              }
              break;
          }
        }
      }
      this.longDataStep = false;
      if (hasLongData) {
        for (let i = 0; i < this.parameterCount; i++) {
          if (this.parametersType[i].isLongData()) {
            if (opts.logger.query)
              opts.logger.query(
                `EXECUTE: (${this.prepare ? this.prepare.id : -1}) sql: ${opts.logParam ? this.displaySql() : this.sql}`
              );
            if (!this.longDataStep) {
              this.longDataStep = true;
              this.registerStreamSendEvent(out2, info);
              this.currentParam = i;
            }
            this.sendComStmtLongData(out2, info, this.values[i]);
            return;
          }
        }
      }
      if (!this.longDataStep) {
        if (opts.logger.query)
          opts.logger.query(
            `EXECUTE: (${this.prepare ? this.prepare.id : -1}) sql: ${opts.logParam ? this.displaySql() : this.sql}`
          );
        this.sendComStmtExecute(out2, info);
      }
    }
    /**
     * Validate that parameters exists and are defined.
     *
     * @param info        connection info
     * @returns {boolean} return false if any error occur.
     */
    validateParameters(info) {
      if (this.parameterCount > this.values.length) {
        this.sendCancelled(
          `Parameter at position ${this.values.length} is not set\\nsql: ${this.opts.logParam ? this.displaySql() : this.sql}`,
          Errors.ER_MISSING_PARAMETER,
          info
        );
        return false;
      }
      if (this.opts.namedPlaceholders && this.placeHolderIndex) {
        for (let i = 0; i < this.parameterCount; i++) {
          if (this.values[i] === void 0) {
            let errMsg = `Parameter named ${this.placeHolderIndex[i]} is not set`;
            if (this.placeHolderIndex.length < this.parameterCount) {
              errMsg = `Command expect ${this.parameterCount} parameters, but found only ${this.placeHolderIndex.length} named parameters. You probably use question mark in place of named parameters`;
            }
            this.sendCancelled(errMsg, Errors.ER_PARAMETER_UNDEFINED, info);
            return false;
          }
        }
      }
      return true;
    }
    sendComStmtLongData(out2, info, value) {
      out2.startPacket(this);
      out2.writeInt8(24);
      out2.writeInt32(this.prepare.id);
      out2.writeInt16(this.currentParam);
      if (Buffer.isBuffer(value)) {
        out2.writeBuffer(value, 0, value.length);
        out2.flush();
        this.currentParam++;
        return this.paramWritten();
      }
      this.sending = true;
      value.on("data", function(chunk) {
        out2.writeBuffer(chunk, 0, chunk.length);
      });
      value.on(
        "end",
        (function() {
          out2.flush();
          this.currentParam++;
          this.paramWritten();
        }).bind(this)
      );
    }
    /**
     * Send a COM_STMT_EXECUTE
     * @param out
     * @param info
     */
    sendComStmtExecute(out2, info) {
      let nullCount = ~~((this.parameterCount + 7) / 8);
      const nullBitsBuffer = Buffer.alloc(nullCount);
      for (let i = 0; i < this.parameterCount; i++) {
        if (this.values[i] == null) {
          nullBitsBuffer[~~(i / 8)] |= 1 << i % 8;
        }
      }
      out2.startPacket(this);
      out2.writeInt8(23);
      out2.writeInt32(this.prepare ? this.prepare.id : -1);
      out2.writeInt8(0);
      out2.writeInt32(1);
      out2.writeBuffer(nullBitsBuffer, 0, nullCount);
      out2.writeInt8(1);
      for (let i = 0; i < this.parameterCount; i++) {
        out2.writeInt8(this.parametersType[i].type);
        out2.writeInt8(0);
      }
      for (let i = 0; i < this.parameterCount; i++) {
        const parameterType = this.parametersType[i];
        if (parameterType.encoder) parameterType.encoder(out2, this.values[i]);
      }
      out2.flush();
      this.sending = false;
      this.emit("send_end");
    }
    /**
     * Define params events.
     * Each parameter indicate that he is written to socket,
     * emitting event so next stream parameter can be written.
     */
    registerStreamSendEvent(out2, info) {
      this.paramWritten = (function() {
        if (this.longDataStep) {
          for (; this.currentParam < this.parameterCount; this.currentParam++) {
            if (this.parametersType[this.currentParam].isLongData()) {
              const value = this.values[this.currentParam];
              this.sendComStmtLongData(out2, info, value);
              return;
            }
          }
          this.longDataStep = false;
        }
        if (!this.longDataStep) {
          this.sendComStmtExecute(out2, info);
        }
      }).bind(this);
    }
  }
  class ParameterType {
    constructor(type2, encoder, pipe = false, isNull = false) {
      this.pipe = pipe;
      this.type = type2;
      this.encoder = encoder;
      this.isNull = isNull;
    }
    isLongData() {
      return this.encoder === null && !this.isNull;
    }
  }
  const NULL_PARAM_TYPE = new ParameterType(FieldType.VAR_STRING, null, false, true);
  const BOOLEAN_TYPE = new ParameterType(FieldType.TINY, (out2, value) => out2.writeInt8(value ? 1 : 0));
  const BIG_BIGINT_TYPE = new ParameterType(
    FieldType.NEWDECIMAL,
    (out2, value) => out2.writeLengthEncodedString(value.toString())
  );
  const BIGINT_TYPE = new ParameterType(FieldType.BIGINT, (out2, value) => out2.writeBigInt(value));
  const INT_TYPE = new ParameterType(FieldType.INT, (out2, value) => out2.writeInt32(value));
  const DOUBLE_TYPE = new ParameterType(FieldType.DOUBLE, (out2, value) => out2.writeDouble(value));
  const STRING_TYPE = new ParameterType(FieldType.VAR_STRING, (out2, value) => out2.writeLengthEncodedString(value));
  const STRING_TOSTR_TYPE = new ParameterType(
    FieldType.VAR_STRING,
    (out2, value) => out2.writeLengthEncodedString(value.toString())
  );
  const DATE_TYPE = new ParameterType(FieldType.DATETIME, (out2, value) => out2.writeBinaryDate(value));
  const BLOB_TYPE = new ParameterType(FieldType.BLOB, (out2, value) => out2.writeLengthEncodedBuffer(value));
  const LONGBLOB_TYPE = new ParameterType(FieldType.BLOB, null);
  const STRING_FCT_TYPE = new ParameterType(
    FieldType.VAR_STRING,
    (out2, value) => out2.writeLengthEncodedString(String(value.toSqlString()))
  );
  const STREAM_TYPE = new ParameterType(FieldType.BLOB, null, true);
  const STRINGIFY_TYPE = new ParameterType(
    FieldType.VAR_STRING,
    (out2, value) => out2.writeLengthEncodedString(JSON.stringify(value))
  );
  execute = Execute;
  return execute;
}
var executeStream;
var hasRequiredExecuteStream;
function requireExecuteStream() {
  if (hasRequiredExecuteStream) return executeStream;
  hasRequiredExecuteStream = 1;
  const Execute = requireExecute();
  const { Readable } = require$$0$4;
  class ExecuteStream extends Execute {
    constructor(cmdParam, connOpts, prepare2, socket) {
      super(
        () => {
        },
        () => {
        },
        connOpts,
        cmdParam,
        prepare2
      );
      this.socket = socket;
      this.inStream = new Readable({
        objectMode: true,
        read: () => {
          this.socket.resume();
        }
      });
      this.on("fields", function(meta) {
        this.inStream.emit("fields", meta);
      });
      this.on("error", function(err) {
        this.inStream.emit("error", err);
      });
      this.on("close", function(err) {
        this.inStream.emit("error", err);
      });
      this.on("end", function(err) {
        if (err) this.inStream.emit("error", err);
        this.socket.resume();
        this.inStream.push(null);
      });
      this.inStream.close = (function() {
        this.handleNewRows = () => {
        };
        this.socket.resume();
      }).bind(this);
    }
    handleNewRows(row) {
      if (!this.inStream.push(row)) {
        this.socket.pause();
      }
    }
  }
  executeStream = ExecuteStream;
  return executeStream;
}
var prepareResultPacket;
var hasRequiredPrepareResultPacket;
function requirePrepareResultPacket() {
  var _conn;
  if (hasRequiredPrepareResultPacket) return prepareResultPacket;
  hasRequiredPrepareResultPacket = 1;
  const Errors = requireErrors();
  const ExecuteStream = requireExecuteStream();
  const Parser = requireParser();
  class PrepareResultPacket {
    constructor(statementId, parameterCount, columns, database, sql, placeHolderIndex, conn) {
      __privateAdd(this, _conn);
      this.id = statementId;
      this.parameterCount = parameterCount;
      this.columns = columns;
      this.database = database;
      this.query = sql;
      this.closed = false;
      this._placeHolderIndex = placeHolderIndex;
      __privateSet(this, _conn, conn);
    }
    get conn() {
      return __privateGet(this, _conn);
    }
    execute(values, opts, cb, stack) {
      let _opts = opts, _cb = cb;
      if (typeof _opts === "function") {
        _cb = _opts;
        _opts = void 0;
      }
      if (this.isClose()) {
        let sql = this.query;
        if (this.conn.opts.logParam) {
          if (this.query.length > this.conn.opts.debugLen) {
            sql = this.query.substring(0, this.conn.opts.debugLen) + "...";
          } else {
            let sqlMsg = this.query + " - parameters:";
            sql = Parser.logParameters(this.conn.opts, sqlMsg, values);
          }
        }
        const error2 = Errors.createError(
          `Execute fails, prepare command as already been closed`,
          Errors.ER_PREPARE_CLOSED,
          null,
          "22000",
          sql
        );
        if (!_cb) {
          return Promise.reject(error2);
        } else {
          _cb(error2);
          return;
        }
      }
      const cmdParam = {
        sql: this.query,
        values,
        opts: _opts,
        callback: _cb
      };
      if (stack) cmdParam.stack = stack;
      const conn = this.conn;
      const promise2 = new Promise((resolve, reject) => conn.executePromise.call(conn, cmdParam, this, resolve, reject));
      if (!_cb) {
        return promise2;
      } else {
        promise2.then((res) => {
          if (_cb) _cb(null, res, null);
        }).catch(_cb || function(err) {
        });
      }
    }
    executeStream(values, opts, cb, stack) {
      let _opts = opts, _cb = cb;
      if (typeof _opts === "function") {
        _cb = _opts;
        _opts = void 0;
      }
      if (this.isClose()) {
        const error2 = Errors.createError(
          `Execute fails, prepare command as already been closed`,
          Errors.ER_PREPARE_CLOSED,
          null,
          "22000",
          this.query
        );
        if (!_cb) {
          throw error2;
        } else {
          _cb(error2);
          return;
        }
      }
      const cmdParam = {
        sql: this.query,
        values,
        opts: _opts,
        callback: _cb
      };
      if (stack) cmdParam.stack = stack;
      const cmd = new ExecuteStream(cmdParam, this.conn.opts, this, this.conn.socket);
      if (this.conn.opts.logger.error) cmd.on("error", this.conn.opts.logger.error);
      this.conn.addCommand(cmd, true);
      return cmd.inStream;
    }
    isClose() {
      return this.closed;
    }
    close() {
      if (!this.closed) {
        this.closed = true;
        __privateGet(this, _conn).emit("close_prepare", this);
      }
    }
    toString() {
      return "Prepare{closed:" + this.closed + "}";
    }
  }
  _conn = new WeakMap();
  prepareResultPacket = PrepareResultPacket;
  return prepareResultPacket;
}
var prepare;
var hasRequiredPrepare;
function requirePrepare() {
  if (hasRequiredPrepare) return prepare;
  hasRequiredPrepare = 1;
  const Parser = requireParser();
  const Parse = requireParse$1();
  const BinaryEncoder = requireBinaryEncoder();
  const PrepareCacheWrapper = requirePrepareCacheWrapper();
  const PrepareResult = requirePrepareResultPacket();
  const ServerStatus = requireServerStatus();
  const Errors = requireErrors();
  const ColumnDefinition = requireColumnDefinition();
  class Prepare extends Parser {
    constructor(resolve, reject, connOpts, cmdParam, conn) {
      super(resolve, reject, connOpts, cmdParam);
      this.encoder = new BinaryEncoder(this.opts);
      this.binary = true;
      this.conn = conn;
      this.executeCommand = cmdParam.executeCommand;
    }
    /**
     * Send COM_STMT_PREPARE
     *
     * @param out   output writer
     * @param opts  connection options
     * @param info  connection information
     */
    start(out2, opts, info) {
      if (this.conn.prepareCache) {
        let cachedPrepare = this.conn.prepareCache.get(this.sql);
        if (cachedPrepare) {
          this.emit("send_end");
          return this.successEnd(cachedPrepare);
        }
      }
      if (opts.logger.query) opts.logger.query(`PREPARE: ${this.sql}`);
      this.onPacketReceive = this.readPrepareResultPacket;
      if (this.opts.namedPlaceholders) {
        const res = Parse.searchPlaceholder(this.sql);
        this.sql = res.sql;
        this.placeHolderIndex = res.placeHolderIndex;
      }
      out2.startPacket(this);
      out2.writeInt8(22);
      out2.writeString(this.sql);
      out2.flush();
      this.emit("send_end");
    }
    successPrepare(info, opts) {
      let prepare2 = new PrepareResult(
        this.statementId,
        this.parameterCount,
        this._columns,
        info.database,
        this.sql,
        this.placeHolderIndex,
        this.conn
      );
      if (this.conn.prepareCache) {
        let cached = new PrepareCacheWrapper(prepare2);
        this.conn.prepareCache.set(this.sql, cached);
        const cachedWrappedPrepared = cached.incrementUse();
        if (this.executeCommand) this.executeCommand.prepare = cachedWrappedPrepared;
        return this.successEnd(cachedWrappedPrepared);
      }
      if (this.executeCommand) this.executeCommand.prepare = prepare2;
      this.successEnd(prepare2);
    }
    /**
     * Read COM_STMT_PREPARE response Packet.
     * see https://mariadb.com/kb/en/library/com_stmt_prepare/#com_stmt_prepare-response
     *
     * @param packet    COM_STMT_PREPARE_OK packet
     * @param opts      connection options
     * @param info      connection information
     * @param out       output writer
     * @returns {*}     null or {Result.readResponsePacket} in case of multi-result-set
     */
    readPrepareResultPacket(packet2, out2, opts, info) {
      switch (packet2.peek()) {
        //*********************************************************************************************************
        //* PREPARE response
        //*********************************************************************************************************
        case 0:
          packet2.skip(1);
          this.statementId = packet2.readInt32();
          this.columnNo = packet2.readUInt16();
          this.parameterCount = packet2.readUInt16();
          this._parameterNo = this.parameterCount;
          this._columns = [];
          if (this._parameterNo > 0) return this.onPacketReceive = this.skipPrepareParameterPacket;
          if (this.columnNo > 0) return this.onPacketReceive = this.readPrepareColumnsPacket;
          return this.successPrepare(info, opts);
        //*********************************************************************************************************
        //* ERROR response
        //*********************************************************************************************************
        case 255:
          const err = packet2.readError(info, this.displaySql(), this.stack);
          info.status |= ServerStatus.STATUS_IN_TRANS;
          this.onPacketReceive = this.readResponsePacket;
          return this.throwError(err, info);
        //*********************************************************************************************************
        //* Unexpected response
        //*********************************************************************************************************
        default:
          info.status |= ServerStatus.STATUS_IN_TRANS;
          this.onPacketReceive = this.readResponsePacket;
          return this.throwError(Errors.ER_UNEXPECTED_PACKET, info);
      }
    }
    readPrepareColumnsPacket(packet2, out2, opts, info) {
      this.columnNo--;
      this._columns.push(new ColumnDefinition(packet2, info, opts.rowsAsArray));
      if (this.columnNo === 0) {
        if (info.eofDeprecated) {
          return this.successPrepare(info, opts);
        }
        this.onPacketReceive = this.skipEofPacket;
      }
    }
    skipEofPacket(packet2, out2, opts, info) {
      if (this.columnNo > 0) return this.onPacketReceive = this.readPrepareColumnsPacket;
      this.successPrepare(info, opts);
    }
    skipPrepareParameterPacket(packet2, out2, opts, info) {
      this._parameterNo--;
      if (this._parameterNo === 0) {
        if (info.eofDeprecated) {
          if (this.columnNo > 0) return this.onPacketReceive = this.readPrepareColumnsPacket;
          return this.successPrepare(info, opts);
        }
        this.onPacketReceive = this.skipEofPacket;
      }
    }
    /**
     * Display current SQL with parameters (truncated if too big)
     *
     * @returns {string}
     */
    displaySql() {
      if (this.opts) {
        if (this.sql.length > this.opts.debugLen) {
          return this.sql.substring(0, this.opts.debugLen) + "...";
        }
      }
      return this.sql;
    }
  }
  prepare = Prepare;
  return prepare;
}
var closePrepare;
var hasRequiredClosePrepare;
function requireClosePrepare() {
  if (hasRequiredClosePrepare) return closePrepare;
  hasRequiredClosePrepare = 1;
  const Command = requireCommand();
  class ClosePrepare extends Command {
    constructor(cmdParam, resolve, reject, prepare2) {
      super(cmdParam, resolve, reject);
      this.prepare = prepare2;
    }
    start(out2, opts, info) {
      if (opts.logger.query) opts.logger.query(`CLOSE PREPARE: (${this.prepare.id}) ${this.prepare.query}`);
      const closeCmd = new Uint8Array([
        5,
        0,
        0,
        0,
        25,
        this.prepare.id,
        this.prepare.id >> 8,
        this.prepare.id >> 16,
        this.prepare.id >> 24
      ]);
      out2.fastFlush(this, closeCmd);
      this.onPacketReceive = null;
      this.emit("send_end");
      this.emit("end");
    }
  }
  closePrepare = ClosePrepare;
  return closePrepare;
}
var batchBulk;
var hasRequiredBatchBulk;
function requireBatchBulk() {
  if (hasRequiredBatchBulk) return batchBulk;
  hasRequiredBatchBulk = 1;
  const Parser = requireParser();
  const Errors = requireErrors();
  const BinaryEncoder = requireBinaryEncoder();
  const FieldType = requireFieldType();
  const OkPacket = requireOkPacket();
  class BatchBulk extends Parser {
    constructor(resolve, reject, connOpts, prepare2, cmdParam) {
      super(resolve, reject, connOpts, cmdParam);
      this.cmdOpts = cmdParam.opts;
      this.binary = true;
      this.prepare = prepare2;
      this.canSkipMeta = true;
    }
    /**
     * Send COM_STMT_BULK_EXECUTE
     *
     * @param out   output writer
     * @param opts  connection options
     * @param info  connection information
     */
    start(out2, opts, info) {
      this.info = info;
      this.values = this.initialValues;
      if (this.cmdOpts && this.cmdOpts.timeout) {
        this.bulkPacketNo = 1;
        this.sending = false;
        return this.sendCancelled("Cannot use timeout for Batch statement", Errors.ER_TIMEOUT_NOT_SUPPORTED);
      }
      this.onPacketReceive = this.readResponsePacket;
      if (this.opts.namedPlaceholders && this.prepare._placeHolderIndex) {
        this.values = [];
        if (this.initialValues) {
          for (let r = 0; r < this.initialValues.length; r++) {
            let val = this.initialValues[r];
            this.values[r] = new Array(this.prepare.parameterCount);
            for (let i = 0; i < this.prepare._placeHolderIndex.length; i++) {
              this.values[r][i] = val[this.prepare._placeHolderIndex[i]];
            }
          }
        }
      } else {
        this.values = this.initialValues;
      }
      if (!this.validateParameters(info)) return;
      this.sendComStmtBulkExecute(out2, opts, info);
    }
    /**
     * Set header type
     * @param value current value
     * @param parameterCount parameter number
     * @returns {*[]} header type array
     */
    parameterHeaderFromValue(value, parameterCount) {
      const parameterHeaderType = new Array(parameterCount);
      for (let i = 0; i < parameterCount; i++) {
        const val = value[i];
        if (val != null) {
          switch (typeof val) {
            case "boolean":
              parameterHeaderType[i] = FieldType.TINY;
              break;
            case "bigint":
              if (val >= 2n ** 63n) {
                parameterHeaderType[i] = FieldType.NEWDECIMAL;
              } else {
                parameterHeaderType[i] = FieldType.BIGINT;
              }
              break;
            case "number":
              if (Number.isInteger(val) && val >= -2147483648 && val < 2147483647) {
                parameterHeaderType[i] = FieldType.INT;
                break;
              }
              parameterHeaderType[i] = FieldType.DOUBLE;
              break;
            case "string":
              parameterHeaderType[i] = FieldType.VAR_STRING;
              break;
            case "object":
              if (Object.prototype.toString.call(val) === "[object Date]") {
                parameterHeaderType[i] = FieldType.DATETIME;
              } else if (Buffer.isBuffer(val)) {
                parameterHeaderType[i] = FieldType.BLOB;
              } else if (typeof val.toSqlString === "function") {
                parameterHeaderType[i] = FieldType.VAR_STRING;
              } else {
                if (val.type != null && [
                  "Point",
                  "LineString",
                  "Polygon",
                  "MultiPoint",
                  "MultiLineString",
                  "MultiPolygon",
                  "GeometryCollection"
                ].includes(val.type)) {
                  parameterHeaderType[i] = FieldType.BLOB;
                } else {
                  parameterHeaderType[i] = FieldType.VAR_STRING;
                }
              }
              break;
            default:
              parameterHeaderType[i] = FieldType.BLOB;
              break;
          }
        } else {
          parameterHeaderType[i] = FieldType.VAR_STRING;
        }
      }
      return parameterHeaderType;
    }
    /**
     * Check current value has same header than set in initial BULK header
     *
     * @param parameterHeaderType current header
     * @param value current value
     * @param parameterCount number of parameter
     * @returns {boolean} true if identical
     */
    checkSameHeader(parameterHeaderType, value, parameterCount) {
      let val;
      for (let i = 0; i < parameterCount; i++) {
        if ((val = value[i]) != null) {
          switch (typeof val) {
            case "boolean":
              if (parameterHeaderType[i] !== FieldType.TINY) return false;
              break;
            case "bigint":
              if (val >= 2n ** 63n) {
                if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
              } else {
                if (parameterHeaderType[i] !== FieldType.BIGINT) return false;
              }
              break;
            case "number":
              if (Number.isInteger(val) && val >= -2147483648 && val < 2147483647) {
                if (parameterHeaderType[i] !== FieldType.INT) return false;
                break;
              }
              if (parameterHeaderType[i] !== FieldType.DOUBLE) return false;
              break;
            case "string":
              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
              break;
            case "object":
              if (Object.prototype.toString.call(val) === "[object Date]") {
                if (parameterHeaderType[i] !== FieldType.TIMESTAMP) return false;
              } else if (Buffer.isBuffer(val)) {
                if (parameterHeaderType[i] !== FieldType.BLOB) return false;
              } else if (typeof val.toSqlString === "function") {
                if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
              } else {
                if (val.type != null && [
                  "Point",
                  "LineString",
                  "Polygon",
                  "MultiPoint",
                  "MultiLineString",
                  "MultiPolygon",
                  "GeometryCollection"
                ].includes(val.type)) {
                  if (parameterHeaderType[i] !== FieldType.BLOB) return false;
                } else {
                  if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
                }
              }
              break;
            default:
              if (parameterHeaderType[i] !== FieldType.BLOB) return false;
              break;
          }
        }
      }
      return true;
    }
    /**
     * Send a COM_STMT_BULK_EXECUTE
     * @param out output packet writer
     * @param opts options
     * @param info information
     */
    sendComStmtBulkExecute(out2, opts, info) {
      if (opts.logger.query)
        opts.logger.query(`BULK: (${this.prepare.id}) sql: ${opts.logParam ? this.displaySql() : this.sql}`);
      const parameterCount = this.prepare.parameterCount;
      this.rowIdx = 0;
      this.vals = this.values[this.rowIdx++];
      let parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);
      let lastCmdData = null;
      this.bulkPacketNo = 0;
      this.sending = true;
      main_loop: while (true) {
        this.bulkPacketNo++;
        out2.startPacket(this);
        out2.writeInt8(250);
        out2.writeInt32(this.prepare.id);
        out2.writeInt16(128);
        for (let i = 0; i < parameterCount; i++) {
          out2.writeInt16(parameterHeaderType[i]);
        }
        if (lastCmdData != null) {
          const err = out2.checkMaxAllowedLength(lastCmdData.length, info);
          if (err) {
            this.sending = false;
            this.throwError(err, info);
            return;
          }
          out2.writeBuffer(lastCmdData, 0, lastCmdData.length);
          out2.mark();
          lastCmdData = null;
          if (this.rowIdx >= this.values.length) {
            break;
          }
          this.vals = this.values[this.rowIdx++];
        }
        parameter_loop: while (true) {
          for (let i = 0; i < parameterCount; i++) {
            let param = this.vals[i];
            if (param != null) {
              if (param.type != null && [
                "Point",
                "LineString",
                "Polygon",
                "MultiPoint",
                "MultiLineString",
                "MultiPolygon",
                "GeometryCollection"
              ].includes(param.type)) {
                const geoBuff = BinaryEncoder.getBufferFromGeometryValue(param);
                if (geoBuff == null) {
                  out2.writeInt8(1);
                } else {
                  out2.writeInt8(0);
                  param = Buffer.concat([
                    Buffer.from([0, 0, 0, 0]),
                    // SRID
                    geoBuff
                    // WKB
                  ]);
                  BinaryEncoder.writeParam(out2, param, this.opts, info);
                }
              } else {
                out2.writeInt8(0);
                BinaryEncoder.writeParam(out2, param, this.opts, info);
              }
            } else {
              out2.writeInt8(1);
            }
          }
          if (!out2.bufIsDataAfterMark() && !out2.isMarked() && out2.hasFlushed()) {
            out2.flush();
            if (!this.rowIdx >= this.values.length) {
              break main_loop;
            }
            this.vals = this.values[this.rowIdx++];
            parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);
            break parameter_loop;
          }
          if (out2.isMarked() && out2.bufIsAfterMaxPacketLength()) {
            out2.flushBufferStopAtMark();
            out2.mark();
            lastCmdData = out2.resetMark();
            break;
          }
          out2.mark();
          if (out2.bufIsDataAfterMark()) {
            lastCmdData = out2.resetMark();
            break;
          }
          if (this.rowIdx >= this.values.length) {
            break main_loop;
          }
          this.vals = this.values[this.rowIdx++];
          if (!this.checkSameHeader(parameterHeaderType, this.vals, parameterCount)) {
            out2.flush();
            parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);
            break parameter_loop;
          }
        }
      }
      out2.flush();
      this.sending = false;
      this.emit("send_end");
    }
    displaySql() {
      if (this.sql.length > this.opts.debugLen) {
        return this.sql.substring(0, this.opts.debugLen) + "...";
      }
      let sqlMsg = this.sql + " - parameters:[";
      for (let i = 0; i < this.initialValues.length; i++) {
        if (i !== 0) sqlMsg += ",";
        let param = this.initialValues[i];
        sqlMsg = Parser.logParameters(this.opts, sqlMsg, param);
        if (sqlMsg.length > this.opts.debugLen) {
          return sqlMsg.substring(0, this.opts.debugLen) + "...";
        }
      }
      sqlMsg += "]";
      return sqlMsg;
    }
    success(val) {
      this.bulkPacketNo--;
      if (this._responseIndex === 0) {
        if (this.opts.metaAsArray) {
          if (val[0] instanceof OkPacket) this._rows.push(val[0]);
        } else if (val instanceof OkPacket) this._rows.push(val);
      }
      if (!this.sending && this.bulkPacketNo === 0) {
        this.packet = null;
        if (this.firstError) {
          this.resolve = null;
          this.onPacketReceive = null;
          this._columns = null;
          this._rows = null;
          process.nextTick(this.reject, this.firstError);
          this.reject = null;
          this.emit("end", this.firstError);
        } else {
          if (this._rows[0].affectedRows !== void 0) {
            let totalAffectedRows = 0;
            this._rows.forEach((row) => {
              totalAffectedRows += row.affectedRows;
            });
            const rs = new OkPacket(
              totalAffectedRows,
              this._rows[0].insertId,
              this._rows[this._rows.length - 1].warningStatus
            );
            this.successEnd(this.opts.metaAsArray ? [rs, []] : rs);
          } else {
            if (this._rows.length === 1) {
              this.successEnd(this.opts.metaAsArray ? [this._rows[0], this._columns] : this._rows[0]);
            }
            if (this.opts.metaAsArray) {
              if (this._rows.length === 1) {
                this.successEnd([this._rows[0], this._columns]);
              } else {
                const rs = [];
                this._rows.forEach((row) => {
                  rs.push(...row);
                });
                this.successEnd([rs, this._columns]);
              }
            } else {
              if (this._rows.length === 1) {
                this.successEnd(this._rows[0]);
              } else {
                const rs = [];
                this._rows.forEach((row) => {
                  rs.push(...row);
                });
                Object.defineProperty(rs, "meta", {
                  value: this._columns,
                  writable: true,
                  enumerable: this.opts.metaEnumerable
                });
                this.successEnd(rs);
              }
            }
          }
          this._columns = null;
          this._rows = null;
        }
        return;
      }
      if (!this.firstError) {
        this._responseIndex++;
        this.onPacketReceive = this.readResponsePacket;
      }
    }
    throwError(err, info) {
      this.bulkPacketNo--;
      if (!this.firstError) {
        if (err.fatal) {
          this.bulkPacketNo = 0;
        }
        if (this.cmdParam.stack) {
          err = Errors.createError(
            err.message,
            err.errno,
            info,
            err.sqlState,
            this.sql,
            err.fatal,
            this.cmdParam.stack,
            false
          );
        }
        this.firstError = err;
      }
      if (!this.sending && this.bulkPacketNo === 0) {
        this.resolve = null;
        this.emit("send_end");
        process.nextTick(this.reject, this.firstError);
        this.reject = null;
        this.onPacketReceive = null;
        this.emit("end", this.firstError);
      } else {
        this._responseIndex++;
        this.onPacketReceive = this.readResponsePacket;
      }
    }
    /**
     * Validate that parameters exists and are defined.
     *
     * @param info        connection info
     * @returns {boolean} return false if any error occur.
     */
    validateParameters(info) {
      const nbParameter = this.prepare.parameterCount;
      for (let r = 0; r < this.values.length; r++) {
        if (!Array.isArray(this.values[r])) this.values[r] = [this.values[r]];
        if (this.values[r].length < nbParameter) {
          this.emit("send_end");
          this.throwNewError(
            `Expect ${nbParameter} parameters, but at index ${r}, parameters only contains ${this.values[r].length}
 ${this.opts.logParam ? this.displaySql() : this.sql}`,
            false,
            info,
            "HY000",
            Errors.ER_PARAMETER_UNDEFINED
          );
          return false;
        }
      }
      return true;
    }
  }
  batchBulk = BatchBulk;
  return batchBulk;
}
var changeUser;
var hasRequiredChangeUser;
function requireChangeUser() {
  if (hasRequiredChangeUser) return changeUser;
  hasRequiredChangeUser = 1;
  const Iconv = requireLib$1();
  const Capabilities = requireCapabilities();
  const Ed25519PasswordAuth = requireEd25519PasswordAuth();
  const NativePasswordAuth = requireNativePasswordAuth();
  const Collations = requireCollations();
  const Authentication = requireAuthentication();
  class ChangeUser extends Authentication {
    constructor(cmdParam, connOpts, resolve, reject, getSocket) {
      super(cmdParam, resolve, reject, () => {
      }, getSocket);
      this.configAssign(connOpts, cmdParam.opts);
    }
    start(out2, opts, info) {
      if (opts.logger.query) opts.logger.query(`CHANGE USER to '${this.opts.user || ""}'`);
      let authToken;
      const pwd = Array.isArray(this.opts.password) ? this.opts.password[0] : this.opts.password;
      switch (info.defaultPluginName) {
        case "mysql_native_password":
        case "":
          authToken = NativePasswordAuth.encryptSha1Password(pwd, info.seed);
          break;
        case "client_ed25519":
          authToken = Ed25519PasswordAuth.encryptPassword(pwd, info.seed);
          break;
        default:
          authToken = Buffer.alloc(0);
          break;
      }
      out2.startPacket(this);
      out2.writeInt8(17);
      out2.writeString(this.opts.user || "");
      out2.writeInt8(0);
      if (info.serverCapabilities & Capabilities.SECURE_CONNECTION) {
        out2.writeInt8(authToken.length);
        out2.writeBuffer(authToken, 0, authToken.length);
      } else {
        out2.writeBuffer(authToken, 0, authToken.length);
        out2.writeInt8(0);
      }
      if (info.clientCapabilities & Capabilities.CONNECT_WITH_DB) {
        out2.writeString(this.opts.database);
        out2.writeInt8(0);
        info.database = this.opts.database;
      }
      if (this.opts.collation) {
        if (!this.opts.charset || info.collation.charset !== this.opts.collation.charset) {
          info.collation = this.opts.collation;
        }
      } else {
        if (info.collation.charset !== "utf8" || info.collation.maxLength === 3) {
          info.collation = Collations.fromIndex(224);
        }
      }
      out2.writeInt16(info.collation.index);
      if (info.clientCapabilities & Capabilities.PLUGIN_AUTH) {
        out2.writeString(info.defaultPluginName);
        out2.writeInt8(0);
      }
      if (info.clientCapabilities & Capabilities.CONNECT_ATTRS) {
        out2.writeInt8(252);
        let initPos = out2.pos;
        out2.writeInt16(0);
        const encoding = info.collation.charset;
        writeAttribute(out2, "_client_name", encoding);
        writeAttribute(out2, "MariaDB connector/Node", encoding);
        let packageJson2 = require$$8;
        writeAttribute(out2, "_client_version", encoding);
        writeAttribute(out2, packageJson2.version, encoding);
        writeAttribute(out2, "_node_version", encoding);
        writeAttribute(out2, process.versions.node, encoding);
        if (opts.connectAttributes !== true) {
          let attrNames = Object.keys(this.opts.connectAttributes);
          for (let k = 0; k < attrNames.length; ++k) {
            writeAttribute(out2, attrNames[k], encoding);
            writeAttribute(out2, this.opts.connectAttributes[attrNames[k]], encoding);
          }
        }
        out2.writeInt16AtPos(initPos);
      }
      out2.flush();
      this.plugin.onPacketReceive = this.handshakeResult.bind(this);
    }
    /**
     * Assign global configuration option used by result-set to current query option.
     * a little faster than Object.assign() since doest copy all information
     *
     * @param connOpts  connection global configuration
     * @param cmdOpts   current options
     */
    configAssign(connOpts, cmdOpts) {
      if (!cmdOpts) {
        this.opts = connOpts;
        return;
      }
      this.opts = cmdOpts ? Object.assign({}, connOpts, cmdOpts) : connOpts;
      if (cmdOpts.charset && typeof cmdOpts.charset === "string") {
        this.opts.collation = Collations.fromCharset(cmdOpts.charset.toLowerCase());
        if (this.opts.collation === void 0) {
          this.opts.collation = Collations.fromName(cmdOpts.charset.toUpperCase());
          if (this.opts.collation !== void 0) {
            this.opts.logger.warning(
              "warning: please use option 'collation' in replacement of 'charset' when using a collation name ('" + cmdOpts.charset + "')\n(collation looks like 'UTF8MB4_UNICODE_CI', charset like 'utf8')."
            );
          }
        }
        if (this.opts.collation === void 0) throw new RangeError("Unknown charset '" + cmdOpts.charset + "'");
      } else if (cmdOpts.collation && typeof cmdOpts.collation === "string") {
        const initial = cmdOpts.collation;
        this.opts.collation = Collations.fromName(initial.toUpperCase());
        if (this.opts.collation === void 0) throw new RangeError("Unknown collation '" + initial + "'");
      } else {
        this.opts.collation = Collations.fromIndex(cmdOpts.charsetNumber) || connOpts.collation;
      }
      connOpts.password = cmdOpts.password;
    }
  }
  function writeAttribute(out2, val, encoding) {
    let param = Buffer.isEncoding(encoding) ? Buffer.from(val, encoding) : Iconv.encode(val, encoding);
    out2.writeLengthCoded(param.length);
    out2.writeBuffer(param, 0, param.length);
  }
  changeUser = ChangeUser;
  return changeUser;
}
var connection_status = {};
var hasRequiredConnection_status;
function requireConnection_status() {
  if (hasRequiredConnection_status) return connection_status;
  hasRequiredConnection_status = 1;
  const Status = {
    NOT_CONNECTED: 1,
    CONNECTING: 2,
    AUTHENTICATING: 3,
    INIT_CMD: 4,
    CONNECTED: 5,
    CLOSING: 6,
    CLOSED: 7
  };
  connection_status.Status = Status;
  return connection_status;
}
var commonjs = {};
var hasRequiredCommonjs;
function requireCommonjs() {
  var _a, _constructing, _b, _c, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
  if (hasRequiredCommonjs) return commonjs;
  hasRequiredCommonjs = 1;
  Object.defineProperty(commonjs, "__esModule", { value: true });
  commonjs.LRUCache = void 0;
  const perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  const warned = /* @__PURE__ */ new Set();
  const PROCESS = typeof process === "object" && !!process ? process : {};
  const emitWarning = (msg, type2, code, fn) => {
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type2, code, fn) : console.error(`[${code}] ${type2}: ${msg}`);
  };
  let AC = globalThis.AbortController;
  let AS = globalThis.AbortSignal;
  if (typeof AC === "undefined") {
    AS = class AbortSignal {
      constructor() {
        __publicField(this, "onabort");
        __publicField(this, "_onabort", []);
        __publicField(this, "reason");
        __publicField(this, "aborted", false);
      }
      addEventListener(_, fn) {
        this._onabort.push(fn);
      }
    };
    AC = class AbortController {
      constructor() {
        __publicField(this, "signal", new AS());
        warnACPolyfill();
      }
      abort(reason) {
        var _a2, _b2;
        if (this.signal.aborted)
          return;
        this.signal.reason = reason;
        this.signal.aborted = true;
        for (const fn of this.signal._onabort) {
          fn(reason);
        }
        (_b2 = (_a2 = this.signal).onabort) == null ? void 0 : _b2.call(_a2, reason);
      }
    };
    let printACPolyfillWarning = ((_a = PROCESS.env) == null ? void 0 : _a.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = false;
      emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  const shouldWarn = (code) => !warned.has(code);
  const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  const getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
  class ZeroArray extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  }
  const _Stack = class _Stack {
    constructor(max, HeapCls) {
      __publicField(this, "heap");
      __publicField(this, "length");
      if (!__privateGet(_Stack, _constructing)) {
        throw new TypeError("instantiate Stack using Stack.create(n)");
      }
      this.heap = new HeapCls(max);
      this.length = 0;
    }
    static create(max) {
      const HeapCls = getUintArray(max);
      if (!HeapCls)
        return [];
      __privateSet(_Stack, _constructing, true);
      const s = new _Stack(max, HeapCls);
      __privateSet(_Stack, _constructing, false);
      return s;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  };
  _constructing = new WeakMap();
  // private constructor
  __privateAdd(_Stack, _constructing, false);
  let Stack = _Stack;
  const _LRUCache = class _LRUCache {
    constructor(options) {
      __privateAdd(this, _LRUCache_instances);
      // options that cannot be changed without disaster
      __privateAdd(this, _max);
      __privateAdd(this, _maxSize);
      __privateAdd(this, _dispose);
      __privateAdd(this, _disposeAfter);
      __privateAdd(this, _fetchMethod);
      __privateAdd(this, _memoMethod);
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      __publicField(this, "ttl");
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      __publicField(this, "ttlResolution");
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      __publicField(this, "ttlAutopurge");
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      __publicField(this, "updateAgeOnGet");
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      __publicField(this, "updateAgeOnHas");
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      __publicField(this, "allowStale");
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      __publicField(this, "noDisposeOnSet");
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      __publicField(this, "noUpdateTTL");
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      __publicField(this, "maxEntrySize");
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      __publicField(this, "sizeCalculation");
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      __publicField(this, "noDeleteOnFetchRejection");
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      __publicField(this, "noDeleteOnStaleGet");
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      __publicField(this, "allowStaleOnFetchAbort");
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      __publicField(this, "allowStaleOnFetchRejection");
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      __publicField(this, "ignoreFetchAbort");
      // computed properties
      __privateAdd(this, _size);
      __privateAdd(this, _calculatedSize);
      __privateAdd(this, _keyMap);
      __privateAdd(this, _keyList);
      __privateAdd(this, _valList);
      __privateAdd(this, _next);
      __privateAdd(this, _prev);
      __privateAdd(this, _head);
      __privateAdd(this, _tail);
      __privateAdd(this, _free);
      __privateAdd(this, _disposed);
      __privateAdd(this, _sizes);
      __privateAdd(this, _starts);
      __privateAdd(this, _ttls);
      __privateAdd(this, _hasDispose);
      __privateAdd(this, _hasFetchMethod);
      __privateAdd(this, _hasDisposeAfter);
      // conditionally set private methods related to TTL
      __privateAdd(this, _updateItemAge, () => {
      });
      __privateAdd(this, _statusTTL, () => {
      });
      __privateAdd(this, _setItemTTL, () => {
      });
      /* c8 ignore stop */
      __privateAdd(this, _isStale, () => false);
      __privateAdd(this, _removeItemSize, (_i) => {
      });
      __privateAdd(this, _addItemSize, (_i, _s, _st) => {
      });
      __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      });
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      __publicField(this, _b, "LRUCache");
      const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max ? getUintArray(max) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max);
      }
      __privateSet(this, _max, max);
      __privateSet(this, _maxSize, maxSize);
      this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
      this.sizeCalculation = sizeCalculation;
      if (this.sizeCalculation) {
        if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      if (memoMethod !== void 0 && typeof memoMethod !== "function") {
        throw new TypeError("memoMethod must be a function if defined");
      }
      __privateSet(this, _memoMethod, memoMethod);
      if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      __privateSet(this, _fetchMethod, fetchMethod);
      __privateSet(this, _hasFetchMethod, !!fetchMethod);
      __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
      __privateSet(this, _keyList, new Array(max).fill(void 0));
      __privateSet(this, _valList, new Array(max).fill(void 0));
      __privateSet(this, _next, new UintArray(max));
      __privateSet(this, _prev, new UintArray(max));
      __privateSet(this, _head, 0);
      __privateSet(this, _tail, 0);
      __privateSet(this, _free, Stack.create(max));
      __privateSet(this, _size, 0);
      __privateSet(this, _calculatedSize, 0);
      if (typeof dispose === "function") {
        __privateSet(this, _dispose, dispose);
      }
      if (typeof disposeAfter === "function") {
        __privateSet(this, _disposeAfter, disposeAfter);
        __privateSet(this, _disposed, []);
      } else {
        __privateSet(this, _disposeAfter, void 0);
        __privateSet(this, _disposed, void 0);
      }
      __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
      __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (__privateGet(this, _maxSize) !== 0) {
          if (!isPosInt(__privateGet(this, _maxSize))) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
      }
      this.allowStale = !!allowStale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
      }
      if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
        }
      }
    }
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
      return {
        // properties
        starts: __privateGet(c, _starts),
        ttls: __privateGet(c, _ttls),
        sizes: __privateGet(c, _sizes),
        keyMap: __privateGet(c, _keyMap),
        keyList: __privateGet(c, _keyList),
        valList: __privateGet(c, _valList),
        next: __privateGet(c, _next),
        prev: __privateGet(c, _prev),
        get head() {
          return __privateGet(c, _head);
        },
        get tail() {
          return __privateGet(c, _tail);
        },
        free: __privateGet(c, _free),
        // methods
        isBackgroundFetch: (p) => {
          var _a2;
          return __privateMethod(_a2 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a2, p);
        },
        backgroundFetch: (k, index, options, context) => {
          var _a2;
          return __privateMethod(_a2 = c, _LRUCache_instances, backgroundFetch_fn).call(_a2, k, index, options, context);
        },
        moveToTail: (index) => {
          var _a2;
          return __privateMethod(_a2 = c, _LRUCache_instances, moveToTail_fn).call(_a2, index);
        },
        indexes: (options) => {
          var _a2;
          return __privateMethod(_a2 = c, _LRUCache_instances, indexes_fn).call(_a2, options);
        },
        rindexes: (options) => {
          var _a2;
          return __privateMethod(_a2 = c, _LRUCache_instances, rindexes_fn).call(_a2, options);
        },
        isStale: (index) => {
          var _a2;
          return __privateGet(_a2 = c, _isStale).call(_a2, index);
        }
      };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
      return __privateGet(this, _max);
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
      return __privateGet(this, _maxSize);
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
      return __privateGet(this, _calculatedSize);
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
      return __privateGet(this, _size);
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
      return __privateGet(this, _fetchMethod);
    }
    get memoMethod() {
      return __privateGet(this, _memoMethod);
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
      return __privateGet(this, _dispose);
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
      return __privateGet(this, _disposeAfter);
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
      return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
      for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
        if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
          yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
      for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
        if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
          yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
        }
      }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
      for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
        const k = __privateGet(this, _keyList)[i];
        if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
          yield k;
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
      for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
        const k = __privateGet(this, _keyList)[i];
        if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
          yield k;
        }
      }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
      for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
        const v = __privateGet(this, _valList)[i];
        if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
          yield __privateGet(this, _valList)[i];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
      for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
        const v = __privateGet(this, _valList)[i];
        if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
          yield __privateGet(this, _valList)[i];
        }
      }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [(_c = Symbol.iterator, _b = Symbol.toStringTag, _c)]() {
      return this.entries();
    }
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
      for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
        const v = __privateGet(this, _valList)[i];
        const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        if (fn(value, __privateGet(this, _keyList)[i], this)) {
          return this.get(__privateGet(this, _keyList)[i], getOptions);
        }
      }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
      for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
        const v = __privateGet(this, _valList)[i];
        const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
      }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
      for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
        const v = __privateGet(this, _valList)[i];
        const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
      }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
      let deleted = false;
      for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
        if (__privateGet(this, _isStale).call(this, i)) {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[i], "expire");
          deleted = true;
        }
      }
      return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
      const i = __privateGet(this, _keyMap).get(key);
      if (i === void 0)
        return void 0;
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        return void 0;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        const ttl = __privateGet(this, _ttls)[i];
        const start = __privateGet(this, _starts)[i];
        if (ttl && start) {
          const remain = ttl - (perf.now() - start);
          entry.ttl = remain;
          entry.start = Date.now();
        }
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i];
      }
      return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
      const arr = [];
      for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
        const key = __privateGet(this, _keyList)[i];
        const v = __privateGet(this, _valList)[i];
        const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0 || key === void 0)
          continue;
        const entry = { value };
        if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
          entry.ttl = __privateGet(this, _ttls)[i];
          const age = perf.now() - __privateGet(this, _starts)[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (__privateGet(this, _sizes)) {
          entry.size = __privateGet(this, _sizes)[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
      var _a2, _b2, _c2, _d, _e;
      if (v === void 0) {
        this.delete(k);
        return this;
      }
      const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
      let { noUpdateTTL = this.noUpdateTTL } = setOptions;
      const size = __privateGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "set");
        return this;
      }
      let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k);
      if (index === void 0) {
        index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, false) : __privateGet(this, _size);
        __privateGet(this, _keyList)[index] = k;
        __privateGet(this, _valList)[index] = v;
        __privateGet(this, _keyMap).set(k, index);
        __privateGet(this, _next)[__privateGet(this, _tail)] = index;
        __privateGet(this, _prev)[index] = __privateGet(this, _tail);
        __privateSet(this, _tail, index);
        __privateWrapper(this, _size)._++;
        __privateGet(this, _addItemSize).call(this, index, size, status);
        if (status)
          status.set = "add";
        noUpdateTTL = false;
      } else {
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
        const oldVal = __privateGet(this, _valList)[index];
        if (v !== oldVal) {
          if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: s } = oldVal;
            if (s !== void 0 && !noDisposeOnSet) {
              if (__privateGet(this, _hasDispose)) {
                (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, s, k, "set");
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([s, k, "set"]);
              }
            }
          } else if (!noDisposeOnSet) {
            if (__privateGet(this, _hasDispose)) {
              (_c2 = __privateGet(this, _dispose)) == null ? void 0 : _c2.call(this, oldVal, k, "set");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_d = __privateGet(this, _disposed)) == null ? void 0 : _d.push([oldVal, k, "set"]);
            }
          }
          __privateGet(this, _removeItemSize).call(this, index);
          __privateGet(this, _addItemSize).call(this, index, size, status);
          __privateGet(this, _valList)[index] = v;
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== void 0)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
      }
      if (ttl !== 0 && !__privateGet(this, _ttls)) {
        __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
      }
      if (__privateGet(this, _ttls)) {
        if (!noUpdateTTL) {
          __privateGet(this, _setItemTTL).call(this, index, ttl, start);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index);
      }
      if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_e = __privateGet(this, _disposeAfter)) == null ? void 0 : _e.call(this, ...task);
        }
      }
      return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
      var _a2;
      try {
        while (__privateGet(this, _size)) {
          const val = __privateGet(this, _valList)[__privateGet(this, _head)];
          __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
          if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching;
            }
          } else if (val !== void 0) {
            return val;
          }
        }
      } finally {
        if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt == null ? void 0 : dt.shift()) {
            (_a2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a2.call(this, ...task);
          }
        }
      }
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
      const index = __privateGet(this, _keyMap).get(k);
      if (index !== void 0) {
        const v = __privateGet(this, _valList)[index];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
          return false;
        }
        if (!__privateGet(this, _isStale).call(this, index)) {
          if (updateAgeOnHas) {
            __privateGet(this, _updateItemAge).call(this, index);
          }
          if (status) {
            status.has = "hit";
            __privateGet(this, _statusTTL).call(this, status, index);
          }
          return true;
        } else if (status) {
          status.has = "stale";
          __privateGet(this, _statusTTL).call(this, status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions;
      const index = __privateGet(this, _keyMap).get(k);
      if (index === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index)) {
        return;
      }
      const v = __privateGet(this, _valList)[index];
      return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
    }
    async fetch(k, fetchOptions = {}) {
      const {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions;
      if (!__privateGet(this, _hasFetchMethod)) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = __privateGet(this, _keyMap).get(k);
      if (index === void 0) {
        if (status)
          status.fetch = "miss";
        const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
        return p.__returned = p;
      } else {
        const v = __privateGet(this, _valList)[index];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          const stale = allowStale && v.__staleWhileFetching !== void 0;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = __privateGet(this, _isStale).call(this, index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
          if (updateAgeOnGet) {
            __privateGet(this, _updateItemAge).call(this, index);
          }
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index);
          return v;
        }
        const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
        const hasStale = p.__staleWhileFetching !== void 0;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      const v = await this.fetch(k, fetchOptions);
      if (v === void 0)
        throw new Error("fetch() returned undefined");
      return v;
    }
    memo(k, memoOptions = {}) {
      const memoMethod = __privateGet(this, _memoMethod);
      if (!memoMethod) {
        throw new Error("no memoMethod provided to constructor");
      }
      const { context, forceRefresh, ...options } = memoOptions;
      const v = this.get(k, options);
      if (!forceRefresh && v !== void 0)
        return v;
      const vv = memoMethod(k, v, {
        options,
        context
      });
      this.set(k, vv, options);
      return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
      const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
      const index = __privateGet(this, _keyMap).get(k);
      if (index !== void 0) {
        const value = __privateGet(this, _valList)[index];
        const fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index);
        if (__privateGet(this, _isStale).call(this, index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "expire");
            }
            if (status && allowStale)
              status.returnedStale = true;
            return allowStale ? value : void 0;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== void 0) {
              status.returnedStale = true;
            }
            return allowStale ? value.__staleWhileFetching : void 0;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
          if (updateAgeOnGet) {
            __privateGet(this, _updateItemAge).call(this, index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
      return __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "delete");
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
      return __privateMethod(this, _LRUCache_instances, clear_fn).call(this, "delete");
    }
  };
  _max = new WeakMap();
  _maxSize = new WeakMap();
  _dispose = new WeakMap();
  _disposeAfter = new WeakMap();
  _fetchMethod = new WeakMap();
  _memoMethod = new WeakMap();
  _size = new WeakMap();
  _calculatedSize = new WeakMap();
  _keyMap = new WeakMap();
  _keyList = new WeakMap();
  _valList = new WeakMap();
  _next = new WeakMap();
  _prev = new WeakMap();
  _head = new WeakMap();
  _tail = new WeakMap();
  _free = new WeakMap();
  _disposed = new WeakMap();
  _sizes = new WeakMap();
  _starts = new WeakMap();
  _ttls = new WeakMap();
  _hasDispose = new WeakMap();
  _hasFetchMethod = new WeakMap();
  _hasDisposeAfter = new WeakMap();
  _LRUCache_instances = new WeakSet();
  initializeTTLTracking_fn = function() {
    const ttls = new ZeroArray(__privateGet(this, _max));
    const starts = new ZeroArray(__privateGet(this, _max));
    __privateSet(this, _ttls, ttls);
    __privateSet(this, _starts, starts);
    __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (__privateGet(this, _isStale).call(this, index)) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[index], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    });
    __privateSet(this, _updateItemAge, (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    });
    __privateSet(this, _statusTTL, (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    });
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = __privateGet(this, _keyMap).get(key);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    __privateSet(this, _isStale, (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    });
  };
  _updateItemAge = new WeakMap();
  _statusTTL = new WeakMap();
  _setItemTTL = new WeakMap();
  _isStale = new WeakMap();
  initializeSizeTracking_fn = function() {
    const sizes = new ZeroArray(__privateGet(this, _max));
    __privateSet(this, _calculatedSize, 0);
    __privateSet(this, _sizes, sizes);
    __privateSet(this, _removeItemSize, (index) => {
      __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
      sizes[index] = 0;
    });
    __privateSet(this, _requireSize, (k, v, size, sizeCalculation) => {
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    });
    __privateSet(this, _addItemSize, (index, size, status) => {
      sizes[index] = size;
      if (__privateGet(this, _maxSize)) {
        const maxSize = __privateGet(this, _maxSize) - sizes[index];
        while (__privateGet(this, _calculatedSize) > maxSize) {
          __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
        }
      }
      __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = __privateGet(this, _calculatedSize);
      }
    });
  };
  _removeItemSize = new WeakMap();
  _addItemSize = new WeakMap();
  _requireSize = new WeakMap();
  indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
    if (__privateGet(this, _size)) {
      for (let i = __privateGet(this, _tail); true; ) {
        if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
          break;
        }
        if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
          yield i;
        }
        if (i === __privateGet(this, _head)) {
          break;
        } else {
          i = __privateGet(this, _prev)[i];
        }
      }
    }
  };
  rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
    if (__privateGet(this, _size)) {
      for (let i = __privateGet(this, _head); true; ) {
        if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
          break;
        }
        if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
          yield i;
        }
        if (i === __privateGet(this, _tail)) {
          break;
        } else {
          i = __privateGet(this, _next)[i];
        }
      }
    }
  };
  isValidIndex_fn = function(index) {
    return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
  };
  evict_fn = function(free) {
    var _a2, _b2;
    const head = __privateGet(this, _head);
    const k = __privateGet(this, _keyList)[head];
    const v = __privateGet(this, _valList)[head];
    if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
      if (__privateGet(this, _hasDispose)) {
        (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, "evict");
      }
      if (__privateGet(this, _hasDisposeAfter)) {
        (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k, "evict"]);
      }
    }
    __privateGet(this, _removeItemSize).call(this, head);
    if (free) {
      __privateGet(this, _keyList)[head] = void 0;
      __privateGet(this, _valList)[head] = void 0;
      __privateGet(this, _free).push(head);
    }
    if (__privateGet(this, _size) === 1) {
      __privateSet(this, _head, __privateSet(this, _tail, 0));
      __privateGet(this, _free).length = 0;
    } else {
      __privateSet(this, _head, __privateGet(this, _next)[head]);
    }
    __privateGet(this, _keyMap).delete(k);
    __privateWrapper(this, _size)._--;
    return head;
  };
  backgroundFetch_fn = function(k, index, options, context) {
    const v = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options;
    signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (__privateGet(this, _valList)[index] === p) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching) {
            __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
          } else {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (__privateGet(this, _valList)[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
        } else if (!allowStaleAborted) {
          __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      var _a2;
      const fmp = (_a2 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a2.call(this, k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index = __privateGet(this, _keyMap).get(k);
    } else {
      __privateGet(this, _valList)[index] = bf;
    }
    return bf;
  };
  isBackgroundFetch_fn = function(p) {
    if (!__privateGet(this, _hasFetchMethod))
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  };
  connect_fn = function(p, n) {
    __privateGet(this, _prev)[n] = p;
    __privateGet(this, _next)[p] = n;
  };
  moveToTail_fn = function(index) {
    if (index !== __privateGet(this, _tail)) {
      if (index === __privateGet(this, _head)) {
        __privateSet(this, _head, __privateGet(this, _next)[index]);
      } else {
        __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
      }
      __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index);
      __privateSet(this, _tail, index);
    }
  };
  delete_fn = function(k, reason) {
    var _a2, _b2, _c2, _d;
    let deleted = false;
    if (__privateGet(this, _size) !== 0) {
      const index = __privateGet(this, _keyMap).get(k);
      if (index !== void 0) {
        deleted = true;
        if (__privateGet(this, _size) === 1) {
          __privateMethod(this, _LRUCache_instances, clear_fn).call(this, reason);
        } else {
          __privateGet(this, _removeItemSize).call(this, index);
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
            if (__privateGet(this, _hasDispose)) {
              (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, reason);
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k, reason]);
            }
          }
          __privateGet(this, _keyMap).delete(k);
          __privateGet(this, _keyList)[index] = void 0;
          __privateGet(this, _valList)[index] = void 0;
          if (index === __privateGet(this, _tail)) {
            __privateSet(this, _tail, __privateGet(this, _prev)[index]);
          } else if (index === __privateGet(this, _head)) {
            __privateSet(this, _head, __privateGet(this, _next)[index]);
          } else {
            const pi = __privateGet(this, _prev)[index];
            __privateGet(this, _next)[pi] = __privateGet(this, _next)[index];
            const ni = __privateGet(this, _next)[index];
            __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index];
          }
          __privateWrapper(this, _size)._--;
          __privateGet(this, _free).push(index);
        }
      }
    }
    if (__privateGet(this, _hasDisposeAfter) && ((_c2 = __privateGet(this, _disposed)) == null ? void 0 : _c2.length)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
      }
    }
    return deleted;
  };
  clear_fn = function(reason) {
    var _a2, _b2, _c2;
    for (const index of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
      const v = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = __privateGet(this, _keyList)[index];
        if (__privateGet(this, _hasDispose)) {
          (_a2 = __privateGet(this, _dispose)) == null ? void 0 : _a2.call(this, v, k, reason);
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k, reason]);
        }
      }
    }
    __privateGet(this, _keyMap).clear();
    __privateGet(this, _valList).fill(void 0);
    __privateGet(this, _keyList).fill(void 0);
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      __privateGet(this, _ttls).fill(0);
      __privateGet(this, _starts).fill(0);
    }
    if (__privateGet(this, _sizes)) {
      __privateGet(this, _sizes).fill(0);
    }
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateGet(this, _free).length = 0;
    __privateSet(this, _calculatedSize, 0);
    __privateSet(this, _size, 0);
    if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_c2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _c2.call(this, ...task);
      }
    }
  };
  let LRUCache = _LRUCache;
  commonjs.LRUCache = LRUCache;
  return commonjs;
}
var lruPrepareCache;
var hasRequiredLruPrepareCache;
function requireLruPrepareCache() {
  var _lruCache, _info;
  if (hasRequiredLruPrepareCache) return lruPrepareCache;
  hasRequiredLruPrepareCache = 1;
  const LRU = /* @__PURE__ */ requireCommonjs();
  class LruPrepareCache {
    constructor(info, prepareCacheLength) {
      __privateAdd(this, _lruCache);
      __privateAdd(this, _info);
      __privateSet(this, _info, info);
      __privateSet(this, _lruCache, new LRU.LRUCache({
        max: prepareCacheLength,
        dispose: (value, key) => value.unCache()
      }));
    }
    get(sql) {
      const key = __privateGet(this, _info).database + "|" + sql;
      const cachedItem = __privateGet(this, _lruCache).get(key);
      if (cachedItem) {
        return cachedItem.incrementUse();
      }
      return null;
    }
    set(sql, cache) {
      const key = __privateGet(this, _info).database + "|" + sql;
      __privateGet(this, _lruCache).set(key, cache);
    }
    toString() {
      let keyStr = "";
      for (const value of __privateGet(this, _lruCache).keys()) {
        keyStr += "[" + value + "],";
      }
      if (keyStr.length > 1) keyStr = keyStr.substring(0, keyStr.length - 1);
      return "info{cache:" + keyStr + "}";
    }
    reset() {
      __privateGet(this, _lruCache).clear();
    }
  }
  _lruCache = new WeakMap();
  _info = new WeakMap();
  lruPrepareCache = LruPrepareCache;
  return lruPrepareCache;
}
var connection;
var hasRequiredConnection;
function requireConnection() {
  var _collation, _socket;
  if (hasRequiredConnection) return connection;
  hasRequiredConnection = 1;
  const EventEmitter = require$$0$3;
  const Queue = requireDenque();
  const Net = require$$2$2;
  const PacketInputStream = requirePacketInputStream();
  const PacketOutputStream = requirePacketOutputStream();
  const CompressionInputStream = requireCompressionInputStream();
  const CompressionOutputStream = requireCompressionOutputStream();
  const ServerStatus = requireServerStatus();
  const ConnectionInformation = requireConnectionInformation();
  const tls = require$$9;
  const Errors = requireErrors();
  const Utils = requireUtils$2();
  const Capabilities = requireCapabilities();
  const ConnectionOptions = requireConnectionOptions();
  const Authentication = requireAuthentication();
  const Quit = requireQuit();
  const Ping = requirePing();
  const Reset = requireReset();
  const Query = requireQuery();
  const Prepare = requirePrepare();
  const OkPacket = requireOkPacket();
  const Execute = requireExecute();
  const ClosePrepare = requireClosePrepare();
  const BatchBulk = requireBatchBulk();
  const ChangeUser = requireChangeUser();
  const { Status } = requireConnection_status();
  const LruPrepareCache = requireLruPrepareCache();
  const fsPromises = require$$1$2.promises;
  const Parse = requireParse$1();
  const Collations = requireCollations();
  const ConnOptions = requireConnectionOptions();
  const convertFixedTime = function(tz, conn) {
    if (tz === "UTC" || tz === "Etc/UTC" || tz === "Z" || tz === "Etc/GMT") {
      return "+00:00";
    } else if (tz.startsWith("Etc/GMT") || tz.startsWith("GMT")) {
      let tzdiff;
      let negate;
      if (tz.startsWith("Etc/GMT")) {
        tzdiff = tz.substring(7);
        negate = !tzdiff.startsWith("-");
      } else {
        tzdiff = tz.substring(3);
        negate = tzdiff.startsWith("-");
      }
      let diff = parseInt(tzdiff.substring(1));
      if (isNaN(diff)) {
        throw Errors.createFatalError(
          `Automatic timezone setting fails. wrong Server timezone '${tz}' conversion to +/-HH:00 conversion.`,
          Errors.ER_WRONG_AUTO_TIMEZONE,
          conn.info
        );
      }
      return (negate ? "-" : "+") + (diff >= 10 ? diff : "0" + diff) + ":00";
    }
    return tz;
  };
  const redirectUrlFormat = /(mariadb|mysql):\/\/(([^/@:]+)?(:([^/]+))?@)?(([^/:]+)(:([0-9]+))?)(\/([^?]+)(\?(.*))?)?$/;
  class Connection extends EventEmitter {
    constructor(options) {
      super();
      __publicField(this, "opts");
      __publicField(this, "sendQueue", new Queue());
      __publicField(this, "receiveQueue", new Queue());
      __publicField(this, "waitingAuthenticationQueue", new Queue());
      __publicField(this, "status", Status.NOT_CONNECTED);
      __publicField(this, "socket", null);
      __publicField(this, "timeout", null);
      __publicField(this, "addCommand");
      __publicField(this, "streamOut");
      __publicField(this, "streamIn");
      __publicField(this, "info");
      __publicField(this, "prepareCache");
      this.opts = Object.assign(new EventEmitter(), options);
      this.info = new ConnectionInformation(this.opts, this.redirect.bind(this));
      this.prepareCache = this.opts.prepareCacheLength > 0 ? new LruPrepareCache(this.info, this.opts.prepareCacheLength) : null;
      this.addCommand = this.addCommandQueue;
      this.streamOut = new PacketOutputStream(this.opts, this.info);
      this.streamIn = new PacketInputStream(
        this.unexpectedPacket.bind(this),
        this.receiveQueue,
        this.streamOut,
        this.opts,
        this.info
      );
      this.on("close_prepare", this._closePrepare.bind(this));
      this.escape = Utils.escape.bind(this, this.opts, this.info);
      this.escapeId = Utils.escapeId.bind(this, this.opts, this.info);
    }
    //*****************************************************************
    // public methods
    //*****************************************************************
    /**
     * Connect event
     *
     * @returns {Promise} promise
     */
    connect() {
      const conn = this;
      this.status = Status.CONNECTING;
      const authenticationParam = {
        opts: this.opts
      };
      return new Promise(function(resolve, reject) {
        conn.connectRejectFct = reject;
        conn.connectResolveFct = resolve;
        const authentication2 = new Authentication(
          authenticationParam,
          conn.authSucceedHandler.bind(conn),
          conn.authFailHandler.bind(conn),
          conn.createSecureContext.bind(conn),
          conn.getSocket.bind(conn)
        );
        Error.captureStackTrace(authentication2);
        authentication2.once("end", () => {
          conn.receiveQueue.shift();
          if (!conn.opts.collation && conn.info.collation) {
            conn.opts.emit("collation", conn.info.collation);
          }
          process.nextTick(conn.nextSendCmd.bind(conn));
        });
        conn.receiveQueue.push(authentication2);
        conn.streamInitSocket.call(conn);
      });
    }
    executePromise(cmdParam, prepare2, resolve, reject) {
      const cmd = new Execute(resolve, this._logAndReject.bind(this, reject), this.opts, cmdParam, prepare2);
      this.addCommand(cmd, true);
    }
    batch(cmdParam) {
      if (!cmdParam.sql) {
        const err = Errors.createError(
          "sql parameter is mandatory",
          Errors.ER_UNDEFINED_SQL,
          this.info,
          "HY000",
          null,
          false,
          cmdParam.stack
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        return Promise.reject(err);
      }
      if (!cmdParam.values) {
        const err = Errors.createError(
          "Batch must have values set",
          Errors.ER_BATCH_WITH_NO_VALUES,
          this.info,
          "HY000",
          cmdParam.sql.length > this.opts.debugLen ? cmdParam.sql.substring(0, this.opts.debugLen) + "..." : cmdParam.sql,
          false,
          cmdParam.stack
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        return Promise.reject(err);
      }
      return new Promise(this.prepare.bind(this, cmdParam)).then((prepare2) => {
        const usePlaceHolder = cmdParam.opts && cmdParam.opts.namedPlaceholders || this.opts.namedPlaceholders;
        let vals;
        if (Array.isArray(cmdParam.values)) {
          if (usePlaceHolder) {
            vals = cmdParam.values;
          } else if (Array.isArray(cmdParam.values[0])) {
            vals = cmdParam.values;
          } else if (prepare2.parameterCount === 1) {
            vals = [];
            for (let i = 0; i < cmdParam.values.length; i++) {
              vals.push([cmdParam.values[i]]);
            }
          } else {
            vals = [cmdParam.values];
          }
        } else {
          vals = [[cmdParam.values]];
        }
        cmdParam.values = vals;
        let useBulk = this._canUseBulk(vals, cmdParam.opts);
        if (useBulk) {
          return new Promise(this.executeBulkPromise.bind(this, cmdParam, prepare2, this.opts));
        } else {
          const executes = [];
          const cmdOpt = Object.assign({}, this.opts, cmdParam.opts);
          for (let i = 0; i < vals.length; i++) {
            executes.push(prepare2.execute(vals[i], cmdParam.opts, null, cmdParam.stack));
          }
          return Promise.all(executes).then(
            (function(res) {
              if (cmdParam.opts && cmdParam.opts.fullResult) {
                return Promise.resolve(res);
              } else {
                let firstResult = res[0];
                if (cmdOpt.metaAsArray) firstResult = firstResult[0];
                if (firstResult instanceof OkPacket) {
                  let affectedRows = 0;
                  const insertId = firstResult.insertId;
                  const warningStatus = firstResult.warningStatus;
                  if (cmdOpt.metaAsArray) {
                    for (let i = 0; i < res.length; i++) {
                      affectedRows += res[i][0].affectedRows;
                    }
                    return Promise.resolve([new OkPacket(affectedRows, insertId, warningStatus), []]);
                  } else {
                    for (let i = 0; i < res.length; i++) {
                      affectedRows += res[i].affectedRows;
                    }
                    return Promise.resolve(new OkPacket(affectedRows, insertId, warningStatus));
                  }
                } else {
                  if (cmdOpt.metaAsArray) {
                    const rs = [];
                    res.forEach((row) => {
                      rs.push(...row[0]);
                    });
                    return Promise.resolve([rs, res[0][1]]);
                  } else {
                    const rs = [];
                    res.forEach((row) => {
                      rs.push(...row);
                    });
                    Object.defineProperty(rs, "meta", {
                      value: res[0].meta,
                      writable: true,
                      enumerable: this.opts.metaEnumerable
                    });
                    return Promise.resolve(rs);
                  }
                }
              }
            }).bind(this)
          ).finally(() => prepare2.close());
        }
      });
    }
    executeBulkPromise(cmdParam, prepare2, opts, resolve, reject) {
      const cmd = new BatchBulk(
        (res) => {
          prepare2.close();
          return resolve(res);
        },
        function(err) {
          prepare2.close();
          if (opts.logger.error) opts.logger.error(err);
          reject(err);
        },
        opts,
        prepare2,
        cmdParam
      );
      this.addCommand(cmd, true);
    }
    /**
     * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout
     * @param cmdParam command context
     * @param resolve success function
     * @param reject rejection function
     */
    ping(cmdParam, resolve, reject) {
      if (cmdParam.opts && cmdParam.opts.timeout) {
        if (cmdParam.opts.timeout < 0) {
          const err = Errors.createError(
            "Ping cannot have negative timeout value",
            Errors.ER_BAD_PARAMETER_VALUE,
            this.info,
            "0A000"
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          reject(err);
          return;
        }
        let tOut = setTimeout(
          (function() {
            tOut = void 0;
            const err = Errors.createFatalError("Ping timeout", Errors.ER_PING_TIMEOUT, this.info, "0A000");
            if (this.opts.logger.error) this.opts.logger.error(err);
            this.addCommand = this.addCommandDisabled;
            clearTimeout(this.timeout);
            if (this.status !== Status.CLOSING && this.status !== Status.CLOSED) {
              this.sendQueue.clear();
              this.status = Status.CLOSED;
              this.socket.destroy();
            }
            this.clear();
            reject(err);
          }).bind(this),
          cmdParam.opts.timeout
        );
        this.addCommand(
          new Ping(
            cmdParam,
            () => {
              if (tOut) {
                clearTimeout(tOut);
                resolve();
              }
            },
            (err) => {
              if (this.opts.logger.error) this.opts.logger.error(err);
              clearTimeout(tOut);
              reject(err);
            }
          ),
          true
        );
        return;
      }
      this.addCommand(new Ping(cmdParam, resolve, reject), true);
    }
    /**
     * Send a reset command that will
     * - rollback any open transaction
     * - reset transaction isolation level
     * - reset session variables
     * - delete user variables
     * - remove temporary tables
     * - remove all PREPARE statement
     */
    reset(cmdParam, resolve, reject) {
      if (this.info.isMariaDB() && this.info.hasMinVersion(10, 2, 4) || !this.info.isMariaDB() && this.info.hasMinVersion(5, 7, 3)) {
        const conn = this;
        const resetCmd = new Reset(
          cmdParam,
          () => {
            if (conn.prepareCache) conn.prepareCache.reset();
            let prom = Promise.resolve();
            prom.then(conn.handleCharset.bind(conn)).then(conn.handleTimezone.bind(conn)).then(conn.executeInitQuery.bind(conn)).then(conn.executeSessionTimeout.bind(conn)).then(resolve).catch(reject);
          },
          reject
        );
        this.addCommand(resetCmd, true);
        return;
      }
      const err = new Error(
        `Reset command not permitted for server ${this.info.serverVersion.raw} (requires server MariaDB version 10.2.4+ or MySQL 5.7.3+)`
      );
      err.stack = cmdParam.stack;
      if (this.opts.logger.error) this.opts.logger.error(err);
      reject(err);
    }
    /**
     * Indicates the state of the connection as the driver knows it
     * @returns {boolean}
     */
    isValid() {
      return this.status === Status.CONNECTED;
    }
    /**
     * Terminate connection gracefully.
     */
    end(cmdParam, resolve, reject) {
      this.addCommand = this.addCommandDisabled;
      clearTimeout(this.timeout);
      if (this.status < Status.CLOSING && this.status !== Status.NOT_CONNECTED) {
        this.status = Status.CLOSING;
        const ended = () => {
          this.status = Status.CLOSED;
          this.socket.destroy();
          this.socket.unref();
          this.clear();
          this.receiveQueue.clear();
          resolve();
        };
        const quitCmd = new Quit(cmdParam, ended, ended);
        this.sendQueue.push(quitCmd);
        this.receiveQueue.push(quitCmd);
        if (this.sendQueue.length === 1) {
          process.nextTick(this.nextSendCmd.bind(this));
        }
      } else resolve();
    }
    /**
     * Force connection termination by closing the underlying socket and killing server process if any.
     */
    destroy() {
      this.addCommand = this.addCommandDisabled;
      clearTimeout(this.timeout);
      if (this.status < Status.CLOSING) {
        this.status = Status.CLOSING;
        this.sendQueue.clear();
        if (this.receiveQueue.length > 0) {
          const self2 = this;
          const remoteAddress = this.socket.remoteAddress;
          const connOption = remoteAddress ? Object.assign({}, this.opts, { host: remoteAddress }) : this.opts;
          const killCon = new Connection(connOption);
          killCon.connect().then(() => {
            new Promise(killCon.query.bind(killCon, { sql: `KILL ${self2.info.threadId}` })).finally((err) => {
              const destroyError = Errors.createFatalError(
                "Connection destroyed, command was killed",
                Errors.ER_CMD_NOT_EXECUTED_DESTROYED,
                self2.info
              );
              if (self2.opts.logger.error) self2.opts.logger.error(destroyError);
              self2.socketErrorDispatchToQueries(destroyError);
              if (self2.socket) {
                const sok = self2.socket;
                process.nextTick(() => {
                  sok.destroy();
                });
              }
              self2.status = Status.CLOSED;
              self2.clear();
              new Promise(killCon.end.bind(killCon)).catch(() => {
              });
            });
          }).catch(() => {
            const ended = () => {
              let sock = self2.socket;
              self2.clear();
              self2.status = Status.CLOSED;
              sock.destroy();
              self2.receiveQueue.clear();
            };
            const quitCmd = new Quit(ended, ended);
            self2.sendQueue.push(quitCmd);
            self2.receiveQueue.push(quitCmd);
            if (self2.sendQueue.length === 1) {
              process.nextTick(self2.nextSendCmd.bind(self2));
            }
          });
        } else {
          this.status = Status.CLOSED;
          this.socket.destroy();
          this.clear();
        }
      }
    }
    pause() {
      this.socket.pause();
    }
    resume() {
      this.socket.resume();
    }
    format(sql, values) {
      const err = Errors.createError(
        '"Connection.format intentionally not implemented. please use Connection.query(sql, values), it will be more secure and faster',
        Errors.ER_NOT_IMPLEMENTED_FORMAT,
        this.info,
        "0A000"
      );
      if (this.opts.logger.error) this.opts.logger.error(err);
      throw err;
    }
    //*****************************************************************
    // additional public methods
    //*****************************************************************
    /**
     * return current connected server version information.
     *
     * @returns {*}
     */
    serverVersion() {
      if (!this.info.serverVersion) {
        const err = new Error("cannot know if server information until connection is established");
        if (this.opts.logger.error) this.opts.logger.error(err);
        throw err;
      }
      return this.info.serverVersion.raw;
    }
    /**
     * Change option "debug" during connection.
     * @param val   debug value
     */
    debug(val) {
      if (typeof val === "boolean") {
        if (val && !this.opts.logger.network) this.opts.logger.network = console.log;
      } else if (typeof val === "function") {
        this.opts.logger.network = val;
      }
      this.opts.emit("debug", val);
    }
    debugCompress(val) {
      if (val) {
        if (typeof val === "boolean") {
          this.opts.debugCompress = val;
          if (val && !this.opts.logger.network) this.opts.logger.network = console.log;
        } else if (typeof val === "function") {
          this.opts.debugCompress = true;
          this.opts.logger.network = val;
        }
      } else this.opts.debugCompress = false;
    }
    //*****************************************************************
    // internal public testing methods
    //*****************************************************************
    get __tests() {
      return new TestMethods(this.info.collation, this.socket);
    }
    //*****************************************************************
    // internal methods
    //*****************************************************************
    /**
     * Use multiple COM_STMT_EXECUTE or COM_STMT_BULK_EXECUTE
     *
     * @param values current batch values
     * @param _options batch option
     * @return {boolean} indicating if can use bulk command
     */
    _canUseBulk(values, _options) {
      if (_options && _options.fullResult) return false;
      const bulkEnable = _options === void 0 || _options === null ? this.opts.bulk : _options.bulk !== void 0 && _options.bulk !== null ? _options.bulk : this.opts.bulk;
      if (this.info.serverVersion && this.info.serverVersion.mariaDb && this.info.hasMinVersion(10, 2, 7) && bulkEnable && (this.info.serverCapabilities & Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS) > 0n) {
        if (values !== void 0) {
          if (!this.opts.namedPlaceholders) {
            const paramLen = Array.isArray(values[0]) ? values[0].length : values[0] ? 1 : 0;
            if (paramLen === 0) return false;
            for (let r = 0; r < values.length; r++) {
              let row = values[r];
              if (!Array.isArray(row)) row = [row];
              if (paramLen !== row.length) {
                return false;
              }
              for (let j = 0; j < paramLen; j++) {
                const val = row[j];
                if (val != null && typeof val === "object" && typeof val.pipe === "function" && typeof val.read === "function") {
                  return false;
                }
              }
            }
          } else {
            for (let r = 0; r < values.length; r++) {
              let row = values[r];
              const keys = Object.keys(row);
              for (let j = 0; j < keys.length; j++) {
                const val = row[keys[j]];
                if (val != null && typeof val === "object" && typeof val.pipe === "function" && typeof val.read === "function") {
                  return false;
                }
              }
            }
          }
        }
        return true;
      }
      return false;
    }
    executeSessionVariableQuery() {
      if (this.opts.sessionVariables) {
        const values = [];
        let sessionQuery = "set ";
        let keys = Object.keys(this.opts.sessionVariables);
        if (keys.length > 0) {
          for (let k = 0; k < keys.length; ++k) {
            sessionQuery += (k !== 0 ? "," : "") + "@@" + keys[k].replace(/[^a-z0-9_]/gi, "") + "=?";
            values.push(this.opts.sessionVariables[keys[k]]);
          }
          return new Promise(
            this.query.bind(this, {
              sql: sessionQuery,
              values
            })
          ).catch((initialErr) => {
            const err = Errors.createFatalError(
              `Error setting session variable (value ${JSON.stringify(this.opts.sessionVariables)}). Error: ${initialErr.message}`,
              Errors.ER_SETTING_SESSION_ERROR,
              this.info,
              "08S01",
              sessionQuery
            );
            if (this.opts.logger.error) this.opts.logger.error(err);
            return Promise.reject(err);
          });
        }
      }
      return Promise.resolve();
    }
    /**
     * set charset to charset/collation if set or utf8mb4 if not.
     * @returns {Promise<void>}
     * @private
     */
    handleCharset() {
      if (this.opts.collation) {
        if (this.opts.collation.index <= 255) return Promise.resolve();
        const charset = this.opts.collation.charset === "utf8" && this.opts.collation.maxLength === 4 ? "utf8mb4" : this.opts.collation.charset;
        return new Promise(
          this.query.bind(this, {
            sql: `SET NAMES ${charset} COLLATE ${this.opts.collation.name}`
          })
        );
      }
      if (!this.opts.charset && this.info.collation && this.info.collation.charset === "utf8" && this.info.collation.maxLength === 4) {
        this.info.collation = Collations.fromCharset("utf8mb4");
        return Promise.resolve();
      }
      const connCharset = this.opts.charset ? this.opts.charset : "utf8mb4";
      this.info.collation = Collations.fromCharset(connCharset);
      return new Promise(
        this.query.bind(this, {
          sql: `SET NAMES ${connCharset}`
        })
      );
    }
    /**
     * Asking server timezone if not set in case of 'auto'
     * @returns {Promise<void>}
     * @private
     */
    handleTimezone() {
      const conn = this;
      if (this.opts.timezone === "local") this.opts.timezone = void 0;
      if (this.opts.timezone === "auto") {
        return new Promise(
          this.query.bind(this, {
            sql: "SELECT @@system_time_zone stz, @@time_zone tz"
          })
        ).then((res) => {
          const serverTimezone = res[0].tz === "SYSTEM" ? res[0].stz : res[0].tz;
          const localTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
          if (serverTimezone === localTz || convertFixedTime(serverTimezone, conn) === convertFixedTime(localTz, conn)) {
            this.opts.timezone = localTz;
            return Promise.resolve();
          }
          return this._setSessionTimezone(convertFixedTime(localTz, conn));
        });
      }
      if (this.opts.timezone) {
        return this._setSessionTimezone(convertFixedTime(this.opts.timezone, conn));
      }
      return Promise.resolve();
    }
    _setSessionTimezone(tz) {
      return new Promise(
        this.query.bind(this, {
          sql: "SET time_zone=?",
          values: [tz]
        })
      ).catch((err) => {
        const er = Errors.createFatalError(
          `setting timezone '${tz}' fails on server.
 look at https://mariadb.com/kb/en/mysql_tzinfo_to_sql/ to load IANA timezone. `,
          Errors.ER_WRONG_IANA_TIMEZONE,
          this.info
        );
        if (this.opts.logger.error) this.opts.logger.error(er);
        return Promise.reject(er);
      });
    }
    checkServerVersion() {
      if (!this.opts.forceVersionCheck) {
        return Promise.resolve();
      }
      return new Promise(
        this.query.bind(this, {
          sql: "SELECT @@VERSION AS v"
        })
      ).then(
        (function(res) {
          this.info.serverVersion.raw = res[0].v;
          this.info.serverVersion.mariaDb = this.info.serverVersion.raw.includes("MariaDB");
          ConnectionInformation.parseVersionString(this.info);
          return Promise.resolve();
        }).bind(this)
      );
    }
    executeInitQuery() {
      if (this.opts.initSql) {
        const initialArr = Array.isArray(this.opts.initSql) ? this.opts.initSql : [this.opts.initSql];
        const initialPromises = [];
        initialArr.forEach((sql) => {
          initialPromises.push(
            new Promise(
              this.query.bind(this, {
                sql
              })
            )
          );
        });
        return Promise.all(initialPromises).catch((initialErr) => {
          const err = Errors.createFatalError(
            `Error executing initial sql command: ${initialErr.message}`,
            Errors.ER_INITIAL_SQL_ERROR,
            this.info
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          return Promise.reject(err);
        });
      }
      return Promise.resolve();
    }
    executeSessionTimeout() {
      if (this.opts.queryTimeout) {
        if (this.info.isMariaDB() && this.info.hasMinVersion(10, 1, 2)) {
          const query2 = `SET max_statement_time=${this.opts.queryTimeout / 1e3}`;
          new Promise(
            this.query.bind(this, {
              sql: query2
            })
          ).catch(
            (function(initialErr) {
              const err = Errors.createFatalError(
                `Error setting session queryTimeout: ${initialErr.message}`,
                Errors.ER_INITIAL_TIMEOUT_ERROR,
                this.info,
                "08S01",
                query2
              );
              if (this.opts.logger.error) this.opts.logger.error(err);
              return Promise.reject(err);
            }).bind(this)
          );
        } else {
          const err = Errors.createError(
            `Can only use queryTimeout for MariaDB server after 10.1.1. queryTimeout value: ${this.opts.queryTimeout}`,
            Errors.ER_TIMEOUT_NOT_SUPPORTED,
            this.info,
            "HY000",
            this.opts.queryTimeout
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          return Promise.reject(err);
        }
      }
      return Promise.resolve();
    }
    getSocket() {
      return this.socket;
    }
    /**
     * Initialize socket and associate events.
     * @private
     */
    streamInitSocket() {
      if (this.opts.connectTimeout) {
        this.timeout = setTimeout(this.connectTimeoutReached.bind(this), this.opts.connectTimeout, Date.now());
      }
      if (this.opts.socketPath) {
        this.socket = Net.connect(this.opts.socketPath);
        if (this.opts.enableKeepAlive) {
          this.stream.on("connect", () => {
            this.stream.setKeepAlive(true, this.opts.keepAliveInitialDelay);
          });
        }
      } else if (this.opts.stream) {
        if (typeof this.opts.stream === "function") {
          const tmpSocket = this.opts.stream(
            (function(err, stream2) {
              if (err) {
                this.authFailHandler(err);
                return;
              }
              this.socket = stream2 ? stream2 : Net.connect(this.opts.port, this.opts.host);
              this.socketInit();
            }).bind(this)
          );
          if (tmpSocket) {
            this.socket = tmpSocket;
            this.socketInit();
          }
        } else {
          this.authFailHandler(
            Errors.createError(
              "stream option is not a function. stream must be a function with (error, callback) parameter",
              Errors.ER_BAD_PARAMETER_VALUE,
              this.info
            )
          );
        }
        return;
      } else {
        this.socket = Net.connect(this.opts.port, this.opts.host);
        this.socket.setNoDelay(true);
      }
      this.socketInit();
    }
    socketInit() {
      this.socket.on("data", this.streamIn.onData.bind(this.streamIn));
      this.socket.on("error", this.socketErrorHandler.bind(this));
      this.socket.on("end", this.socketErrorHandler.bind(this));
      this.socket.on(
        "connect",
        (function() {
          if (this.status === Status.CONNECTING) {
            this.status = Status.AUTHENTICATING;
            this.socket.setTimeout(this.opts.socketTimeout, this.socketTimeoutReached.bind(this));
            this.socket.setNoDelay(true);
            if (this.opts.keepAliveDelay) {
              this.socket.setKeepAlive(true, this.opts.keepAliveDelay);
            }
          }
        }).bind(this)
      );
      this.socket.writeBuf = (buf) => this.socket.write(buf);
      this.socket.flush = () => {
      };
      this.streamOut.setStream(this.socket);
    }
    /**
     * Authentication success result handler.
     *
     * @private
     */
    authSucceedHandler() {
      if (this.opts.compress) {
        if (this.info.serverCapabilities & Capabilities.COMPRESS) {
          this.streamOut.setStream(new CompressionOutputStream(this.socket, this.opts, this.info));
          this.streamIn = new CompressionInputStream(this.streamIn, this.receiveQueue, this.opts, this.info);
          this.socket.removeAllListeners("data");
          this.socket.on("data", this.streamIn.onData.bind(this.streamIn));
        } else if (this.opts.logger.error) {
          this.opts.logger.error(
            Errors.createError(
              "connection is configured to use packet compression, but the server doesn't have this capability",
              Errors.ER_COMPRESSION_NOT_SUPPORTED,
              this.info
            )
          );
        }
      }
      this.addCommand = this.opts.pipelining ? this.addCommandEnablePipeline : this.addCommandEnable;
      const conn = this;
      this.status = Status.INIT_CMD;
      this.executeSessionVariableQuery().then(conn.handleCharset.bind(conn)).then(this.handleTimezone.bind(this)).then(this.checkServerVersion.bind(this)).then(this.executeInitQuery.bind(this)).then(this.executeSessionTimeout.bind(this)).then(() => {
        clearTimeout(this.timeout);
        conn.status = Status.CONNECTED;
        process.nextTick(conn.connectResolveFct, conn);
        const commands = conn.waitingAuthenticationQueue.toArray();
        commands.forEach((cmd) => {
          conn.addCommand(cmd, true);
        });
        conn.waitingAuthenticationQueue = null;
        conn.connectRejectFct = null;
        conn.connectResolveFct = null;
      }).catch((err) => {
        if (!err.fatal) {
          const res = () => {
            conn.authFailHandler.call(conn, err);
          };
          conn.end(res, res);
        } else {
          conn.authFailHandler.call(conn, err);
        }
        return Promise.reject(err);
      });
    }
    /**
     * Authentication failed result handler.
     *
     * @private
     */
    authFailHandler(err) {
      clearTimeout(this.timeout);
      if (this.connectRejectFct) {
        if (this.opts.logger.error) this.opts.logger.error(err);
        this.receiveQueue.shift();
        this.fatalError(err, true);
        process.nextTick(this.connectRejectFct, err);
        this.connectRejectFct = null;
      }
    }
    /**
     * Create TLS socket and associate events.
     *
     * @param info current connection information
     * @param callback  callback function when done
     * @private
     */
    createSecureContext(info, callback) {
      info.requireValidCert = this.opts.ssl === true || this.opts.ssl.rejectUnauthorized === void 0 || this.opts.ssl.rejectUnauthorized === true;
      info.requireIdentifyCheck = this.opts.ssl === true || this.opts.ssl.checkServerIdentity === void 0;
      const baseConf = {
        servername: this.opts.host,
        socket: this.socket,
        rejectUnauthorized: false,
        checkServerIdentity: () => {
        }
      };
      const sslOption = this.opts.ssl === true ? baseConf : Object.assign({}, this.opts.ssl, baseConf);
      try {
        const secureSocket = tls.connect(sslOption, callback);
        secureSocket.on("data", this.streamIn.onData.bind(this.streamIn));
        secureSocket.on("error", this.socketErrorHandler.bind(this));
        secureSocket.on("end", this.socketErrorHandler.bind(this));
        secureSocket.writeBuf = (buf) => secureSocket.write(buf);
        secureSocket.flush = () => {
        };
        this.socket.removeAllListeners("data");
        this.socket = secureSocket;
        this.streamOut.setStream(secureSocket);
      } catch (err) {
        this.socketErrorHandler(err);
      }
    }
    /**
     * Handle packet when no packet is expected.
     * (there can be an ERROR packet send by server/proxy to inform that connection is ending).
     *
     * @param packet  packet
     * @private
     */
    unexpectedPacket(packet2) {
      if (packet2 && packet2.peek() === 255) {
        let err = packet2.readError(this.info);
        if (err.fatal && this.status < Status.CLOSING) {
          this.emit("error", err);
          if (this.opts.logger.error) this.opts.logger.error(err);
          this.end(
            () => {
            },
            () => {
            }
          );
        }
      } else if (this.status < Status.CLOSING) {
        const err = Errors.createFatalError(
          `receiving packet from server without active commands
conn:${this.info.threadId ? this.info.threadId : -1}(${packet2.pos},${packet2.end})
${Utils.log(this.opts, packet2.buf, packet2.pos, packet2.end)}`,
          Errors.ER_UNEXPECTED_PACKET,
          this.info
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        this.emit("error", err);
        this.destroy();
      }
    }
    /**
     * Handle connection timeout.
     *
     * @private
     */
    connectTimeoutReached(initialConnectionTime) {
      this.timeout = null;
      const handshake2 = this.receiveQueue.peekFront();
      const err = Errors.createFatalError(
        `Connection timeout: failed to create socket after ${Date.now() - initialConnectionTime}ms`,
        Errors.ER_CONNECTION_TIMEOUT,
        this.info,
        "08S01",
        null,
        handshake2 ? handshake2.stack : null
      );
      if (this.opts.logger.error) this.opts.logger.error(err);
      this.authFailHandler(err);
    }
    /**
     * Handle socket timeout.
     *
     * @private
     */
    socketTimeoutReached() {
      const err = Errors.createFatalError("socket timeout", Errors.ER_SOCKET_TIMEOUT, this.info);
      if (this.opts.logger.error) this.opts.logger.error(err);
      this.fatalError(err, true);
    }
    /**
     * Add command to waiting queue until authentication.
     *
     * @param cmd         command
     * @private
     */
    addCommandQueue(cmd) {
      this.waitingAuthenticationQueue.push(cmd);
    }
    /**
     * Add command to command sending and receiving queue.
     *
     * @param cmd         command
     * @param expectResponse queue command response
     * @private
     */
    addCommandEnable(cmd, expectResponse) {
      cmd.once("end", this._sendNextCmdImmediate.bind(this));
      if (this.sendQueue.isEmpty() && this.receiveQueue.isEmpty()) {
        if (expectResponse) this.receiveQueue.push(cmd);
        cmd.start(this.streamOut, this.opts, this.info);
      } else {
        if (expectResponse) this.receiveQueue.push(cmd);
        this.sendQueue.push(cmd);
      }
    }
    /**
     * Add command to command sending and receiving queue using pipelining
     *
     * @param cmd             command
     * @param expectResponse queue command response
     * @private
     */
    addCommandEnablePipeline(cmd, expectResponse) {
      cmd.once("send_end", this._sendNextCmdImmediate.bind(this));
      if (expectResponse) this.receiveQueue.push(cmd);
      if (this.sendQueue.isEmpty()) {
        cmd.start(this.streamOut, this.opts, this.info);
        if (cmd.sending) {
          this.sendQueue.push(cmd);
          cmd.prependOnceListener("send_end", this.sendQueue.shift.bind(this.sendQueue));
        }
      } else {
        this.sendQueue.push(cmd);
      }
    }
    /**
     * Replacing command when connection is closing or closed to send a proper error message.
     *
     * @param cmd         command
     * @private
     */
    addCommandDisabled(cmd) {
      const err = cmd.throwNewError(
        "Cannot execute new commands: connection closed",
        true,
        this.info,
        "08S01",
        Errors.ER_CMD_CONNECTION_CLOSED
      );
      if (this.opts.logger.error) this.opts.logger.error(err);
    }
    /**
     * Handle socket error.
     *
     * @param err               socket error
     * @private
     */
    socketErrorHandler(err) {
      if (this.status >= Status.CLOSING) return;
      if (this.socket) {
        this.socket.writeBuf = () => {
        };
        this.socket.flush = () => {
        };
      }
      if (!err) {
        err = Errors.createFatalError(
          "socket has unexpectedly been closed",
          Errors.ER_SOCKET_UNEXPECTED_CLOSE,
          this.info
        );
      } else {
        err.fatal = true;
        err.sqlState = "HY000";
      }
      switch (this.status) {
        case Status.CONNECTING:
        case Status.AUTHENTICATING:
          const currentCmd = this.receiveQueue.peekFront();
          if (currentCmd && currentCmd.stack && err) {
            err.stack += "\n From event:\n" + currentCmd.stack.substring(currentCmd.stack.indexOf("\n") + 1);
          }
          this.authFailHandler(err);
          break;
        default:
          this.fatalError(err, false);
      }
    }
    /**
     * Fatal unexpected error : closing connection, and throw exception.
     */
    fatalError(err, avoidThrowError) {
      if (this.status >= Status.CLOSING) {
        this.socketErrorDispatchToQueries(err);
        return;
      }
      const mustThrowError = this.status !== Status.CONNECTING;
      this.status = Status.CLOSING;
      this.addCommand = this.addCommandDisabled;
      if (this.socket) {
        this.socket.removeAllListeners("error");
        this.socket.removeAllListeners("timeout");
        this.socket.removeAllListeners("close");
        this.socket.removeAllListeners("data");
        if (!this.socket.destroyed) this.socket.destroy();
        this.socket = void 0;
      }
      this.status = Status.CLOSED;
      const errorThrownByCmd = this.socketErrorDispatchToQueries(err);
      if (mustThrowError) {
        if (this.opts.logger.error) this.opts.logger.error(err);
        if (this.listenerCount("error") > 0) {
          this.emit("error", err);
          this.emit("end");
          this.clear();
        } else {
          this.emit("end");
          this.clear();
          if (!avoidThrowError && !errorThrownByCmd) throw err;
        }
      } else {
        this.clear();
      }
    }
    /**
     * Dispatch fatal error to current running queries.
     *
     * @param err        the fatal error
     * @return {boolean} return if error has been relayed to queries
     */
    socketErrorDispatchToQueries(err) {
      let receiveCmd;
      let errorThrownByCmd = false;
      while (receiveCmd = this.receiveQueue.shift()) {
        if (receiveCmd && receiveCmd.onPacketReceive) {
          errorThrownByCmd = true;
          setImmediate(receiveCmd.throwError.bind(receiveCmd, err, this.info));
        }
      }
      return errorThrownByCmd;
    }
    /**
     * Will send next command in queue if any.
     *
     * @private
     */
    nextSendCmd() {
      let sendCmd;
      if (sendCmd = this.sendQueue.shift()) {
        if (sendCmd.sending) {
          this.sendQueue.unshift(sendCmd);
        } else {
          sendCmd.start(this.streamOut, this.opts, this.info);
          if (sendCmd.sending) {
            this.sendQueue.unshift(sendCmd);
            sendCmd.prependOnceListener("send_end", this.sendQueue.shift.bind(this.sendQueue));
          }
        }
      }
    }
    /**
     * Change transaction state.
     *
     * @param cmdParam command parameter
     * @param resolve success function to call
     * @param reject error function to call
     * @private
     */
    changeTransaction(cmdParam, resolve, reject) {
      if (this.status >= Status.CLOSING) {
        const err = Errors.createFatalError(
          "Cannot execute new commands: connection closed",
          Errors.ER_CMD_CONNECTION_CLOSED,
          this.info,
          "08S01",
          cmdParam.sql
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        reject(err);
        return;
      }
      if (this.receiveQueue.peekFront() || this.info.status & ServerStatus.STATUS_IN_TRANS) {
        const cmd = new Query(
          resolve,
          (err) => {
            if (this.opts.logger.error) this.opts.logger.error(err);
            reject(err);
          },
          this.opts,
          cmdParam
        );
        this.addCommand(cmd, true);
      } else resolve();
    }
    changeUser(cmdParam, resolve, reject) {
      if (!this.info.isMariaDB()) {
        const err = Errors.createError(
          "method changeUser not available for MySQL server due to Bug #83472",
          Errors.ER_MYSQL_CHANGE_USER_BUG,
          this.info,
          "0A000"
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        reject(err);
        return;
      }
      if (this.status < Status.CLOSING) {
        this.addCommand = this.addCommandEnable;
      }
      let conn = this;
      if (cmdParam.opts && cmdParam.opts.collation && typeof cmdParam.opts.collation === "string") {
        const val = cmdParam.opts.collation.toUpperCase();
        cmdParam.opts.collation = Collations.fromName(cmdParam.opts.collation.toUpperCase());
        if (cmdParam.opts.collation === void 0) return reject(new RangeError(`Unknown collation '${val}'`));
      }
      this.addCommand(
        new ChangeUser(
          cmdParam,
          this.opts,
          (res) => {
            if (conn.status < Status.CLOSING && conn.opts.pipelining) conn.addCommand = conn.addCommandEnablePipeline;
            if (cmdParam.opts && cmdParam.opts.collation) conn.opts.collation = cmdParam.opts.collation;
            conn.handleCharset().then(() => {
              if (cmdParam.opts && cmdParam.opts.collation) {
                conn.info.collation = cmdParam.opts.collation;
                conn.opts.emit("collation", cmdParam.opts.collation);
              }
              resolve(res);
            }).catch((err) => {
              const res2 = () => conn.authFailHandler.call(conn, err);
              if (!err.fatal) {
                conn.end(res2, res2);
              } else {
                res2();
              }
              reject(err);
            });
          },
          this.authFailHandler.bind(this, reject),
          this.getSocket.bind(this)
        ),
        true
      );
    }
    query(cmdParam, resolve, reject) {
      if (!cmdParam.sql)
        return reject(
          Errors.createError(
            "sql parameter is mandatory",
            Errors.ER_UNDEFINED_SQL,
            this.info,
            "HY000",
            null,
            false,
            cmdParam.stack
          )
        );
      const cmd = new Query(
        resolve,
        (err) => {
          if (this.opts.logger.error) this.opts.logger.error(err);
          reject(err);
        },
        this.opts,
        cmdParam
      );
      this.addCommand(cmd, true);
    }
    prepare(cmdParam, resolve, reject) {
      if (!cmdParam.sql)
        return reject(Errors.createError("sql parameter is mandatory", Errors.ER_UNDEFINED_SQL, this.info, "HY000"));
      if (this.prepareCache && (this.sendQueue.isEmpty() || !this.receiveQueue.peekFront())) {
        const cachedPrepare = this.prepareCache.get(cmdParam.sql);
        if (cachedPrepare) {
          return resolve(cachedPrepare);
        }
      }
      const cmd = new Prepare(
        resolve,
        (err) => {
          if (this.opts.logger.error) this.opts.logger.error(err);
          reject(err);
        },
        this.opts,
        cmdParam,
        this
      );
      this.addCommand(cmd, true);
    }
    prepareExecute(cmdParam) {
      if (!cmdParam.sql) {
        return Promise.reject(
          Errors.createError("sql parameter is mandatory", Errors.ER_UNDEFINED_SQL, this.info, "HY000")
        );
      }
      if (this.prepareCache && (this.sendQueue.isEmpty() || !this.receiveQueue.peekFront())) {
        const cachedPrepare = this.prepareCache.get(cmdParam.sql);
        if (cachedPrepare) {
          return new Promise(this.executePromise.bind(this, cmdParam, cachedPrepare)).finally(
            () => cachedPrepare.close()
          );
        }
      }
      const conn = this;
      if (this.opts.pipelining && this.info.isMariaDB() && this.info.hasMinVersion(10, 2, 4)) {
        let hasStreamingValue = false;
        const vals = cmdParam.values ? Array.isArray(cmdParam.values) ? cmdParam.values : [cmdParam.values] : [];
        for (let i = 0; i < vals.length; i++) {
          const val = vals[i];
          if (val != null && typeof val === "object" && typeof val.pipe === "function" && typeof val.read === "function") {
            hasStreamingValue = true;
          }
        }
        if (!hasStreamingValue) {
          return new Promise((resolve, reject) => {
            let nbExecute = 0;
            const executeCommand = new Execute(
              (res) => {
                if (nbExecute++ === 0) {
                  executeCommand.prepare.close();
                  resolve(res);
                }
              },
              (err) => {
                if (nbExecute++ === 0) {
                  if (conn.opts.logger.error) conn.opts.logger.error(err);
                  reject(err);
                  if (executeCommand.prepare) {
                    executeCommand.prepare.close();
                  }
                }
              },
              conn.opts,
              cmdParam,
              null
            );
            cmdParam.executeCommand = executeCommand;
            const cmd = new Prepare(
              (prep) => {
                if (nbExecute > 0) prep.close();
              },
              (err) => {
                if (nbExecute++ === 0) {
                  if (conn.opts.logger.error) conn.opts.logger.error(err);
                  reject(err);
                }
              },
              conn.opts,
              cmdParam,
              conn
            );
            conn.addCommand(cmd, true);
            conn.addCommand(executeCommand, true);
          });
        }
      }
      return new Promise((resolve, reject) => {
        const cmd = new Prepare(resolve, reject, this.opts, cmdParam, conn);
        conn.addCommand(cmd, true);
      }).then((prepare2) => {
        return new Promise(function(resolve, reject) {
          conn.executePromise.call(conn, cmdParam, prepare2, resolve, reject);
        }).finally(() => prepare2.close());
      }).catch((err) => {
        if (conn.opts.logger.error) conn.opts.logger.error(err);
        throw err;
      });
    }
    importFile(cmdParam, resolve, reject) {
      const conn = this;
      if (!cmdParam || !cmdParam.file) {
        return reject(
          Errors.createError(
            "SQL file parameter is mandatory",
            Errors.ER_MISSING_SQL_PARAMETER,
            conn.info,
            "HY000",
            null,
            false,
            cmdParam.stack
          )
        );
      }
      const prevAddCommand = this.addCommand.bind(conn);
      this.waitingAuthenticationQueue = new Queue();
      this.addCommand = this.addCommandQueue;
      const tmpQuery = function(sql, resolve2, reject2) {
        const cmd = new Query(
          resolve2,
          (err) => {
            if (conn.opts.logger.error) conn.opts.logger.error(err);
            reject2(err);
          },
          conn.opts,
          {
            sql,
            opts: {}
          }
        );
        prevAddCommand(cmd, true);
      };
      let prevDatabase = null;
      return (cmdParam.skipDbCheck ? Promise.resolve() : new Promise(tmpQuery.bind(conn, "SELECT DATABASE() as db"))).then((res) => {
        prevDatabase = res ? res[0].db : null;
        if (cmdParam.skipDbCheck && !conn.opts.database || !cmdParam.skipDbCheck && !cmdParam.database && !prevDatabase) {
          return reject(
            Errors.createError(
              "Database parameter is not set and no database is selected",
              Errors.ER_MISSING_DATABASE_PARAMETER,
              conn.info,
              "HY000",
              null,
              false,
              cmdParam.stack
            )
          );
        }
        const searchDbPromise = cmdParam.database ? new Promise(tmpQuery.bind(conn, `USE \`${cmdParam.database.replace(/`/gi, "``")}\``)) : Promise.resolve();
        return searchDbPromise.then(() => {
          const endingFunction = () => {
            if (conn.status < Status.CLOSING) {
              conn.addCommand = conn.addCommandEnable.bind(conn);
              if (conn.status < Status.CLOSING && conn.opts.pipelining) {
                conn.addCommand = conn.addCommandEnablePipeline.bind(conn);
              }
              const commands = conn.waitingAuthenticationQueue.toArray();
              commands.forEach((cmd) => conn.addCommand(cmd, true));
              conn.waitingAuthenticationQueue = null;
            }
          };
          return fsPromises.open(cmdParam.file, "r").then(async (fd) => {
            const buf = {
              buffer: Buffer.allocUnsafe(16384),
              offset: 0,
              end: 0
            };
            const queryPromises = [];
            let cmdError = null;
            while (!cmdError) {
              try {
                const res2 = await fd.read(buf.buffer, buf.end, buf.buffer.length - buf.end, null);
                if (res2.bytesRead === 0) {
                  fd.close().catch(() => {
                  });
                  if (cmdError) {
                    endingFunction();
                    reject(cmdError);
                    return;
                  }
                  await Promise.allSettled(queryPromises).then(() => {
                    if (!cmdParam.skipDbCheck && prevDatabase && cmdParam.database && cmdParam.database !== prevDatabase) {
                      return new Promise(tmpQuery.bind(conn, `USE \`${prevDatabase.replace(/`/gi, "``")}\``));
                    }
                    return Promise.resolve();
                  }).then(() => {
                    endingFunction();
                    if (cmdError) {
                      reject(cmdError);
                    }
                    resolve();
                  }).catch((err) => {
                    endingFunction();
                    reject(err);
                  });
                  return;
                } else {
                  buf.end += res2.bytesRead;
                  const queries = Parse.parseQueries(buf);
                  const queryIntermediatePromise = queries.flatMap((element) => {
                    return new Promise(tmpQuery.bind(conn, element)).catch((err) => {
                      cmdError = err;
                    });
                  });
                  queryPromises.push(...queryIntermediatePromise);
                  if (buf.offset === buf.end) {
                    buf.offset = 0;
                    buf.end = 0;
                  } else {
                    if (buf.offset > 8192) {
                      buf.buffer.copy(buf.buffer, 0, buf.offset, buf.end);
                      buf.end -= buf.offset;
                      buf.offset = 0;
                    } else if (buf.buffer.length - buf.end < 8192) {
                      const tmpBuf = Buffer.allocUnsafe(buf.buffer.length << 1);
                      buf.buffer.copy(tmpBuf, 0, buf.offset, buf.end);
                      buf.buffer = tmpBuf;
                      buf.end -= buf.offset;
                      buf.offset = 0;
                    }
                  }
                }
              } catch (e) {
                fd.close().catch(() => {
                });
                endingFunction();
                Promise.allSettled(queryPromises).catch(() => {
                });
                return reject(
                  Errors.createError(
                    e.message,
                    Errors.ER_SQL_FILE_ERROR,
                    conn.info,
                    "HY000",
                    null,
                    false,
                    cmdParam.stack
                  )
                );
              }
            }
            if (cmdError) {
              endingFunction();
              reject(cmdError);
            }
          }).catch((err) => {
            endingFunction();
            if (err.code === "ENOENT") {
              return reject(
                Errors.createError(
                  `SQL file parameter '${cmdParam.file}' doesn't exists`,
                  Errors.ER_MISSING_SQL_FILE,
                  conn.info,
                  "HY000",
                  null,
                  false,
                  cmdParam.stack
                )
              );
            }
            return reject(
              Errors.createError(err.message, Errors.ER_SQL_FILE_ERROR, conn.info, "HY000", null, false, cmdParam.stack)
            );
          });
        });
      });
    }
    /**
     * Clearing connection variables when ending.
     *
     * @private
     */
    clear() {
      this.sendQueue.clear();
      this.opts.removeAllListeners();
      this.streamOut = void 0;
      this.socket = void 0;
    }
    /**
     * Redirecting connection to server indicated value.
     * @param value server host string
     * @param resolve promise result when done
     */
    redirect(value, resolve) {
      if (this.opts.permitRedirect && value) {
        if (this.receiveQueue.length <= 1 && (this.info.status & ServerStatus.STATUS_IN_TRANS) === 0) {
          this.info.redirectRequest = null;
          const matchResults = value.match(redirectUrlFormat);
          if (!matchResults) {
            if (this.opts.logger.error)
              this.opts.logger.error(
                new Error(
                  `error parsing redirection string '${value}'. format must be 'mariadb/mysql://[<user>[:<password>]@]<host>[:<port>]/[<db>[?<opt1>=<value1>[&<opt2>=<value2>]]]'`
                )
              );
            return resolve();
          }
          const options = {
            host: matchResults[7] ? decodeURIComponent(matchResults[7]) : matchResults[6],
            port: matchResults[9] ? parseInt(matchResults[9]) : 3306
          };
          if (options.host === this.opts.host && options.port === this.opts.port) {
            return resolve();
          }
          if (matchResults[3]) options.user = matchResults[3];
          if (matchResults[5]) options.password = matchResults[5];
          const redirectOpts = ConnectionOptions.parseOptionDataType(options);
          const finalRedirectOptions = new ConnOptions(Object.assign({}, this.opts, redirectOpts));
          const conn = new Connection(finalRedirectOptions);
          conn.connect().then(
            (async function() {
              await new Promise(this.end.bind(this, {}));
              this.status = Status.CONNECTED;
              this.info = conn.info;
              this.opts = conn.opts;
              this.socket = conn.socket;
              if (this.prepareCache) this.prepareCache.reset();
              this.streamOut = conn.streamOut;
              this.streamIn = conn.streamIn;
              resolve();
            }).bind(this)
          ).catch(
            (function(e) {
              if (this.opts.logger.error) {
                const err = new Error(`fail to redirect to '${value}'`);
                err.cause = e;
                this.opts.logger.error(err);
              }
              resolve();
            }).bind(this)
          );
        } else {
          this.info.redirectRequest = value;
          resolve();
        }
      } else {
        this.info.redirectRequest = null;
        resolve();
      }
    }
    get threadId() {
      return this.info ? this.info.threadId : null;
    }
    _sendNextCmdImmediate() {
      if (!this.sendQueue.isEmpty()) {
        setImmediate(this.nextSendCmd.bind(this));
      }
    }
    _closePrepare(prepareResultPacket2) {
      this.addCommand(
        new ClosePrepare(
          {},
          () => {
          },
          () => {
          },
          prepareResultPacket2
        ),
        false
      );
    }
    _logAndReject(reject, err) {
      if (this.opts.logger.error) this.opts.logger.error(err);
      reject(err);
    }
  }
  class TestMethods {
    constructor(collation, socket) {
      __privateAdd(this, _collation);
      __privateAdd(this, _socket);
      __privateSet(this, _collation, collation);
      __privateSet(this, _socket, socket);
    }
    getCollation() {
      return __privateGet(this, _collation);
    }
    getSocket() {
      return __privateGet(this, _socket);
    }
  }
  _collation = new WeakMap();
  _socket = new WeakMap();
  connection = Connection;
  return connection;
}
var connectionPromise = { exports: {} };
var stream;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream;
  hasRequiredStream = 1;
  const Query = requireQuery();
  const { Readable } = require$$0$4;
  class Stream extends Query {
    constructor(cmdParam, connOpts, socket) {
      super(
        () => {
        },
        () => {
        },
        connOpts,
        cmdParam
      );
      this.socket = socket;
      this.inStream = new Readable({
        objectMode: true,
        read: () => {
          this.socket.resume();
        }
      });
      this.on("fields", function(meta) {
        this.inStream.emit("fields", meta);
      });
      this.on("error", function(err) {
        this.inStream.emit("error", err);
      });
      this.on("close", function(err) {
        this.inStream.emit("error", err);
      });
      this.on("end", function(err) {
        if (err) this.inStream.emit("error", err);
        this.socket.resume();
        this.inStream.push(null);
      });
      this.inStream.close = (function() {
        this.handleNewRows = () => {
        };
        this.socket.resume();
      }).bind(this);
    }
    handleNewRows(row) {
      if (!this.inStream.push(row)) {
        this.socket.pause();
      }
    }
  }
  stream = Stream;
  return stream;
}
var hasRequiredConnectionPromise;
function requireConnectionPromise() {
  var _conn, _capture;
  if (hasRequiredConnectionPromise) return connectionPromise.exports;
  hasRequiredConnectionPromise = 1;
  const Stream = requireStream();
  const Errors = requireErrors();
  class ConnectionPromise {
    constructor(conn) {
      __privateAdd(this, _conn);
      __privateAdd(this, _capture);
      __privateSet(this, _conn, conn);
      __privateSet(this, _capture, conn.opts.trace ? Error.captureStackTrace : () => {
      });
    }
    get threadId() {
      return __privateGet(this, _conn).threadId;
    }
    get info() {
      return __privateGet(this, _conn).info;
    }
    get prepareCache() {
      return __privateGet(this, _conn).prepareCache;
    }
    /**
     * Permit to change user during connection.
     * All user variables will be reset, Prepare commands will be released.
     * !!! mysql has a bug when CONNECT_ATTRS capability is set, that is default !!!!
     *
     * @param options   connection options
     * @returns {Promise} promise
     */
    changeUser(options) {
      const param = { opts: options };
      __privateGet(this, _capture).call(this, param);
      return new Promise(__privateGet(this, _conn).changeUser.bind(__privateGet(this, _conn), param));
    }
    /**
     * Start transaction
     *
     * @returns {Promise} promise
     */
    beginTransaction() {
      const param = { sql: "START TRANSACTION" };
      __privateGet(this, _capture).call(this, param);
      return new Promise(__privateGet(this, _conn).query.bind(__privateGet(this, _conn), param));
    }
    /**
     * Commit a transaction.
     *
     * @returns {Promise} command if commit was needed only
     */
    commit() {
      const param = { sql: "COMMIT" };
      __privateGet(this, _capture).call(this, param);
      return new Promise(__privateGet(this, _conn).changeTransaction.bind(__privateGet(this, _conn), param));
    }
    /**
     * Roll back a transaction.
     *
     * @returns {Promise} promise
     */
    rollback() {
      const param = { sql: "ROLLBACK" };
      __privateGet(this, _capture).call(this, param);
      return new Promise(__privateGet(this, _conn).changeTransaction.bind(__privateGet(this, _conn), param));
    }
    /**
     * Execute query using text protocol.
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  object / array of placeholder values (not mandatory)
     * @returns {Promise} promise
     */
    query(sql, values) {
      const cmdParam = paramSetter(sql, values);
      __privateGet(this, _capture).call(this, cmdParam);
      return new Promise(__privateGet(this, _conn).query.bind(__privateGet(this, _conn), cmdParam));
    }
    static _PARAM_DEF(sql, values) {
      if (typeof sql === "object") {
        return { sql: sql.sql, values: sql.values ? sql.values : values, opts: sql };
      } else return { sql, values };
    }
    execute(sql, values) {
      const cmdParam = paramSetter(sql, values);
      __privateGet(this, _capture).call(this, cmdParam);
      return __privateGet(this, _conn).prepareExecute(cmdParam);
    }
    static _EXECUTE_CMD(conn, cmdParam) {
      return conn.prepareExecute(cmdParam);
    }
    prepare(sql) {
      let param;
      if (typeof sql === "object") {
        param = { sql: sql.sql, opts: sql };
      } else {
        param = { sql };
      }
      __privateGet(this, _capture).call(this, param);
      return new Promise(__privateGet(this, _conn).prepare.bind(__privateGet(this, _conn), param));
    }
    /**
     * Execute batch using text protocol.
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  object / array of placeholder values
     * @returns {Promise} promise
     */
    batch(sql, values) {
      const cmdParam = paramSetter(sql, values);
      __privateGet(this, _capture).call(this, cmdParam);
      return __privateGet(this, _conn).batch(cmdParam);
    }
    static _BATCH_CMD(conn, cmdParam) {
      return conn.batch(cmdParam);
    }
    /**
     * Import sql file.
     *
     * @param opts JSON array with 2 possible fields: file and database
     */
    importFile(opts) {
      if (!opts || !opts.file) {
        return Promise.reject(
          Errors.createError(
            "SQL file parameter is mandatory",
            Errors.ER_MISSING_SQL_PARAMETER,
            __privateGet(this, _conn).info,
            "HY000",
            null,
            false,
            null
          )
        );
      }
      return new Promise(__privateGet(this, _conn).importFile.bind(__privateGet(this, _conn), { file: opts.file, database: opts.database }));
    }
    /**
     * Execute query returning a Readable Object that will emit columns/data/end/error events
     * to permit streaming big result-set
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  object / array of placeholder values (not mandatory)
     * @returns {Readable}
     */
    queryStream(sql, values) {
      const cmdParam = paramSetter(sql, values);
      __privateGet(this, _capture).call(this, cmdParam);
      const cmd = new Stream(cmdParam, __privateGet(this, _conn).opts, __privateGet(this, _conn).socket);
      if (__privateGet(this, _conn).opts.logger.error) cmd.on("error", __privateGet(this, _conn).opts.logger.error);
      __privateGet(this, _conn).addCommand(cmd, true);
      return cmd.inStream;
    }
    /**
     * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout
     * @param timeout (optional) timeout value in ms. If reached, throw error and close connection
     * @returns {Promise} promise
     */
    ping(timeout) {
      const cmdParam = {
        opts: { timeout }
      };
      __privateGet(this, _capture).call(this, cmdParam);
      return new Promise(__privateGet(this, _conn).ping.bind(__privateGet(this, _conn), cmdParam));
    }
    /**
     * Send a reset command that will
     * - rollback any open transaction
     * - reset transaction isolation level
     * - reset session variables
     * - delete user variables
     * - remove temporary tables
     * - remove all PREPARE statement
     *
     * @returns {Promise} promise
     */
    reset() {
      const cmdParam = {};
      __privateGet(this, _capture).call(this, cmdParam);
      return new Promise(__privateGet(this, _conn).reset.bind(__privateGet(this, _conn), cmdParam));
    }
    /**
     * Indicates the state of the connection as the driver knows it
     * @returns {boolean}
     */
    isValid() {
      return __privateGet(this, _conn).isValid();
    }
    /**
     * Terminate connection gracefully.
     *
     * @returns {Promise} promise
     */
    end() {
      const cmdParam = {};
      __privateGet(this, _capture).call(this, cmdParam);
      return new Promise(__privateGet(this, _conn).end.bind(__privateGet(this, _conn), cmdParam));
    }
    /**
     * Alias for destroy.
     */
    close() {
      this.destroy();
    }
    /**
     * Force connection termination by closing the underlying socket and killing server process if any.
     */
    destroy() {
      __privateGet(this, _conn).destroy();
    }
    pause() {
      __privateGet(this, _conn).pause();
    }
    resume() {
      __privateGet(this, _conn).resume();
    }
    format(sql, values) {
      __privateGet(this, _conn).format(sql, values);
    }
    /**
     * return current connected server version information.
     *
     * @returns {*}
     */
    serverVersion() {
      return __privateGet(this, _conn).serverVersion();
    }
    /**
     * Change option "debug" during connection.
     * @param val   debug value
     */
    debug(val) {
      return __privateGet(this, _conn).debug(val);
    }
    debugCompress(val) {
      return __privateGet(this, _conn).debugCompress(val);
    }
    escape(val) {
      return __privateGet(this, _conn).escape(val);
    }
    escapeId(val) {
      return __privateGet(this, _conn).escapeId(val);
    }
    //*****************************************************************
    // EventEmitter proxy methods
    //*****************************************************************
    on(eventName, listener) {
      __privateGet(this, _conn).on.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    off(eventName, listener) {
      __privateGet(this, _conn).off.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    once(eventName, listener) {
      __privateGet(this, _conn).once.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    listeners(eventName) {
      return __privateGet(this, _conn).listeners.call(__privateGet(this, _conn), eventName);
    }
    addListener(eventName, listener) {
      __privateGet(this, _conn).addListener.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    eventNames() {
      return __privateGet(this, _conn).eventNames.call(__privateGet(this, _conn));
    }
    getMaxListeners() {
      return __privateGet(this, _conn).getMaxListeners.call(__privateGet(this, _conn));
    }
    listenerCount(eventName, listener) {
      return __privateGet(this, _conn).listenerCount.call(__privateGet(this, _conn), eventName, listener);
    }
    prependListener(eventName, listener) {
      __privateGet(this, _conn).prependListener.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    prependOnceListener(eventName, listener) {
      __privateGet(this, _conn).prependOnceListener.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    removeAllListeners(eventName, listener) {
      __privateGet(this, _conn).removeAllListeners.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    removeListener(eventName, listener) {
      __privateGet(this, _conn).removeListener.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    setMaxListeners(n) {
      __privateGet(this, _conn).setMaxListeners.call(__privateGet(this, _conn), n);
      return this;
    }
    rawListeners(eventName) {
      return __privateGet(this, _conn).rawListeners.call(__privateGet(this, _conn), eventName);
    }
    //*****************************************************************
    // internal public testing methods
    //*****************************************************************
    get __tests() {
      return __privateGet(this, _conn).__tests;
    }
  }
  _conn = new WeakMap();
  _capture = new WeakMap();
  const paramSetter = function(sql, values) {
    if (typeof sql === "object") {
      return { sql: sql.sql, values: sql.values ? sql.values : values, opts: sql };
    } else return { sql, values };
  };
  connectionPromise.exports = ConnectionPromise;
  connectionPromise.exports.paramSetter = paramSetter;
  return connectionPromise.exports;
}
var pool$1;
var hasRequiredPool;
function requirePool() {
  var _closed, _connectionInCreation, _errorCreatingConnection, _idleConnections, _activeConnections, _requests, _unusedConnectionRemoverId, _requestTimeoutId, _connErrorNumber, _initialized;
  if (hasRequiredPool) return pool$1;
  hasRequiredPool = 1;
  const { EventEmitter } = require$$0$3;
  const Queue = requireDenque();
  const Errors = requireErrors();
  const Utils = requireUtils$2();
  const Connection = requireConnection();
  class Pool extends EventEmitter {
    constructor(options) {
      super();
      __publicField(this, "opts");
      __privateAdd(this, _closed, false);
      __privateAdd(this, _connectionInCreation, false);
      __privateAdd(this, _errorCreatingConnection, null);
      __privateAdd(this, _idleConnections, new Queue());
      __privateAdd(this, _activeConnections, {});
      __privateAdd(this, _requests, new Queue());
      __privateAdd(this, _unusedConnectionRemoverId);
      __privateAdd(this, _requestTimeoutId);
      __privateAdd(this, _connErrorNumber, 0);
      __privateAdd(this, _initialized, false);
      __publicField(this, "_sizeHandlerTimeout");
      this.opts = options;
      this.on("_idle", this._requestsHandler);
      this.on("validateSize", this._sizeHandler);
      this._sizeHandler();
    }
    //*****************************************************************
    // pool automatic handlers
    //*****************************************************************
    _doCreateConnection(resolve, reject, timeoutEnd) {
      this._createConnection(timeoutEnd).then((conn) => {
        if (__privateGet(this, _closed)) {
          conn.forceEnd(
            null,
            () => {
            },
            () => {
            }
          );
          reject(
            new Errors.createFatalError(
              "Cannot create new connection to pool, pool closed",
              Errors.ER_ADD_CONNECTION_CLOSED_POOL
            )
          );
          return;
        }
        conn.lastUse = Date.now();
        const nativeDestroy = conn.destroy.bind(conn);
        const pool2 = this;
        conn.destroy = function() {
          pool2._endLeak(conn);
          delete __privateGet(pool2, _activeConnections)[conn.threadId];
          nativeDestroy();
          pool2.emit("validateSize");
        };
        conn.once("error", function() {
          let idx = 0;
          let currConn;
          pool2._endLeak(conn);
          delete __privateGet(pool2, _activeConnections)[conn.threadId];
          while (currConn = __privateGet(pool2, _idleConnections).peekAt(idx)) {
            if (currConn === conn) {
              __privateGet(pool2, _idleConnections).removeOne(idx);
              continue;
            }
            currConn.lastUse = Math.min(currConn.lastUse, Date.now() - pool2.opts.minDelayValidation);
            idx++;
          }
          setTimeout(() => {
            if (!__privateGet(pool2, _requests).isEmpty()) {
              pool2._sizeHandler();
            }
          }, 0);
        });
        __privateGet(this, _idleConnections).push(conn);
        __privateSet(this, _connectionInCreation, false);
        this.emit("_idle");
        this.emit("connection", conn);
        resolve(conn);
      }).catch((err) => {
        if (err instanceof AggregateError) {
          err = err.errors[0];
        }
        if (__privateGet(this, _closed) || err.errno && (err.errno === 1524 || err.errno === 1045 || err.errno === 1698) || timeoutEnd < Date.now()) {
          err.message = err.message + this._errorMsgAddon();
          reject(err);
          return;
        }
        setTimeout(this._doCreateConnection.bind(this, resolve, reject, timeoutEnd), 500);
      });
    }
    _destroy(conn) {
      this._endLeak(conn);
      delete __privateGet(this, _activeConnections)[conn.threadId];
      conn.lastUse = Date.now();
      conn.forceEnd(
        null,
        () => {
        },
        () => {
        }
      );
      if (this.totalConnections() === 0) {
        this._stopReaping();
      }
      this.emit("validateSize");
    }
    release(conn) {
      if (__privateGet(this, _activeConnections)[conn.threadId]) {
        this._endLeak(conn);
        __privateGet(this, _activeConnections)[conn.threadId] = null;
        conn.lastUse = Date.now();
        if (__privateGet(this, _closed)) {
          conn.forceEnd(
            null,
            () => {
            },
            () => {
            }
          );
        } else if (conn.isValid()) {
          this.emit("release", conn);
          __privateGet(this, _idleConnections).push(conn);
          process.nextTick(this.emit.bind(this, "_idle"));
        } else {
          this.emit("validateSize");
        }
      }
    }
    _checkLeak(conn) {
      conn.lastUse = Date.now();
      conn.leaked = false;
      conn.leakProcess = setTimeout(
        (conn2) => {
          conn2.leaked = true;
          conn2.opts.logger.warning(
            `A possible connection leak on the thread ${conn2.info.threadId} (the connection not returned to the pool since ${Date.now() - conn2.lastUse} ms). Has the connection.release() been called ?` + this._errorMsgAddon()
          );
        },
        this.opts.leakDetectionTimeout,
        conn
      );
    }
    _endLeak(conn) {
      if (conn.leakProcess) {
        clearTimeout(conn.leakProcess);
        conn.leakProcess = null;
        if (conn.leaked) {
          conn.opts.logger.warning(
            `Previous possible leak connection with thread ${conn.info.threadId} was returned to pool`
          );
        }
      }
    }
    /**
     * Permit to remove idle connection if unused for some time.
     */
    _startReaping() {
      if (!__privateGet(this, _unusedConnectionRemoverId) && this.opts.idleTimeout > 0) {
        __privateSet(this, _unusedConnectionRemoverId, setInterval(this._reaper.bind(this), 500));
      }
    }
    _stopReaping() {
      if (__privateGet(this, _unusedConnectionRemoverId) && this.totalConnections() === 0) {
        clearInterval(__privateGet(this, _unusedConnectionRemoverId));
      }
    }
    _reaper() {
      const idleTimeRemoval = Date.now() - this.opts.idleTimeout * 1e3;
      let maxRemoval = Math.max(0, __privateGet(this, _idleConnections).length - this.opts.minimumIdle);
      while (maxRemoval > 0) {
        const conn = __privateGet(this, _idleConnections).peek();
        maxRemoval--;
        if (conn && conn.lastUse < idleTimeRemoval) {
          __privateGet(this, _idleConnections).shift();
          conn.forceEnd(
            null,
            () => {
            },
            () => {
            }
          );
          continue;
        }
        break;
      }
      if (this.totalConnections() === 0) {
        this._stopReaping();
      }
      this.emit("validateSize");
    }
    _shouldCreateMoreConnections() {
      return !__privateGet(this, _connectionInCreation) && __privateGet(this, _idleConnections).length < this.opts.minimumIdle && this.totalConnections() < this.opts.connectionLimit && !__privateGet(this, _closed);
    }
    /**
     * Grow pool connections until reaching connection limit.
     */
    _sizeHandler() {
      if (this._shouldCreateMoreConnections() && !this._sizeHandlerTimeout) {
        __privateSet(this, _connectionInCreation, true);
        setImmediate(
          (function() {
            const timeoutEnd = Date.now() + this.opts.initializationTimeout;
            new Promise((resolve, reject) => {
              this._doCreateConnection(resolve, reject, timeoutEnd);
            }).then(() => {
              __privateSet(this, _initialized, true);
              __privateSet(this, _errorCreatingConnection, null);
              __privateSet(this, _connErrorNumber, 0);
              if (this._shouldCreateMoreConnections()) {
                this.emit("validateSize");
              }
              this._startReaping();
            }).catch((err) => {
              __privateSet(this, _connectionInCreation, false);
              if (!__privateGet(this, _closed)) {
                if (!__privateGet(this, _initialized)) {
                  err.message = "Error during pool initialization: " + err.message;
                } else {
                  err.message = "Pool fails to create connection: " + err.message;
                }
                __privateSet(this, _errorCreatingConnection, err);
                this.emit("error", err);
                this._sizeHandlerTimeout = setTimeout(
                  (function() {
                    this._sizeHandlerTimeout = null;
                    if (!__privateGet(this, _requests).isEmpty()) {
                      this._sizeHandler();
                    }
                  }).bind(this),
                  Math.min(++__privateWrapper(this, _connErrorNumber)._ * 500, 1e4)
                );
              }
            });
          }).bind(this)
        );
      }
    }
    /**
     * Launch next waiting task request if available connections.
     */
    _requestsHandler() {
      clearTimeout(__privateGet(this, _requestTimeoutId));
      __privateSet(this, _requestTimeoutId, null);
      const request = __privateGet(this, _requests).shift();
      if (request) {
        const conn = __privateGet(this, _idleConnections).shift();
        if (conn) {
          if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);
          this.emit("acquire", conn);
          __privateGet(this, _activeConnections)[conn.threadId] = conn;
          request.resolver(conn);
        } else {
          __privateGet(this, _requests).unshift(request);
        }
        this._requestTimeoutHandler();
      }
    }
    _hasIdleConnection() {
      return !__privateGet(this, _idleConnections).isEmpty();
    }
    /**
     * Return an idle Connection.
     * If connection has not been used for some time ( minDelayValidation), validate connection status.
     *
     * @returns {Promise<Connection>} connection of null of no valid idle connection.
     */
    async _doAcquire() {
      if (!this._hasIdleConnection() || __privateGet(this, _closed)) return Promise.reject();
      let conn;
      let mustRecheckSize = false;
      while ((conn = __privateGet(this, _idleConnections).shift()) != null) {
        if (conn.isValid()) {
          __privateGet(this, _activeConnections)[conn.threadId] = conn;
          if (this.opts.minDelayValidation <= 0 || Date.now() - conn.lastUse > this.opts.minDelayValidation) {
            try {
              const cmdParam = {
                opts: { timeout: this.opts.pingTimeout }
              };
              await new Promise(conn.ping.bind(conn, cmdParam));
            } catch (e) {
              delete __privateGet(this, _activeConnections)[conn.threadId];
              continue;
            }
          }
          if (this.opts.leakDetectionTimeout > 0) this._checkLeak(conn);
          if (mustRecheckSize) setImmediate(this.emit.bind(this, "validateSize"));
          return Promise.resolve(conn);
        }
        mustRecheckSize = true;
      }
      setImmediate(this.emit.bind(this, "validateSize"));
      return Promise.reject();
    }
    _requestTimeoutHandler() {
      __privateSet(this, _requestTimeoutId, null);
      const currTime = Date.now();
      let request;
      while (request = __privateGet(this, _requests).peekFront()) {
        if (request.timeout <= currTime) {
          __privateGet(this, _requests).shift();
          let cause = this.activeConnections() === 0 ? __privateGet(this, _errorCreatingConnection) : null;
          let err = Errors.createError(
            `retrieve connection from pool timeout after ${Math.abs(
              Date.now() - (request.timeout - this.opts.acquireTimeout)
            )}ms${this._errorMsgAddon()}`,
            Errors.ER_GET_CONNECTION_TIMEOUT,
            null,
            "HY000",
            null,
            false,
            request.stack,
            null,
            cause
          );
          request.reject(err);
        } else {
          __privateSet(this, _requestTimeoutId, setTimeout(this._requestTimeoutHandler.bind(this), request.timeout - currTime));
          return;
        }
      }
    }
    /**
     * Search info object of an existing connection. to know server type and version.
     * @returns information object if connection available.
     */
    _searchInfo() {
      let info = null;
      let conn = __privateGet(this, _idleConnections).get(0);
      if (!conn) {
        for (const threadId in Object.keys(__privateGet(this, _activeConnections))) {
          conn = __privateGet(this, _activeConnections)[threadId];
          if (!conn) {
            break;
          }
        }
      }
      if (conn) {
        info = conn.info;
      }
      return info;
    }
    async _createConnection(timeoutEnd) {
      const minTimeout = Math.max(1, timeoutEnd - 100);
      const connectionOpts = !this.opts.connOptions.connectTimeout || this.opts.connOptions.connectTimeout > minTimeout ? Object.assign({}, this.opts.connOptions, { connectTimeout: minTimeout }) : this.opts.connOptions;
      const conn = new Connection(connectionOpts);
      await conn.connect();
      const pool2 = this;
      conn.forceEnd = conn.end;
      conn.release = function(resolve) {
        if (__privateGet(pool2, _closed) || !conn.isValid()) {
          pool2._destroy(conn);
          resolve();
          return;
        }
        if (pool2.opts.noControlAfterUse) {
          pool2.release(conn);
          resolve();
          return;
        }
        let revertFunction;
        if (pool2.opts.resetAfterUse && conn.info.isMariaDB() && (conn.info.serverVersion.minor === 2 && conn.info.hasMinVersion(10, 2, 22) || conn.info.hasMinVersion(10, 3, 13))) {
          revertFunction = conn.reset.bind(conn, {});
        } else revertFunction = conn.changeTransaction.bind(conn, { sql: "ROLLBACK" });
        new Promise(revertFunction).then(pool2.release.bind(pool2, conn), pool2._destroy.bind(pool2, conn)).finally(resolve);
      };
      conn.end = conn.release;
      return conn;
    }
    _leakedConnections() {
      let counter = 0;
      for (const connection2 of Object.values(__privateGet(this, _activeConnections))) {
        if (connection2 && connection2.leaked) counter++;
      }
      return counter;
    }
    _errorMsgAddon() {
      if (this.opts.leakDetectionTimeout > 0) {
        return `
    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} leak=${this._leakedConnections()} limit=${this.opts.connectionLimit})`;
      }
      return `
    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} limit=${this.opts.connectionLimit})`;
    }
    toString() {
      return `active=${this.activeConnections()} idle=${this.idleConnections()} limit=${this.opts.connectionLimit}`;
    }
    //*****************************************************************
    // public methods
    //*****************************************************************
    get closed() {
      return __privateGet(this, _closed);
    }
    /**
     * Get current total connection number.
     * @return {number}
     */
    totalConnections() {
      return this.activeConnections() + this.idleConnections();
    }
    /**
     * Get current active connections.
     * @return {number}
     */
    activeConnections() {
      let counter = 0;
      for (const connection2 of Object.values(__privateGet(this, _activeConnections))) {
        if (connection2) counter++;
      }
      return counter;
    }
    /**
     * Get current idle connection number.
     * @return {number}
     */
    idleConnections() {
      return __privateGet(this, _idleConnections).length;
    }
    /**
     * Get current stacked connection request.
     * @return {number}
     */
    taskQueueSize() {
      return __privateGet(this, _requests).length;
    }
    escape(value) {
      return Utils.escape(this.opts.connOptions, this._searchInfo(), value);
    }
    escapeId(value) {
      return Utils.escapeId(this.opts.connOptions, this._searchInfo(), value);
    }
    //*****************************************************************
    // promise methods
    //*****************************************************************
    /**
     * Retrieve a connection from pool.
     * Create a new one, if limit is not reached.
     * wait until acquireTimeout.
     * @param cmdParam for stackTrace error
     * @return {Promise}
     */
    getConnection(cmdParam) {
      if (__privateGet(this, _closed)) {
        return Promise.reject(
          Errors.createError(
            "pool is closed",
            Errors.ER_POOL_ALREADY_CLOSED,
            null,
            "HY000",
            cmdParam === null ? null : cmdParam.sql,
            false,
            cmdParam.stack
          )
        );
      }
      return this._doAcquire().then(
        (conn) => {
          this.emit("acquire", conn);
          return conn;
        },
        () => {
          if (__privateGet(this, _closed)) {
            throw Errors.createError(
              "Cannot add request to pool, pool is closed",
              Errors.ER_POOL_ALREADY_CLOSED,
              null,
              "HY000",
              cmdParam === null ? null : cmdParam.sql,
              false,
              cmdParam.stack
            );
          }
          setImmediate(this.emit.bind(this, "validateSize"));
          return new Promise(
            (function(resolver, rejecter) {
              setImmediate(this.emit.bind(this, "enqueue"));
              const request = new Request(Date.now() + this.opts.acquireTimeout, cmdParam.stack, resolver, rejecter);
              __privateGet(this, _requests).push(request);
              if (!__privateGet(this, _requestTimeoutId)) {
                __privateSet(this, _requestTimeoutId, setTimeout(this._requestTimeoutHandler.bind(this), this.opts.acquireTimeout));
              }
            }).bind(this)
          );
        }
      );
    }
    /**
     * Close all connection in pool
     * Ends in multiple step :
     * - close idle connections
     * - ensure that no new request is possible
     *   (active connection release are automatically closed on release)
     * - if remaining, after 10 seconds, close remaining active connections
     *
     * @return Promise
     */
    end() {
      if (__privateGet(this, _closed)) {
        return Promise.reject(Errors.createError("pool is already closed", Errors.ER_POOL_ALREADY_CLOSED));
      }
      __privateSet(this, _closed, true);
      clearInterval(__privateGet(this, _unusedConnectionRemoverId));
      clearInterval(this._sizeHandlerTimeout);
      const cmdParam = {};
      if (this.opts.trace) Error.captureStackTrace(cmdParam);
      const idleConnectionsEndings = [];
      let conn;
      while (conn = __privateGet(this, _idleConnections).shift()) {
        idleConnectionsEndings.push(new Promise(conn.forceEnd.bind(conn, cmdParam)));
      }
      clearTimeout(__privateGet(this, _requestTimeoutId));
      __privateSet(this, _requestTimeoutId, null);
      if (!__privateGet(this, _requests).isEmpty()) {
        const err = Errors.createError(
          "pool is ending, connection request aborted",
          Errors.ER_CLOSING_POOL,
          null,
          "HY000",
          null,
          false,
          cmdParam.stack
        );
        let task;
        while (task = __privateGet(this, _requests).shift()) {
          task.reject(err);
        }
      }
      const pool2 = this;
      return Promise.all(idleConnectionsEndings).then(async () => {
        if (pool2.activeConnections() > 0) {
          let remaining = 100;
          while (remaining-- > 0) {
            if (pool2.activeConnections() > 0) {
              await new Promise((res) => setTimeout(() => res(), 100));
            }
          }
          for (const connection2 of Object.values(__privateGet(pool2, _activeConnections))) {
            if (connection2) connection2.destroy();
          }
        }
        return Promise.resolve();
      });
    }
  }
  _closed = new WeakMap();
  _connectionInCreation = new WeakMap();
  _errorCreatingConnection = new WeakMap();
  _idleConnections = new WeakMap();
  _activeConnections = new WeakMap();
  _requests = new WeakMap();
  _unusedConnectionRemoverId = new WeakMap();
  _requestTimeoutId = new WeakMap();
  _connErrorNumber = new WeakMap();
  _initialized = new WeakMap();
  class Request {
    constructor(timeout, stack, resolver, rejecter) {
      this.timeout = timeout;
      this.stack = stack;
      this.resolver = resolver;
      this.rejecter = rejecter;
    }
    reject(err) {
      process.nextTick(this.rejecter, err);
    }
  }
  pool$1 = Pool;
  return pool$1;
}
var poolPromise;
var hasRequiredPoolPromise;
function requirePoolPromise() {
  var _pool;
  if (hasRequiredPoolPromise) return poolPromise;
  hasRequiredPoolPromise = 1;
  const { EventEmitter } = require$$0$3;
  const Pool = requirePool();
  const ConnectionPromise = requireConnectionPromise();
  const Errors = requireErrors();
  class PoolPromise extends EventEmitter {
    constructor(options) {
      super();
      __privateAdd(this, _pool);
      __privateSet(this, _pool, new Pool(options));
      __privateGet(this, _pool).on("acquire", this.emit.bind(this, "acquire"));
      __privateGet(this, _pool).on("connection", this.emit.bind(this, "connection"));
      __privateGet(this, _pool).on("enqueue", this.emit.bind(this, "enqueue"));
      __privateGet(this, _pool).on("release", this.emit.bind(this, "release"));
      __privateGet(this, _pool).on("error", this.emit.bind(this, "error"));
    }
    get closed() {
      return __privateGet(this, _pool).closed;
    }
    /**
     * Get current total connection number.
     * @return {number}
     */
    totalConnections() {
      return __privateGet(this, _pool).totalConnections();
    }
    /**
     * Get current active connections.
     * @return {number}
     */
    activeConnections() {
      return __privateGet(this, _pool).activeConnections();
    }
    /**
     * Get current idle connection number.
     * @return {number}
     */
    idleConnections() {
      return __privateGet(this, _pool).idleConnections();
    }
    /**
     * Get current stacked connection request.
     * @return {number}
     */
    taskQueueSize() {
      return __privateGet(this, _pool).taskQueueSize();
    }
    escape(value) {
      return __privateGet(this, _pool).escape(value);
    }
    escapeId(value) {
      return __privateGet(this, _pool).escapeId(value);
    }
    /**
     * Ends pool
     *
     * @return Promise
     **/
    end() {
      return __privateGet(this, _pool).end();
    }
    /**
     * Retrieve a connection from pool.
     * Create a new one, if limit is not reached.
     * wait until acquireTimeout.
     *
     */
    async getConnection() {
      const cmdParam = {};
      if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
      const baseConn = await __privateGet(this, _pool).getConnection(cmdParam);
      const conn = new ConnectionPromise(baseConn);
      conn.release = () => new Promise(baseConn.release);
      conn.end = conn.release;
      conn.close = conn.release;
      return conn;
    }
    /**
     * Execute query using text protocol with callback emit columns/data/end/error
     * events to permit streaming big result-set
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  object / array of placeholder values (not mandatory)
     */
    query(sql, values) {
      const cmdParam = ConnectionPromise.paramSetter(sql, values);
      if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
      return __privateGet(this, _pool).getConnection(cmdParam).then((baseConn) => {
        return new Promise(baseConn.query.bind(baseConn, cmdParam)).finally(() => {
          __privateGet(this, _pool).release(baseConn);
        });
      });
    }
    /**
     * Execute query using binary protocol with callback emit columns/data/end/error
     * events to permit streaming big result-set
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  object / array of placeholder values (not mandatory)
     */
    execute(sql, values) {
      const cmdParam = ConnectionPromise.paramSetter(sql, values);
      if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
      return __privateGet(this, _pool).getConnection(cmdParam).then((baseConn) => {
        return ConnectionPromise._EXECUTE_CMD(baseConn, cmdParam).finally(() => {
          __privateGet(this, _pool).release(baseConn);
        });
      });
    }
    /**
     * execute a batch
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  array of placeholder values
     */
    batch(sql, values) {
      const cmdParam = ConnectionPromise.paramSetter(sql, values);
      if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
      return __privateGet(this, _pool).getConnection(cmdParam).then((baseConn) => {
        return ConnectionPromise._BATCH_CMD(baseConn, cmdParam).finally(() => {
          __privateGet(this, _pool).release(baseConn);
        });
      });
    }
    /**
     * Import sql file.
     *
     * @param opts JSON array with 2 possible fields: file and database
     */
    importFile(opts) {
      if (!opts) {
        return Promise.reject(
          Errors.createError(
            "SQL file parameter is mandatory",
            Errors.ER_MISSING_SQL_PARAMETER,
            null,
            "HY000",
            null,
            false,
            null
          )
        );
      }
      return __privateGet(this, _pool).getConnection({}).then((baseConn) => {
        return new Promise(baseConn.importFile.bind(baseConn, { file: opts.file, database: opts.database })).finally(
          () => {
            __privateGet(this, _pool).release(baseConn);
          }
        );
      });
    }
    toString() {
      return "poolPromise(" + __privateGet(this, _pool).toString() + ")";
    }
  }
  _pool = new WeakMap();
  poolPromise = PoolPromise;
  return poolPromise;
}
var clusterOptions;
var hasRequiredClusterOptions;
function requireClusterOptions() {
  if (hasRequiredClusterOptions) return clusterOptions;
  hasRequiredClusterOptions = 1;
  class ClusterOptions {
    constructor(opts) {
      if (opts) {
        this.canRetry = opts.canRetry === void 0 ? true : opts.canRetry;
        this.removeNodeErrorCount = opts.removeNodeErrorCount || Infinity;
        this.restoreNodeTimeout = opts.restoreNodeTimeout || 1e3;
        this.defaultSelector = opts.defaultSelector || "RR";
      } else {
        this.canRetry = true;
        this.removeNodeErrorCount = Infinity;
        this.restoreNodeTimeout = 1e3;
        this.defaultSelector = "RR";
      }
    }
  }
  clusterOptions = ClusterOptions;
  return clusterOptions;
}
var poolOptions;
var hasRequiredPoolOptions;
function requirePoolOptions() {
  if (hasRequiredPoolOptions) return poolOptions;
  hasRequiredPoolOptions = 1;
  let ConnOptions = requireConnectionOptions();
  class PoolOptions {
    constructor(opts) {
      if (typeof opts === "string") {
        opts = ConnOptions.parse(opts);
        if (opts.acquireTimeout) opts.acquireTimeout = parseInt(opts.acquireTimeout);
        if (opts.connectionLimit) opts.connectionLimit = parseInt(opts.connectionLimit);
        if (opts.idleTimeout) opts.idleTimeout = parseInt(opts.idleTimeout);
        if (opts.leakDetectionTimeout) opts.leakDetectionTimeout = parseInt(opts.leakDetectionTimeout);
        if (opts.initializationTimeout) opts.initializationTimeout = parseInt(opts.initializationTimeout);
        if (opts.minDelayValidation) opts.minDelayValidation = parseInt(opts.minDelayValidation);
        if (opts.minimumIdle) opts.minimumIdle = parseInt(opts.minimumIdle);
        if (opts.noControlAfterUse) opts.noControlAfterUse = opts.noControlAfterUse === "true";
        if (opts.resetAfterUse) opts.resetAfterUse = opts.resetAfterUse === "true";
        if (opts.pingTimeout) opts.pingTimeout = parseInt(opts.pingTimeout);
      }
      this.acquireTimeout = opts.acquireTimeout === void 0 ? 1e4 : opts.acquireTimeout;
      this.connectionLimit = opts.connectionLimit === void 0 ? 10 : opts.connectionLimit;
      this.idleTimeout = opts.idleTimeout === void 0 ? 1800 : opts.idleTimeout;
      this.leakDetectionTimeout = opts.leakDetectionTimeout || 0;
      this.initializationTimeout = opts.initializationTimeout === void 0 ? Math.max(100, this.acquireTimeout - 100) : opts.initializationTimeout;
      this.minDelayValidation = opts.minDelayValidation === void 0 ? 500 : opts.minDelayValidation;
      this.minimumIdle = opts.minimumIdle === void 0 ? this.connectionLimit : Math.min(opts.minimumIdle, this.connectionLimit);
      this.noControlAfterUse = opts.noControlAfterUse || false;
      this.resetAfterUse = opts.resetAfterUse || false;
      this.pingTimeout = opts.pingTimeout || 250;
      this.connOptions = new ConnOptions(opts);
      if (this.acquireTimeout > 0 && this.connOptions.connectTimeout > this.acquireTimeout) {
        this.connOptions.connectTimeout = this.acquireTimeout;
      }
    }
  }
  poolOptions = PoolOptions;
  return poolOptions;
}
var connectionCallback;
var hasRequiredConnectionCallback;
function requireConnectionCallback() {
  var _conn, _noop;
  if (hasRequiredConnectionCallback) return connectionCallback;
  hasRequiredConnectionCallback = 1;
  const Errors = requireErrors();
  const { Status } = requireConnection_status();
  const Query = requireQuery();
  const _ConnectionCallback = class _ConnectionCallback {
    constructor(conn) {
      __privateAdd(this, _conn);
      __privateAdd(this, _noop, () => {
      });
      __publicField(this, "release", (cb) => {
        __privateGet(this, _conn).release(() => {
          if (cb) cb();
        });
      });
      __privateSet(this, _conn, conn);
    }
    get threadId() {
      return __privateGet(this, _conn).info ? __privateGet(this, _conn).info.threadId : null;
    }
    get info() {
      return __privateGet(this, _conn).info;
    }
    /**
     * Permit to change user during connection.
     * All user variables will be reset, Prepare commands will be released.
     * !!! mysql has a bug when CONNECT_ATTRS capability is set, that is default !!!!
     *
     * @param options   connection options
     * @param callback  callback function
     */
    changeUser(options, callback) {
      let _options, _cb;
      if (typeof options === "function") {
        _cb = options;
        _options = void 0;
      } else {
        _options = options;
        _cb = callback;
      }
      const cmdParam = {
        opts: _options,
        callback: _cb
      };
      if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
      new Promise(__privateGet(this, _conn).changeUser.bind(__privateGet(this, _conn), cmdParam)).then(() => {
        if (cmdParam.callback) cmdParam.callback(null, null, null);
      }).catch(cmdParam.callback || __privateGet(this, _noop));
    }
    /**
     * Start transaction
     *
     * @param callback  callback function
     */
    beginTransaction(callback) {
      this.query("START TRANSACTION", null, callback);
    }
    /**
     * Commit a transaction.
     *
     * @param callback  callback function
     */
    commit(callback) {
      __privateGet(this, _conn).changeTransaction(
        { sql: "COMMIT" },
        () => {
          if (callback) callback(null, null, null);
        },
        callback || __privateGet(this, _noop)
      );
    }
    /**
     * Roll back a transaction.
     *
     * @param callback  callback function
     */
    rollback(callback) {
      __privateGet(this, _conn).changeTransaction(
        { sql: "ROLLBACK" },
        () => {
          if (callback) callback(null, null, null);
        },
        callback || __privateGet(this, _noop)
      );
    }
    /**
     * Execute query using text protocol with callback emit columns/data/end/error
     * events to permit streaming big result-set
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  object / array of placeholder values (not mandatory)
     * @param callback  callback function
     */
    query(sql, values, callback) {
      const cmdParam = _ConnectionCallback._PARAM(__privateGet(this, _conn).opts, sql, values, callback);
      return _ConnectionCallback._QUERY_CMD(__privateGet(this, _conn), cmdParam);
    }
    static _QUERY_CMD(conn, cmdParam) {
      let cmd;
      if (cmdParam.callback) {
        cmdParam.opts = cmdParam.opts ? Object.assign(cmdParam.opts, { metaAsArray: true }) : { metaAsArray: true };
        cmd = new Query(
          ([rows, meta]) => {
            cmdParam.callback(null, rows, meta);
          },
          cmdParam.callback,
          conn.opts,
          cmdParam
        );
      } else {
        cmd = new Query(
          () => {
          },
          () => {
          },
          conn.opts,
          cmdParam
        );
      }
      cmd.handleNewRows = (row) => {
        cmd._rows[cmd._responseIndex].push(row);
        cmd.emit("data", row);
      };
      conn.addCommand(cmd, true);
      cmd.stream = (opt) => cmd._stream(conn.socket, opt);
      return cmd;
    }
    execute(sql, values, callback) {
      const cmdParam = _ConnectionCallback._PARAM(__privateGet(this, _conn).opts, sql, values, callback);
      cmdParam.opts = cmdParam.opts ? Object.assign(cmdParam.opts, { metaAsArray: true }) : { metaAsArray: true };
      __privateGet(this, _conn).prepareExecute(cmdParam).then(([rows, meta]) => {
        if (cmdParam.callback) {
          cmdParam.callback(null, rows, meta);
        }
      }).catch((err) => {
        if (cmdParam.callback) {
          cmdParam.callback(err);
        }
      });
    }
    static _PARAM(options, sql, values, callback) {
      let _cmdOpt, _sql, _values = values, _cb = callback;
      if (typeof values === "function") {
        _cb = values;
        _values = void 0;
      }
      if (typeof sql === "object") {
        _cmdOpt = sql;
        _sql = _cmdOpt.sql;
        if (_cmdOpt.values) _values = _cmdOpt.values;
      } else {
        _sql = sql;
      }
      const cmdParam = {
        sql: _sql,
        values: _values,
        opts: _cmdOpt,
        callback: _cb
      };
      if (options.trace) Error.captureStackTrace(cmdParam, _ConnectionCallback._PARAM);
      return cmdParam;
    }
    static _EXECUTE_CMD(conn, cmdParam) {
      new Promise(conn.prepare.bind(conn, cmdParam)).then((prepare2) => {
        const opts = cmdParam.opts ? Object.assign(cmdParam.opts, { metaAsArray: true }) : { metaAsArray: true };
        return prepare2.execute(cmdParam.values, opts, null, cmdParam.stack).then(([rows, meta]) => {
          if (cmdParam.callback) {
            cmdParam.callback(null, rows, meta);
          }
        }).finally(() => prepare2.close());
      }).catch((err) => {
        if (conn.opts.logger.error) conn.opts.logger.error(err);
        if (cmdParam.callback) cmdParam.callback(err);
      });
    }
    prepare(sql, callback) {
      let _cmdOpt, _sql;
      if (typeof sql === "object") {
        _cmdOpt = sql;
        _sql = _cmdOpt.sql;
      } else {
        _sql = sql;
      }
      const cmdParam = {
        sql: _sql,
        opts: _cmdOpt,
        callback
      };
      if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
      return new Promise(__privateGet(this, _conn).prepare.bind(__privateGet(this, _conn), cmdParam)).then((prepare2) => {
        if (callback) callback(null, prepare2, null);
      }).catch(callback || __privateGet(this, _noop));
    }
    /**
     * Execute a batch
     * events to permit streaming big result-set
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  object / array of placeholder values (not mandatory)
     * @param callback callback
     */
    batch(sql, values, callback) {
      const cmdParam = _ConnectionCallback._PARAM(__privateGet(this, _conn).opts, sql, values, callback);
      return _ConnectionCallback._BATCH_CMD(__privateGet(this, _conn), cmdParam);
    }
    static _BATCH_CMD(conn, cmdParam) {
      conn.batch(cmdParam).then((res) => {
        if (cmdParam.callback) cmdParam.callback(null, res);
      }).catch((err) => {
        if (cmdParam.callback) cmdParam.callback(err);
      });
    }
    /**
     * Import sql file.
     *
     * @param opts JSON array with 2 possible fields: file and database
     * @param cb callback
     */
    importFile(opts, cb) {
      if (!opts || !opts.file) {
        if (cb)
          cb(
            Errors.createError(
              "SQL file parameter is mandatory",
              Errors.ER_MISSING_SQL_PARAMETER,
              __privateGet(this, _conn).info,
              "HY000",
              null,
              false,
              null
            )
          );
        return;
      }
      new Promise(__privateGet(this, _conn).importFile.bind(__privateGet(this, _conn), { file: opts.file, database: opts.database })).then(() => {
        if (cb) cb();
      }).catch((err) => {
        if (cb) cb(err);
      });
    }
    /**
     * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout
     * @param timeout (optional) timeout value in ms. If reached, throw error and close connection
     * @param callback callback
     */
    ping(timeout, callback) {
      let _cmdOpt = {}, _cb;
      if (typeof timeout === "function") {
        _cb = timeout;
      } else {
        _cmdOpt.timeout = timeout;
        _cb = callback;
      }
      const cmdParam = {
        opts: _cmdOpt,
        callback: _cb
      };
      if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
      new Promise(__privateGet(this, _conn).ping.bind(__privateGet(this, _conn), cmdParam)).then(_cb || __privateGet(this, _noop)).catch(_cb || __privateGet(this, _noop));
    }
    /**
     * Send a reset command that will
     * - rollback any open transaction
     * - reset transaction isolation level
     * - reset session variables
     * - delete user variables
     * - remove temporary tables
     * - remove all PREPARE statement
     *
     * @param callback callback
     */
    reset(callback) {
      const cmdParam = {};
      if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
      return new Promise(__privateGet(this, _conn).reset.bind(__privateGet(this, _conn), cmdParam)).then(callback || __privateGet(this, _noop)).catch(callback || __privateGet(this, _noop));
    }
    /**
     * Indicates the state of the connection as the driver knows it
     * @returns {boolean}
     */
    isValid() {
      return __privateGet(this, _conn).isValid();
    }
    /**
     * Terminate connection gracefully.
     *
     * @param callback callback
     */
    end(callback) {
      const cmdParam = {};
      if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
      new Promise(__privateGet(this, _conn).end.bind(__privateGet(this, _conn), cmdParam)).then(() => {
        if (callback) callback();
      }).catch(callback || __privateGet(this, _noop));
    }
    /**
     * Alias for destroy.
     */
    close() {
      this.destroy();
    }
    /**
     * Force connection termination by closing the underlying socket and killing server process if any.
     */
    destroy() {
      __privateGet(this, _conn).destroy();
    }
    pause() {
      __privateGet(this, _conn).pause();
    }
    resume() {
      __privateGet(this, _conn).resume();
    }
    format(sql, values) {
      __privateGet(this, _conn).format(sql, values);
    }
    /**
     * return current connected server version information.
     *
     * @returns {*}
     */
    serverVersion() {
      return __privateGet(this, _conn).serverVersion();
    }
    /**
     * Change option "debug" during connection.
     * @param val   debug value
     */
    debug(val) {
      return __privateGet(this, _conn).debug(val);
    }
    debugCompress(val) {
      return __privateGet(this, _conn).debugCompress(val);
    }
    escape(val) {
      return __privateGet(this, _conn).escape(val);
    }
    escapeId(val) {
      return __privateGet(this, _conn).escapeId(val);
    }
    //*****************************************************************
    // internal public testing methods
    //*****************************************************************
    get __tests() {
      return __privateGet(this, _conn).__tests;
    }
    connect(callback) {
      if (!callback) {
        throw new Errors.createError(
          "missing mandatory callback parameter",
          Errors.ER_MISSING_PARAMETER,
          __privateGet(this, _conn).info
        );
      }
      switch (__privateGet(this, _conn).status) {
        case Status.NOT_CONNECTED:
        case Status.CONNECTING:
        case Status.AUTHENTICATING:
        case Status.INIT_CMD:
          this.once("connect", callback);
          break;
        case Status.CONNECTED:
          callback.call(this);
          break;
        case Status.CLOSING:
        case Status.CLOSED:
          callback.call(
            this,
            Errors.createError(
              "Connection closed",
              Errors.ER_CONNECTION_ALREADY_CLOSED,
              __privateGet(this, _conn).info,
              "08S01",
              null,
              true
            )
          );
          break;
      }
    }
    //*****************************************************************
    // EventEmitter proxy methods
    //*****************************************************************
    on(eventName, listener) {
      __privateGet(this, _conn).on.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    off(eventName, listener) {
      __privateGet(this, _conn).off.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    once(eventName, listener) {
      __privateGet(this, _conn).once.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    listeners(eventName) {
      return __privateGet(this, _conn).listeners.call(__privateGet(this, _conn), eventName);
    }
    addListener(eventName, listener) {
      __privateGet(this, _conn).addListener.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    eventNames() {
      return __privateGet(this, _conn).eventNames.call(__privateGet(this, _conn));
    }
    getMaxListeners() {
      return __privateGet(this, _conn).getMaxListeners.call(__privateGet(this, _conn));
    }
    listenerCount(eventName, listener) {
      return __privateGet(this, _conn).listenerCount.call(__privateGet(this, _conn), eventName, listener);
    }
    prependListener(eventName, listener) {
      __privateGet(this, _conn).prependListener.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    prependOnceListener(eventName, listener) {
      __privateGet(this, _conn).prependOnceListener.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    removeAllListeners(eventName, listener) {
      __privateGet(this, _conn).removeAllListeners.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    removeListener(eventName, listener) {
      __privateGet(this, _conn).removeListener.call(__privateGet(this, _conn), eventName, listener);
      return this;
    }
    setMaxListeners(n) {
      __privateGet(this, _conn).setMaxListeners.call(__privateGet(this, _conn), n);
      return this;
    }
    rawListeners(eventName) {
      return __privateGet(this, _conn).rawListeners.call(__privateGet(this, _conn), eventName);
    }
  };
  _conn = new WeakMap();
  _noop = new WeakMap();
  let ConnectionCallback = _ConnectionCallback;
  connectionCallback = ConnectionCallback;
  return connectionCallback;
}
var poolCallback;
var hasRequiredPoolCallback;
function requirePoolCallback() {
  var _pool, _noop;
  if (hasRequiredPoolCallback) return poolCallback;
  hasRequiredPoolCallback = 1;
  const { EventEmitter } = require$$0$3;
  const Pool = requirePool();
  const Errors = requireErrors();
  const ConnectionCallback = requireConnectionCallback();
  class PoolCallback extends EventEmitter {
    constructor(options) {
      super();
      __privateAdd(this, _pool);
      __privateAdd(this, _noop, () => {
      });
      __privateSet(this, _pool, new Pool(options));
      __privateGet(this, _pool).on("acquire", this.emit.bind(this, "acquire"));
      __privateGet(this, _pool).on("connection", this.emit.bind(this, "connection"));
      __privateGet(this, _pool).on("enqueue", this.emit.bind(this, "enqueue"));
      __privateGet(this, _pool).on("release", this.emit.bind(this, "release"));
      __privateGet(this, _pool).on("error", this.emit.bind(this, "error"));
    }
    get closed() {
      return __privateGet(this, _pool).closed;
    }
    /**
     * Get current total connection number.
     * @return {number}
     */
    totalConnections() {
      return __privateGet(this, _pool).totalConnections();
    }
    /**
     * Get current active connections.
     * @return {number}
     */
    activeConnections() {
      return __privateGet(this, _pool).activeConnections();
    }
    /**
     * Get current idle connection number.
     * @return {number}
     */
    idleConnections() {
      return __privateGet(this, _pool).idleConnections();
    }
    /**
     * Get current stacked connection request.
     * @return {number}
     */
    taskQueueSize() {
      return __privateGet(this, _pool).taskQueueSize();
    }
    escape(value) {
      return __privateGet(this, _pool).escape(value);
    }
    escapeId(value) {
      return __privateGet(this, _pool).escapeId(value);
    }
    /**
     * Ends pool
     *
     * @param callback
     */
    end(callback) {
      __privateGet(this, _pool).end().then(() => {
        if (callback) callback(null);
      }).catch(callback || __privateGet(this, _noop));
    }
    /**
     * Retrieve a connection from pool.
     * Create a new one, if limit is not reached.
     * wait until acquireTimeout.
     *
     * @param cb callback
     */
    getConnection(cb) {
      if (!cb) {
        throw new Errors.createError("missing mandatory callback parameter", Errors.ER_MISSING_PARAMETER);
      }
      const cmdParam = {};
      if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
      __privateGet(this, _pool).getConnection(cmdParam).then((baseConn) => {
        const cc = new ConnectionCallback(baseConn);
        cc.end = (cb2) => cc.release(cb2);
        cc.close = (cb2) => cc.release(cb2);
        cb(null, cc);
      }).catch(cb);
    }
    /**
     * Execute query using text protocol with callback emit columns/data/end/error
     * events to permit streaming big result-set
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  object / array of placeholder values (not mandatory)
     * @param cb      callback
     */
    query(sql, values, cb) {
      const cmdParam = ConnectionCallback._PARAM(__privateGet(this, _pool).opts.connOptions, sql, values, cb);
      __privateGet(this, _pool).getConnection(cmdParam).then((baseConn) => {
        const _cb = cmdParam.callback;
        cmdParam.callback = (err, rows, meta) => {
          __privateGet(this, _pool).release(baseConn);
          if (_cb) _cb(err, rows, meta);
        };
        ConnectionCallback._QUERY_CMD(baseConn, cmdParam);
      }).catch((err) => {
        if (cmdParam.callback) cmdParam.callback(err);
      });
    }
    /**
     * Execute query using binary protocol with callback emit columns/data/end/error
     * events to permit streaming big result-set
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  object / array of placeholder values (not mandatory)
     * @param cb      callback
     */
    execute(sql, values, cb) {
      const cmdParam = ConnectionCallback._PARAM(__privateGet(this, _pool).opts.connOptions, sql, values, cb);
      __privateGet(this, _pool).getConnection(cmdParam).then((baseConn) => {
        const _cb = cmdParam.callback;
        cmdParam.callback = (err, rows, meta) => {
          __privateGet(this, _pool).release(baseConn);
          if (_cb) _cb(err, rows, meta);
        };
        ConnectionCallback._EXECUTE_CMD(baseConn, cmdParam);
      }).catch((err) => {
        if (cmdParam.callback) cmdParam.callback(err);
      });
    }
    /**
     * execute a batch
     *
     * @param sql     sql parameter Object can be used to supersede default option.
     *                Object must then have sql property.
     * @param values  array of placeholder values
     * @param cb      callback
     */
    batch(sql, values, cb) {
      const cmdParam = ConnectionCallback._PARAM(__privateGet(this, _pool).opts.connOptions, sql, values, cb);
      __privateGet(this, _pool).getConnection(cmdParam).then((baseConn) => {
        const _cb = cmdParam.callback;
        cmdParam.callback = (err, rows, meta) => {
          __privateGet(this, _pool).release(baseConn);
          if (_cb) _cb(err, rows, meta);
        };
        ConnectionCallback._BATCH_CMD(baseConn, cmdParam);
      }).catch((err) => {
        if (cmdParam.callback) cmdParam.callback(err);
      });
    }
    /**
     * Import sql file.
     *
     * @param opts JSON array with 2 possible fields: file and database
     * @param cb callback
     */
    importFile(opts, cb) {
      if (!opts) {
        if (cb)
          cb(
            Errors.createError(
              "SQL file parameter is mandatory",
              Errors.ER_MISSING_SQL_PARAMETER,
              null,
              "HY000",
              null,
              false,
              null
            )
          );
        return;
      }
      __privateGet(this, _pool).getConnection({}).then((baseConn) => {
        return new Promise(baseConn.importFile.bind(baseConn, { file: opts.file, database: opts.database })).finally(
          () => {
            __privateGet(this, _pool).release(baseConn);
          }
        );
      }).then(() => {
        if (cb) cb();
      }).catch((err) => {
        if (cb) cb(err);
      });
    }
    toString() {
      return "poolCallback(" + __privateGet(this, _pool).toString() + ")";
    }
  }
  _pool = new WeakMap();
  _noop = new WeakMap();
  poolCallback = PoolCallback;
  return poolCallback;
}
var filteredCluster;
var hasRequiredFilteredCluster;
function requireFilteredCluster() {
  var _cluster, _pattern, _selector;
  if (hasRequiredFilteredCluster) return filteredCluster;
  hasRequiredFilteredCluster = 1;
  class FilteredCluster {
    constructor(poolCluster, patternArg, selectorArg) {
      __privateAdd(this, _cluster);
      __privateAdd(this, _pattern);
      __privateAdd(this, _selector);
      __privateSet(this, _cluster, poolCluster);
      __privateSet(this, _pattern, patternArg);
      __privateSet(this, _selector, selectorArg);
    }
    /**
     * Get a connection according to previously indicated pattern and selector.
     *
     * @return {Promise}
     */
    getConnection() {
      return __privateGet(this, _cluster).getConnection(__privateGet(this, _pattern), __privateGet(this, _selector));
    }
    /**
     * Execute a text query on one connection from available pools matching pattern
     * in cluster.
     *
     * @param sql   sql command
     * @param value parameter value of sql command (not mandatory)
     * @return {Promise}
     */
    query(sql, value) {
      return __privateGet(this, _cluster).getConnection(__privateGet(this, _pattern), __privateGet(this, _selector)).then((conn) => {
        return conn.query(sql, value).then((res) => {
          conn.release();
          return res;
        }).catch((err) => {
          conn.release();
          return Promise.reject(err);
        });
      }).catch((err) => {
        return Promise.reject(err);
      });
    }
    /**
     * Execute a binary query on one connection from available pools matching pattern
     * in cluster.
     *
     * @param sql   sql command
     * @param value parameter value of sql command (not mandatory)
     * @return {Promise}
     */
    execute(sql, value) {
      return __privateGet(this, _cluster).getConnection(__privateGet(this, _pattern), __privateGet(this, _selector)).then((conn) => {
        return conn.execute(sql, value).then((res) => {
          conn.release();
          return res;
        }).catch((err) => {
          conn.release();
          return Promise.reject(err);
        });
      }).catch((err) => {
        return Promise.reject(err);
      });
    }
    /**
     * Execute a batch on one connection from available pools matching pattern
     * in cluster.
     *
     * @param sql   sql command
     * @param value parameter value of sql command
     * @return {Promise}
     */
    batch(sql, value) {
      return __privateGet(this, _cluster).getConnection(__privateGet(this, _pattern), __privateGet(this, _selector)).then((conn) => {
        return conn.batch(sql, value).then((res) => {
          conn.release();
          return res;
        }).catch((err) => {
          conn.release();
          return Promise.reject(err);
        });
      }).catch((err) => {
        return Promise.reject(err);
      });
    }
  }
  _cluster = new WeakMap();
  _pattern = new WeakMap();
  _selector = new WeakMap();
  filteredCluster = FilteredCluster;
  return filteredCluster;
}
var cluster;
var hasRequiredCluster;
function requireCluster() {
  var _opts, _nodes, _cachedPatterns, _nodeCounter, _nodes2;
  if (hasRequiredCluster) return cluster;
  hasRequiredCluster = 1;
  const ClusterOptions = requireClusterOptions();
  const PoolOptions = requirePoolOptions();
  const PoolCallback = requirePoolCallback();
  const PoolPromise = requirePoolPromise();
  const FilteredCluster = requireFilteredCluster();
  const EventEmitter = require$$0$3;
  class Cluster extends EventEmitter {
    constructor(args) {
      super();
      __privateAdd(this, _opts);
      __privateAdd(this, _nodes, {});
      __privateAdd(this, _cachedPatterns, {});
      __privateAdd(this, _nodeCounter, 0);
      __privateSet(this, _opts, new ClusterOptions(args));
    }
    /**
     * Add a new pool node to cluster.
     *
     * @param id      identifier
     * @param config  pool configuration
     */
    add(id, config) {
      let identifier;
      if (typeof id === "string" || id instanceof String) {
        identifier = id;
        if (__privateGet(this, _nodes)[identifier]) throw new Error(`Node identifier '${identifier}' already exist !`);
      } else {
        identifier = "PoolNode-" + __privateWrapper(this, _nodeCounter)._++;
        config = id;
      }
      const options = new PoolOptions(config);
      __privateGet(this, _nodes)[identifier] = this._createPool(options);
    }
    /**
     * End cluster (and underlying pools).
     *
     * @return {Promise<any[]>}
     */
    end() {
      const cluster2 = this;
      __privateSet(this, _cachedPatterns, {});
      const poolEndPromise = [];
      Object.keys(__privateGet(this, _nodes)).forEach((pool2) => {
        const res = __privateGet(cluster2, _nodes)[pool2].end();
        if (res) poolEndPromise.push(res);
      });
      __privateSet(this, _nodes, null);
      return Promise.all(poolEndPromise);
    }
    of(pattern, selector) {
      return new FilteredCluster(this, pattern, selector);
    }
    /**
     * Remove nodes according to pattern.
     *
     * @param pattern  pattern
     */
    remove(pattern) {
      if (!pattern) throw new Error("pattern parameter in Cluster.remove(pattern)  is mandatory");
      const regex = RegExp(pattern);
      Object.keys(__privateGet(this, _nodes)).forEach(
        (function(key) {
          if (regex.test(key)) {
            __privateGet(this, _nodes)[key].end();
            delete __privateGet(this, _nodes)[key];
            __privateSet(this, _cachedPatterns, {});
          }
        }).bind(this)
      );
    }
    /**
     * Get connection from available pools matching pattern, according to selector
     *
     * @param pattern       pattern filter (not mandatory)
     * @param selector      node selector ('RR','RANDOM' or 'ORDER')
     * @return {Promise}
     */
    getConnection(pattern, selector) {
      return this._getConnection(pattern, selector, void 0, void 0, void 0);
    }
    /**
     * Force using callback methods.
     */
    _setCallback() {
      this.getConnection = this._getConnectionCallback;
      this._createPool = this._createPoolCallback;
    }
    /**
     * Get connection from available pools matching pattern, according to selector
     * with additional parameter to avoid reusing failing node
     *
     * @param pattern       pattern filter (not mandatory)
     * @param selector      node selector ('RR','RANDOM' or 'ORDER')
     * @param avoidNodeKey  failing node
     * @param lastError     last error
     * @param remainingRetry remaining possible retry
     * @return {Promise}
     * @private
     */
    _getConnection(pattern, selector, remainingRetry, avoidNodeKey, lastError) {
      const matchingNodeList = this._matchingNodes(pattern || /^/);
      if (matchingNodeList.length === 0) {
        if (Object.keys(__privateGet(this, _nodes)).length === 0 && !lastError) {
          return Promise.reject(
            new Error("No node have been added to cluster or nodes have been removed due to too much connection error")
          );
        }
        if (avoidNodeKey === void 0) return Promise.reject(new Error(`No node found for pattern '${pattern}'`));
        const errMsg = `No Connection available for '${pattern}'${lastError ? ". Last connection error was: " + lastError.message : ""}`;
        return Promise.reject(new Error(errMsg));
      }
      if (remainingRetry === void 0) remainingRetry = matchingNodeList.length;
      const retry2 = --remainingRetry >= 0 ? this._getConnection.bind(this, pattern, selector, remainingRetry) : null;
      try {
        const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);
        return this._handleConnectionError(matchingNodeList, nodeKey, retry2);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    _createPool(options) {
      const pool2 = new PoolPromise(options);
      pool2.on("error", (err) => {
      });
      return pool2;
    }
    _createPoolCallback(options) {
      const pool2 = new PoolCallback(options);
      pool2.on("error", (err) => {
      });
      return pool2;
    }
    /**
     * Get connection from available pools matching pattern, according to selector
     * with additional parameter to avoid reusing failing node
     *
     * @param pattern       pattern filter (not mandatory)
     * @param selector      node selector ('RR','RANDOM' or 'ORDER')
     * @param callback      callback function
     * @param avoidNodeKey  failing node
     * @param lastError     last error
     * @private
     */
    _getConnectionCallback(pattern, selector, callback, avoidNodeKey, lastError) {
      const matchingNodeList = this._matchingNodes(pattern || /^/);
      if (matchingNodeList.length === 0) {
        if (Object.keys(__privateGet(this, _nodes)).length === 0 && !lastError) {
          callback(
            new Error("No node have been added to cluster or nodes have been removed due to too much connection error")
          );
          return;
        }
        if (avoidNodeKey === void 0) callback(new Error(`No node found for pattern '${pattern}'`));
        const errMsg = `No Connection available for '${pattern}'${lastError ? ". Last connection error was: " + lastError.message : ""}`;
        callback(new Error(errMsg));
        return;
      }
      const retry2 = this._getConnectionCallback.bind(this, pattern, selector, callback);
      try {
        const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);
        this._handleConnectionCallbackError(matchingNodeList, nodeKey, retry2, callback);
      } catch (e) {
        callback(e);
      }
    }
    /**
     * Selecting nodes according to pattern.
     *
     * @param pattern pattern
     * @return {*}
     * @private
     */
    _matchingNodes(pattern) {
      if (__privateGet(this, _cachedPatterns)[pattern]) return __privateGet(this, _cachedPatterns)[pattern];
      const regex = RegExp(pattern);
      const matchingNodeList = [];
      Object.keys(__privateGet(this, _nodes)).forEach((key) => {
        if (regex.test(key)) {
          matchingNodeList.push(key);
        }
      });
      __privateGet(this, _cachedPatterns)[pattern] = matchingNodeList;
      return matchingNodeList;
    }
    /**
     * Select next node to be chosen in nodeList according to selector and failed nodes.
     *
     * @param nodeList        current node list
     * @param selectorParam   selector
     * @param avoidNodeKey    last failing node to avoid selecting this one.
     * @return {Promise}
     * @private
     */
    _selectPool(nodeList, selectorParam, avoidNodeKey) {
      const selector = selectorParam || __privateGet(this, _opts).defaultSelector;
      let selectorFct;
      switch (selector) {
        case "RR":
          selectorFct = roundRobinSelector;
          break;
        case "RANDOM":
          selectorFct = randomSelector;
          break;
        case "ORDER":
          selectorFct = orderedSelector;
          break;
        default:
          throw new Error(`Wrong selector value '${selector}'. Possible values are 'RR','RANDOM' or 'ORDER'`);
      }
      let nodeIdx = 0;
      let nodeKey = selectorFct(nodeList, nodeIdx);
      while ((avoidNodeKey === nodeKey || __privateGet(this, _nodes)[nodeKey].blacklistedUntil && __privateGet(this, _nodes)[nodeKey].blacklistedUntil > Date.now()) && nodeIdx < nodeList.length - 1) {
        nodeIdx++;
        nodeKey = selectorFct(nodeList, nodeIdx);
      }
      if (avoidNodeKey === nodeKey) {
        nodeIdx = 0;
        while (avoidNodeKey === nodeKey && nodeIdx < nodeList.length - 1) {
          nodeIdx++;
          nodeKey = selectorFct(nodeList, nodeIdx);
        }
      }
      return nodeKey;
    }
    /**
     * Connect, or if fail handle retry / set timeout error
     *
     * @param nodeList    current node list
     * @param nodeKey     node name to connect
     * @param retryFct    retry function
     * @return {Promise}
     * @private
     */
    _handleConnectionError(nodeList, nodeKey, retryFct) {
      const cluster2 = this;
      const node2 = __privateGet(this, _nodes)[nodeKey];
      return node2.getConnection().then((conn) => {
        node2.blacklistedUntil = null;
        node2.errorCount = 0;
        return Promise.resolve(conn);
      }).catch((err) => {
        node2.errorCount = node2.errorCount ? node2.errorCount + 1 : 1;
        node2.blacklistedUntil = Date.now() + __privateGet(cluster2, _opts).restoreNodeTimeout;
        if (__privateGet(cluster2, _opts).removeNodeErrorCount && node2.errorCount >= __privateGet(cluster2, _opts).removeNodeErrorCount && __privateGet(cluster2, _nodes)[nodeKey]) {
          delete __privateGet(cluster2, _nodes)[nodeKey];
          __privateSet(cluster2, _cachedPatterns, {});
          delete nodeList.lastRrIdx;
          setImmediate(cluster2.emit.bind(cluster2, "remove", nodeKey));
          node2.end().catch((err2) => {
          });
        }
        if (nodeList.length !== 0 && __privateGet(cluster2, _opts).canRetry && retryFct) {
          return retryFct(nodeKey, err);
        }
        return Promise.reject(err);
      });
    }
    /**
     * Connect, or if fail handle retry / set timeout error
     *
     * @param nodeList    current node list
     * @param nodeKey     node name to connect
     * @param retryFct    retry function
     * @param callback    callback function
     * @private
     */
    _handleConnectionCallbackError(nodeList, nodeKey, retryFct, callback) {
      const cluster2 = this;
      const node2 = __privateGet(this, _nodes)[nodeKey];
      node2.getConnection((err, conn) => {
        if (err) {
          node2.errorCount = node2.errorCount ? node2.errorCount + 1 : 1;
          node2.blacklistedUntil = Date.now() + __privateGet(cluster2, _opts).restoreNodeTimeout;
          if (__privateGet(cluster2, _opts).removeNodeErrorCount && node2.errorCount >= __privateGet(cluster2, _opts).removeNodeErrorCount && __privateGet(cluster2, _nodes)[nodeKey]) {
            delete __privateGet(cluster2, _nodes)[nodeKey];
            __privateSet(cluster2, _cachedPatterns, {});
            delete nodeList.lastRrIdx;
            setImmediate(cluster2.emit.bind(cluster2, "remove", nodeKey));
            node2.end(() => {
            });
          }
          if (nodeList.length !== 0 && __privateGet(cluster2, _opts).canRetry && retryFct) {
            return retryFct(nodeKey, err);
          }
          callback(err);
        } else {
          node2.errorCount = 0;
          callback(null, conn);
        }
      });
    }
    //*****************************************************************
    // internal public testing methods
    //*****************************************************************
    get __tests() {
      return new TestMethods(__privateGet(this, _nodes));
    }
  }
  _opts = new WeakMap();
  _nodes = new WeakMap();
  _cachedPatterns = new WeakMap();
  _nodeCounter = new WeakMap();
  class TestMethods {
    constructor(nodes) {
      __privateAdd(this, _nodes2);
      __privateSet(this, _nodes2, nodes);
    }
    getNodes() {
      return __privateGet(this, _nodes2);
    }
  }
  _nodes2 = new WeakMap();
  const roundRobinSelector = (nodeList) => {
    let lastRoundRobin = nodeList.lastRrIdx;
    if (lastRoundRobin === void 0) lastRoundRobin = -1;
    if (++lastRoundRobin >= nodeList.length) lastRoundRobin = 0;
    nodeList.lastRrIdx = lastRoundRobin;
    return nodeList[lastRoundRobin];
  };
  const randomSelector = (nodeList) => {
    let randomIdx = ~~(Math.random() * nodeList.length);
    return nodeList[randomIdx];
  };
  const orderedSelector = (nodeList, retry2) => {
    return nodeList[retry2];
  };
  cluster = Cluster;
  return cluster;
}
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  requireCheckNode();
  const Connection = requireConnection();
  const ConnectionPromise = requireConnectionPromise();
  const PoolPromise = requirePoolPromise();
  const Cluster = requireCluster();
  const ConnOptions = requireConnectionOptions();
  const PoolOptions = requirePoolOptions();
  const ClusterOptions = requireClusterOptions();
  promise.version = require$$8.version;
  promise.SqlError = requireErrors().SqlError;
  promise.defaultOptions = function defaultOptions(opts) {
    const connOpts = new ConnOptions(opts);
    const res = {};
    for (const [key, value] of Object.entries(connOpts)) {
      if (!key.startsWith("_")) {
        res[key] = value;
      }
    }
    return res;
  };
  promise.createConnection = function createConnection(opts) {
    try {
      const options = new ConnOptions(opts);
      const conn = new Connection(options);
      const connPromise = new ConnectionPromise(conn);
      return conn.connect().then(() => Promise.resolve(connPromise));
    } catch (err) {
      return Promise.reject(err);
    }
  };
  promise.createPool = function createPool(opts) {
    const options = new PoolOptions(opts);
    const pool2 = new PoolPromise(options);
    pool2.on("error", (err) => {
    });
    return pool2;
  };
  promise.createPoolCluster = function createPoolCluster(opts) {
    const options = new ClusterOptions(opts);
    return new Cluster(options);
  };
  promise.importFile = function importFile(opts) {
    try {
      const options = new ConnOptions(opts);
      const conn = new Connection(options);
      return conn.connect().then(() => {
        return new Promise(conn.importFile.bind(conn, Object.assign({ skipDbCheck: true }, opts)));
      }).finally(() => {
        new Promise(conn.end.bind(conn, {})).catch(console.log);
      });
    } catch (err) {
      return Promise.reject(err);
    }
  };
  return promise;
}
var promiseExports = requirePromise();
const mariadb = /* @__PURE__ */ getDefaultExportFromCjs(promiseExports);
const pool = mariadb.createPool({
  host: "49.142.106.218",
  user: "root",
  port: "31306",
  password: "3415",
  database: "bluedash",
  connectionLimit: 50
});
async function query(sql, params = {}) {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log("MariaDB  ");
    const values = Object.values(params);
    const result = await conn.query(sql, values);
    conn.commit();
    return result;
  } catch (error2) {
    console.error("  :", error2);
    throw error2;
  } finally {
    if (conn) conn.release();
  }
}
var main$2 = {};
var out = {};
var CancellationToken = {};
var hasRequiredCancellationToken;
function requireCancellationToken() {
  if (hasRequiredCancellationToken) return CancellationToken;
  hasRequiredCancellationToken = 1;
  Object.defineProperty(CancellationToken, "__esModule", { value: true });
  CancellationToken.CancellationError = CancellationToken.CancellationToken = void 0;
  const events_1 = require$$0$3;
  let CancellationToken$1 = class CancellationToken extends events_1.EventEmitter {
    get cancelled() {
      return this._cancelled || this._parent != null && this._parent.cancelled;
    }
    set parent(value) {
      this.removeParentCancelHandler();
      this._parent = value;
      this.parentCancelHandler = () => this.cancel();
      this._parent.onCancel(this.parentCancelHandler);
    }
    // babel cannot compile ... correctly for super calls
    constructor(parent) {
      super();
      this.parentCancelHandler = null;
      this._parent = null;
      this._cancelled = false;
      if (parent != null) {
        this.parent = parent;
      }
    }
    cancel() {
      this._cancelled = true;
      this.emit("cancel");
    }
    onCancel(handler) {
      if (this.cancelled) {
        handler();
      } else {
        this.once("cancel", handler);
      }
    }
    createPromise(callback) {
      if (this.cancelled) {
        return Promise.reject(new CancellationError());
      }
      const finallyHandler = () => {
        if (cancelHandler != null) {
          try {
            this.removeListener("cancel", cancelHandler);
            cancelHandler = null;
          } catch (_ignore) {
          }
        }
      };
      let cancelHandler = null;
      return new Promise((resolve, reject) => {
        let addedCancelHandler = null;
        cancelHandler = () => {
          try {
            if (addedCancelHandler != null) {
              addedCancelHandler();
              addedCancelHandler = null;
            }
          } finally {
            reject(new CancellationError());
          }
        };
        if (this.cancelled) {
          cancelHandler();
          return;
        }
        this.onCancel(cancelHandler);
        callback(resolve, reject, (callback2) => {
          addedCancelHandler = callback2;
        });
      }).then((it) => {
        finallyHandler();
        return it;
      }).catch((e) => {
        finallyHandler();
        throw e;
      });
    }
    removeParentCancelHandler() {
      const parent = this._parent;
      if (parent != null && this.parentCancelHandler != null) {
        parent.removeListener("cancel", this.parentCancelHandler);
        this.parentCancelHandler = null;
      }
    }
    dispose() {
      try {
        this.removeParentCancelHandler();
      } finally {
        this.removeAllListeners();
        this._parent = null;
      }
    }
  };
  CancellationToken.CancellationToken = CancellationToken$1;
  class CancellationError extends Error {
    constructor() {
      super("cancelled");
    }
  }
  CancellationToken.CancellationError = CancellationError;
  return CancellationToken;
}
var httpExecutor = {};
var src$1 = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common$1;
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$1 = setup;
  return common$1;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = requireCommon$1()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node$1 = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$2$1;
  const tty = require$$1$5;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module, exports) {
    const tty = require$$1$5;
    const util2 = require$$1$6;
    exports.init = init;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon$1()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$1, node$1.exports);
  return node$1.exports;
}
var hasRequiredSrc$1;
function requireSrc$1() {
  if (hasRequiredSrc$1) return src$1.exports;
  hasRequiredSrc$1 = 1;
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    src$1.exports = requireBrowser();
  } else {
    src$1.exports = requireNode$1();
  }
  return src$1.exports;
}
var error = {};
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error;
  hasRequiredError = 1;
  Object.defineProperty(error, "__esModule", { value: true });
  error.newError = newError;
  function newError(message, code) {
    const error2 = new Error(message);
    error2.code = code;
    return error2;
  }
  return error;
}
var ProgressCallbackTransform = {};
var hasRequiredProgressCallbackTransform;
function requireProgressCallbackTransform() {
  if (hasRequiredProgressCallbackTransform) return ProgressCallbackTransform;
  hasRequiredProgressCallbackTransform = 1;
  Object.defineProperty(ProgressCallbackTransform, "__esModule", { value: true });
  ProgressCallbackTransform.ProgressCallbackTransform = void 0;
  const stream_1 = require$$0$4;
  let ProgressCallbackTransform$1 = class ProgressCallbackTransform extends stream_1.Transform {
    constructor(total, cancellationToken, onProgress) {
      super();
      this.total = total;
      this.cancellationToken = cancellationToken;
      this.onProgress = onProgress;
      this.start = Date.now();
      this.transferred = 0;
      this.delta = 0;
      this.nextUpdate = this.start + 1e3;
    }
    _transform(chunk, encoding, callback) {
      if (this.cancellationToken.cancelled) {
        callback(new Error("cancelled"), null);
        return;
      }
      this.transferred += chunk.length;
      this.delta += chunk.length;
      const now = Date.now();
      if (now >= this.nextUpdate && this.transferred !== this.total) {
        this.nextUpdate = now + 1e3;
        this.onProgress({
          total: this.total,
          delta: this.delta,
          transferred: this.transferred,
          percent: this.transferred / this.total * 100,
          bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
        });
        this.delta = 0;
      }
      callback(null, chunk);
    }
    _flush(callback) {
      if (this.cancellationToken.cancelled) {
        callback(new Error("cancelled"));
        return;
      }
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.total,
        percent: 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
      this.delta = 0;
      callback(null);
    }
  };
  ProgressCallbackTransform.ProgressCallbackTransform = ProgressCallbackTransform$1;
  return ProgressCallbackTransform;
}
var hasRequiredHttpExecutor;
function requireHttpExecutor() {
  if (hasRequiredHttpExecutor) return httpExecutor;
  hasRequiredHttpExecutor = 1;
  Object.defineProperty(httpExecutor, "__esModule", { value: true });
  httpExecutor.DigestTransform = httpExecutor.HttpExecutor = httpExecutor.HttpError = void 0;
  httpExecutor.createHttpError = createHttpError;
  httpExecutor.parseJson = parseJson;
  httpExecutor.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
  httpExecutor.configureRequestUrl = configureRequestUrl;
  httpExecutor.safeGetHeader = safeGetHeader;
  httpExecutor.configureRequestOptions = configureRequestOptions;
  httpExecutor.safeStringifyJson = safeStringifyJson;
  const crypto_1 = require$$1$3;
  const debug_12 = requireSrc$1();
  const fs_1 = require$$1$2;
  const stream_1 = require$$0$4;
  const url_1 = require$$4$2;
  const CancellationToken_1 = requireCancellationToken();
  const error_1 = requireError();
  const ProgressCallbackTransform_1 = requireProgressCallbackTransform();
  const debug = (0, debug_12.default)("electron-builder");
  function createHttpError(response, description = null) {
    return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description == null ? "" : "\n" + JSON.stringify(description, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description);
  }
  const HTTP_STATUS_CODES = /* @__PURE__ */ new Map([
    [429, "Too many requests"],
    [400, "Bad request"],
    [403, "Forbidden"],
    [404, "Not found"],
    [405, "Method not allowed"],
    [406, "Not acceptable"],
    [408, "Request timeout"],
    [413, "Request entity too large"],
    [500, "Internal server error"],
    [502, "Bad gateway"],
    [503, "Service unavailable"],
    [504, "Gateway timeout"],
    [505, "HTTP version not supported"]
  ]);
  class HttpError extends Error {
    constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description = null) {
      super(message);
      this.statusCode = statusCode;
      this.description = description;
      this.name = "HttpError";
      this.code = `HTTP_ERROR_${statusCode}`;
    }
    isServerError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
  }
  httpExecutor.HttpError = HttpError;
  function parseJson(result) {
    return result.then((it) => it == null || it.length === 0 ? null : JSON.parse(it));
  }
  class HttpExecutor {
    constructor() {
      this.maxRedirects = 10;
    }
    request(options, cancellationToken = new CancellationToken_1.CancellationToken(), data) {
      configureRequestOptions(options);
      const json2 = data == null ? void 0 : JSON.stringify(data);
      const encodedData = json2 ? Buffer.from(json2) : void 0;
      if (encodedData != null) {
        debug(json2);
        const { headers, ...opts } = options;
        options = {
          method: "post",
          headers: {
            "Content-Type": "application/json",
            "Content-Length": encodedData.length,
            ...headers
          },
          ...opts
        };
      }
      return this.doApiRequest(options, cancellationToken, (it) => it.end(encodedData));
    }
    doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
      if (debug.enabled) {
        debug(`Request: ${safeStringifyJson(options)}`);
      }
      return cancellationToken.createPromise((resolve, reject, onCancel) => {
        const request = this.createRequest(options, (response) => {
          try {
            this.handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor);
          } catch (e) {
            reject(e);
          }
        });
        this.addErrorAndTimeoutHandlers(request, reject, options.timeout);
        this.addRedirectHandlers(request, options, reject, redirectCount, (options2) => {
          this.doApiRequest(options2, cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
        });
        requestProcessor(request, reject);
        onCancel(() => request.abort());
      });
    }
    // noinspection JSUnusedLocalSymbols
    // eslint-disable-next-line
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
    }
    addErrorAndTimeoutHandlers(request, reject, timeout = 60 * 1e3) {
      this.addTimeOutHandler(request, reject, timeout);
      request.on("error", reject);
      request.on("aborted", () => {
        reject(new Error("Request has been aborted by the server"));
      });
    }
    handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor) {
      var _a;
      if (debug.enabled) {
        debug(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);
      }
      if (response.statusCode === 404) {
        reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
        return;
      } else if (response.statusCode === 204) {
        resolve();
        return;
      }
      const code = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0;
      const shouldRedirect = code >= 300 && code < 400;
      const redirectUrl = safeGetHeader(response, "location");
      if (shouldRedirect && redirectUrl != null) {
        if (redirectCount > this.maxRedirects) {
          reject(this.createMaxRedirectError());
          return;
        }
        this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
        return;
      }
      response.setEncoding("utf8");
      let data = "";
      response.on("error", reject);
      response.on("data", (chunk) => data += chunk);
      response.on("end", () => {
        try {
          if (response.statusCode != null && response.statusCode >= 400) {
            const contentType = safeGetHeader(response, "content-type");
            const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find((it) => it.includes("json")) != null : contentType.includes("json"));
            reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

          Data:
          ${isJson ? JSON.stringify(JSON.parse(data)) : data}
          `));
          } else {
            resolve(data.length === 0 ? null : data);
          }
        } catch (e) {
          reject(e);
        }
      });
    }
    async downloadToBuffer(url, options) {
      return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {
        const responseChunks = [];
        const requestOptions = {
          headers: options.headers || void 0,
          // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
          redirect: "manual"
        };
        configureRequestUrl(url, requestOptions);
        configureRequestOptions(requestOptions);
        this.doDownload(requestOptions, {
          destination: null,
          options,
          onCancel,
          callback: (error2) => {
            if (error2 == null) {
              resolve(Buffer.concat(responseChunks));
            } else {
              reject(error2);
            }
          },
          responseHandler: (response, callback) => {
            let receivedLength = 0;
            response.on("data", (chunk) => {
              receivedLength += chunk.length;
              if (receivedLength > 524288e3) {
                callback(new Error("Maximum allowed size is 500 MB"));
                return;
              }
              responseChunks.push(chunk);
            });
            response.on("end", () => {
              callback(null);
            });
          }
        }, 0);
      });
    }
    doDownload(requestOptions, options, redirectCount) {
      const request = this.createRequest(requestOptions, (response) => {
        if (response.statusCode >= 400) {
          options.callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response.statusCode}: ${response.statusMessage}`));
          return;
        }
        response.on("error", options.callback);
        const redirectUrl = safeGetHeader(response, "location");
        if (redirectUrl != null) {
          if (redirectCount < this.maxRedirects) {
            this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), options, redirectCount++);
          } else {
            options.callback(this.createMaxRedirectError());
          }
          return;
        }
        if (options.responseHandler == null) {
          configurePipes(options, response);
        } else {
          options.responseHandler(response, options.callback);
        }
      });
      this.addErrorAndTimeoutHandlers(request, options.callback, requestOptions.timeout);
      this.addRedirectHandlers(request, requestOptions, options.callback, redirectCount, (requestOptions2) => {
        this.doDownload(requestOptions2, options, redirectCount++);
      });
      request.end();
    }
    createMaxRedirectError() {
      return new Error(`Too many redirects (> ${this.maxRedirects})`);
    }
    addTimeOutHandler(request, callback, timeout) {
      request.on("socket", (socket) => {
        socket.setTimeout(timeout, () => {
          request.abort();
          callback(new Error("Request timed out"));
        });
      });
    }
    static prepareRedirectUrlOptions(redirectUrl, options) {
      const newOptions = configureRequestOptionsFromUrl(redirectUrl, { ...options });
      const headers = newOptions.headers;
      if (headers === null || headers === void 0 ? void 0 : headers.authorization) {
        const parsedNewUrl = new url_1.URL(redirectUrl);
        if (parsedNewUrl.hostname.endsWith(".amazonaws.com") || parsedNewUrl.searchParams.has("X-Amz-Credential")) {
          delete headers.authorization;
        }
      }
      return newOptions;
    }
    static retryOnServerError(task, maxRetries = 3) {
      for (let attemptNumber = 0; ; attemptNumber++) {
        try {
          return task();
        } catch (e) {
          if (attemptNumber < maxRetries && (e instanceof HttpError && e.isServerError() || e.code === "EPIPE")) {
            continue;
          }
          throw e;
        }
      }
    }
  }
  httpExecutor.HttpExecutor = HttpExecutor;
  function configureRequestOptionsFromUrl(url, options) {
    const result = configureRequestOptions(options);
    configureRequestUrl(new url_1.URL(url), result);
    return result;
  }
  function configureRequestUrl(url, options) {
    options.protocol = url.protocol;
    options.hostname = url.hostname;
    if (url.port) {
      options.port = url.port;
    } else if (options.port) {
      delete options.port;
    }
    options.path = url.pathname + url.search;
  }
  class DigestTransform extends stream_1.Transform {
    // noinspection JSUnusedGlobalSymbols
    get actual() {
      return this._actual;
    }
    constructor(expected, algorithm = "sha512", encoding = "base64") {
      super();
      this.expected = expected;
      this.algorithm = algorithm;
      this.encoding = encoding;
      this._actual = null;
      this.isValidateOnEnd = true;
      this.digester = (0, crypto_1.createHash)(algorithm);
    }
    // noinspection JSUnusedGlobalSymbols
    _transform(chunk, encoding, callback) {
      this.digester.update(chunk);
      callback(null, chunk);
    }
    // noinspection JSUnusedGlobalSymbols
    _flush(callback) {
      this._actual = this.digester.digest(this.encoding);
      if (this.isValidateOnEnd) {
        try {
          this.validate();
        } catch (e) {
          callback(e);
          return;
        }
      }
      callback(null);
    }
    validate() {
      if (this._actual == null) {
        throw (0, error_1.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
      }
      if (this._actual !== this.expected) {
        throw (0, error_1.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
      }
      return null;
    }
  }
  httpExecutor.DigestTransform = DigestTransform;
  function checkSha2(sha2Header, sha2, callback) {
    if (sha2Header != null && sha2 != null && sha2Header !== sha2) {
      callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
      return false;
    }
    return true;
  }
  function safeGetHeader(response, headerKey) {
    const value = response.headers[headerKey];
    if (value == null) {
      return null;
    } else if (Array.isArray(value)) {
      return value.length === 0 ? null : value[value.length - 1];
    } else {
      return value;
    }
  }
  function configurePipes(options, response) {
    if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.options.sha2, options.callback)) {
      return;
    }
    const streams2 = [];
    if (options.options.onProgress != null) {
      const contentLength = safeGetHeader(response, "content-length");
      if (contentLength != null) {
        streams2.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));
      }
    }
    const sha512 = options.options.sha512;
    if (sha512 != null) {
      streams2.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
    } else if (options.options.sha2 != null) {
      streams2.push(new DigestTransform(options.options.sha2, "sha256", "hex"));
    }
    const fileOut = (0, fs_1.createWriteStream)(options.destination);
    streams2.push(fileOut);
    let lastStream = response;
    for (const stream2 of streams2) {
      stream2.on("error", (error2) => {
        fileOut.close();
        if (!options.options.cancellationToken.cancelled) {
          options.callback(error2);
        }
      });
      lastStream = lastStream.pipe(stream2);
    }
    fileOut.on("finish", () => {
      fileOut.close(options.callback);
    });
  }
  function configureRequestOptions(options, token, method) {
    if (method != null) {
      options.method = method;
    }
    options.headers = { ...options.headers };
    const headers = options.headers;
    if (token != null) {
      headers.authorization = token.startsWith("Basic") || token.startsWith("Bearer") ? token : `token ${token}`;
    }
    if (headers["User-Agent"] == null) {
      headers["User-Agent"] = "electron-builder";
    }
    if (method == null || method === "GET" || headers["Cache-Control"] == null) {
      headers["Cache-Control"] = "no-cache";
    }
    if (options.protocol == null && process.versions.electron != null) {
      options.protocol = "https:";
    }
    return options;
  }
  function safeStringifyJson(data, skippedNames) {
    return JSON.stringify(data, (name, value) => {
      if (name.endsWith("Authorization") || name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
        return "<stripped sensitive data>";
      }
      return value;
    }, 2);
  }
  return httpExecutor;
}
var publishOptions = {};
var hasRequiredPublishOptions;
function requirePublishOptions() {
  if (hasRequiredPublishOptions) return publishOptions;
  hasRequiredPublishOptions = 1;
  Object.defineProperty(publishOptions, "__esModule", { value: true });
  publishOptions.githubUrl = githubUrl;
  publishOptions.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
  function githubUrl(options, defaultHost = "github.com") {
    return `${options.protocol || "https"}://${options.host || defaultHost}`;
  }
  function getS3LikeProviderBaseUrl(configuration) {
    const provider = configuration.provider;
    if (provider === "s3") {
      return s3Url(configuration);
    }
    if (provider === "spaces") {
      return spacesUrl(configuration);
    }
    throw new Error(`Not supported provider: ${provider}`);
  }
  function s3Url(options) {
    let url;
    if (options.accelerate == true) {
      url = `https://${options.bucket}.s3-accelerate.amazonaws.com`;
    } else if (options.endpoint != null) {
      url = `${options.endpoint}/${options.bucket}`;
    } else if (options.bucket.includes(".")) {
      if (options.region == null) {
        throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
      }
      if (options.region === "us-east-1") {
        url = `https://s3.amazonaws.com/${options.bucket}`;
      } else {
        url = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
      }
    } else if (options.region === "cn-north-1") {
      url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
    } else {
      url = `https://${options.bucket}.s3.amazonaws.com`;
    }
    return appendPath(url, options.path);
  }
  function appendPath(url, p) {
    if (p != null && p.length > 0) {
      if (!p.startsWith("/")) {
        url += "/";
      }
      url += p;
    }
    return url;
  }
  function spacesUrl(options) {
    if (options.name == null) {
      throw new Error(`name is missing`);
    }
    if (options.region == null) {
      throw new Error(`region is missing`);
    }
    return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);
  }
  return publishOptions;
}
var rfc2253Parser = {};
var hasRequiredRfc2253Parser;
function requireRfc2253Parser() {
  if (hasRequiredRfc2253Parser) return rfc2253Parser;
  hasRequiredRfc2253Parser = 1;
  Object.defineProperty(rfc2253Parser, "__esModule", { value: true });
  rfc2253Parser.parseDn = parseDn;
  function parseDn(seq2) {
    let quoted = false;
    let key = null;
    let token = "";
    let nextNonSpace = 0;
    seq2 = seq2.trim();
    const result = /* @__PURE__ */ new Map();
    for (let i = 0; i <= seq2.length; i++) {
      if (i === seq2.length) {
        if (key !== null) {
          result.set(key, token);
        }
        break;
      }
      const ch = seq2[i];
      if (quoted) {
        if (ch === '"') {
          quoted = false;
          continue;
        }
      } else {
        if (ch === '"') {
          quoted = true;
          continue;
        }
        if (ch === "\\") {
          i++;
          const ord = parseInt(seq2.slice(i, i + 2), 16);
          if (Number.isNaN(ord)) {
            token += seq2[i];
          } else {
            i++;
            token += String.fromCharCode(ord);
          }
          continue;
        }
        if (key === null && ch === "=") {
          key = token;
          token = "";
          continue;
        }
        if (ch === "," || ch === ";" || ch === "+") {
          if (key !== null) {
            result.set(key, token);
          }
          key = null;
          token = "";
          continue;
        }
      }
      if (ch === " " && !quoted) {
        if (token.length === 0) {
          continue;
        }
        if (i > nextNonSpace) {
          let j = i;
          while (seq2[j] === " ") {
            j++;
          }
          nextNonSpace = j;
        }
        if (nextNonSpace >= seq2.length || seq2[nextNonSpace] === "," || seq2[nextNonSpace] === ";" || key === null && seq2[nextNonSpace] === "=" || key !== null && seq2[nextNonSpace] === "+") {
          i = nextNonSpace - 1;
          continue;
        }
      }
      token += ch;
    }
    return result;
  }
  return rfc2253Parser;
}
var uuid = {};
var hasRequiredUuid;
function requireUuid() {
  if (hasRequiredUuid) return uuid;
  hasRequiredUuid = 1;
  Object.defineProperty(uuid, "__esModule", { value: true });
  uuid.nil = uuid.UUID = void 0;
  const crypto_1 = require$$1$3;
  const error_1 = requireError();
  const invalidName = "options.name must be either a string or a Buffer";
  const randomHost = (0, crypto_1.randomBytes)(16);
  randomHost[0] = randomHost[0] | 1;
  const hex2byte = {};
  const byte2hex = [];
  for (let i = 0; i < 256; i++) {
    const hex = (i + 256).toString(16).substr(1);
    hex2byte[hex] = i;
    byte2hex[i] = hex;
  }
  class UUID {
    constructor(uuid2) {
      this.ascii = null;
      this.binary = null;
      const check = UUID.check(uuid2);
      if (!check) {
        throw new Error("not a UUID");
      }
      this.version = check.version;
      if (check.format === "ascii") {
        this.ascii = uuid2;
      } else {
        this.binary = uuid2;
      }
    }
    static v5(name, namespace) {
      return uuidNamed(name, "sha1", 80, namespace);
    }
    toString() {
      if (this.ascii == null) {
        this.ascii = stringify(this.binary);
      }
      return this.ascii;
    }
    inspect() {
      return `UUID v${this.version} ${this.toString()}`;
    }
    static check(uuid2, offset = 0) {
      if (typeof uuid2 === "string") {
        uuid2 = uuid2.toLowerCase();
        if (!/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(uuid2)) {
          return false;
        }
        if (uuid2 === "00000000-0000-0000-0000-000000000000") {
          return { version: void 0, variant: "nil", format: "ascii" };
        }
        return {
          version: (hex2byte[uuid2[14] + uuid2[15]] & 240) >> 4,
          variant: getVariant((hex2byte[uuid2[19] + uuid2[20]] & 224) >> 5),
          format: "ascii"
        };
      }
      if (Buffer.isBuffer(uuid2)) {
        if (uuid2.length < offset + 16) {
          return false;
        }
        let i = 0;
        for (; i < 16; i++) {
          if (uuid2[offset + i] !== 0) {
            break;
          }
        }
        if (i === 16) {
          return { version: void 0, variant: "nil", format: "binary" };
        }
        return {
          version: (uuid2[offset + 6] & 240) >> 4,
          variant: getVariant((uuid2[offset + 8] & 224) >> 5),
          format: "binary"
        };
      }
      throw (0, error_1.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
    }
    // read stringified uuid into a Buffer
    static parse(input) {
      const buffer = Buffer.allocUnsafe(16);
      let j = 0;
      for (let i = 0; i < 16; i++) {
        buffer[i] = hex2byte[input[j++] + input[j++]];
        if (i === 3 || i === 5 || i === 7 || i === 9) {
          j += 1;
        }
      }
      return buffer;
    }
  }
  uuid.UUID = UUID;
  UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
  function getVariant(bits) {
    switch (bits) {
      case 0:
      case 1:
      case 3:
        return "ncs";
      case 4:
      case 5:
        return "rfc4122";
      case 6:
        return "microsoft";
      default:
        return "future";
    }
  }
  var UuidEncoding;
  (function(UuidEncoding2) {
    UuidEncoding2[UuidEncoding2["ASCII"] = 0] = "ASCII";
    UuidEncoding2[UuidEncoding2["BINARY"] = 1] = "BINARY";
    UuidEncoding2[UuidEncoding2["OBJECT"] = 2] = "OBJECT";
  })(UuidEncoding || (UuidEncoding = {}));
  function uuidNamed(name, hashMethod, version2, namespace, encoding = UuidEncoding.ASCII) {
    const hash = (0, crypto_1.createHash)(hashMethod);
    const nameIsNotAString = typeof name !== "string";
    if (nameIsNotAString && !Buffer.isBuffer(name)) {
      throw (0, error_1.newError)(invalidName, "ERR_INVALID_UUID_NAME");
    }
    hash.update(namespace);
    hash.update(name);
    const buffer = hash.digest();
    let result;
    switch (encoding) {
      case UuidEncoding.BINARY:
        buffer[6] = buffer[6] & 15 | version2;
        buffer[8] = buffer[8] & 63 | 128;
        result = buffer;
        break;
      case UuidEncoding.OBJECT:
        buffer[6] = buffer[6] & 15 | version2;
        buffer[8] = buffer[8] & 63 | 128;
        result = new UUID(buffer);
        break;
      default:
        result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 15 | version2] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 63 | 128] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
        break;
    }
    return result;
  }
  function stringify(buffer) {
    return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
  }
  uuid.nil = new UUID("00000000-0000-0000-0000-000000000000");
  return uuid;
}
var xml = {};
var sax = {};
var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  (function(exports) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser2 = this;
        clearBuffers(parser2);
        parser2.q = parser2.c = "";
        parser2.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser2.opt = opt || {};
        parser2.opt.lowercase = parser2.opt.lowercase || parser2.opt.lowercasetags;
        parser2.looseCase = parser2.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser2.tags = [];
        parser2.closed = parser2.closedRoot = parser2.sawRoot = false;
        parser2.tag = parser2.error = null;
        parser2.strict = !!strict;
        parser2.noscript = !!(strict || parser2.opt.noscript);
        parser2.state = S.BEGIN;
        parser2.strictEntities = parser2.opt.strictEntities;
        parser2.ENTITIES = parser2.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser2.attribList = [];
        if (parser2.opt.xmlns) {
          parser2.ns = Object.create(rootNS);
        }
        if (parser2.opt.unquotedAttributeValues === void 0) {
          parser2.opt.unquotedAttributeValues = !strict;
        }
        parser2.trackPosition = parser2.opt.position !== false;
        if (parser2.trackPosition) {
          parser2.position = parser2.line = parser2.column = 0;
        }
        emit(parser2, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser2) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser2[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser2);
                break;
              case "cdata":
                emitNode(parser2, "oncdata", parser2.cdata);
                parser2.cdata = "";
                break;
              case "script":
                emitNode(parser2, "onscript", parser2.script);
                parser2.script = "";
                break;
              default:
                error2(parser2, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser2.bufferCheckPosition = m + parser2.position;
      }
      function clearBuffers(parser2) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser2[buffers[i]] = "";
        }
      }
      function flushBuffers(parser2) {
        closeText(parser2);
        if (parser2.cdata !== "") {
          emitNode(parser2, "oncdata", parser2.cdata);
          parser2.cdata = "";
        }
        if (parser2.script !== "") {
          emitNode(parser2, "onscript", parser2.script);
          parser2.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require("stream").Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream) Stream = function() {
      };
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require$$1$4.StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax2.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S = sax2.STATE;
      function emit(parser2, event, data) {
        parser2[event] && parser2[event](data);
      }
      function emitNode(parser2, nodeType, data) {
        if (parser2.textNode) closeText(parser2);
        emit(parser2, nodeType, data);
      }
      function closeText(parser2) {
        parser2.textNode = textopts(parser2.opt, parser2.textNode);
        if (parser2.textNode) emit(parser2, "ontext", parser2.textNode);
        parser2.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error2(parser2, er) {
        closeText(parser2);
        if (parser2.trackPosition) {
          er += "\nLine: " + parser2.line + "\nColumn: " + parser2.column + "\nChar: " + parser2.c;
        }
        er = new Error(er);
        parser2.error = er;
        emit(parser2, "onerror", er);
        return parser2;
      }
      function end(parser2) {
        if (parser2.sawRoot && !parser2.closedRoot) strictFail(parser2, "Unclosed root tag");
        if (parser2.state !== S.BEGIN && parser2.state !== S.BEGIN_WHITESPACE && parser2.state !== S.TEXT) {
          error2(parser2, "Unexpected end");
        }
        closeText(parser2);
        parser2.c = "";
        parser2.closed = true;
        emit(parser2, "onend");
        SAXParser.call(parser2, parser2.strict, parser2.opt);
        return parser2;
      }
      function strictFail(parser2, message) {
        if (typeof parser2 !== "object" || !(parser2 instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser2.strict) {
          error2(parser2, message);
        }
      }
      function newTag(parser2) {
        if (!parser2.strict) parser2.tagName = parser2.tagName[parser2.looseCase]();
        var parent = parser2.tags[parser2.tags.length - 1] || parser2;
        var tag = parser2.tag = { name: parser2.tagName, attributes: {} };
        if (parser2.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser2.attribList.length = 0;
        emitNode(parser2, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser2) {
        if (!parser2.strict) {
          parser2.attribName = parser2.attribName[parser2.looseCase]();
        }
        if (parser2.attribList.indexOf(parser2.attribName) !== -1 || parser2.tag.attributes.hasOwnProperty(parser2.attribName)) {
          parser2.attribName = parser2.attribValue = "";
          return;
        }
        if (parser2.opt.xmlns) {
          var qn = qname(parser2.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser2.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser2,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser2.attribValue
              );
            } else if (local === "xmlns" && parser2.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser2,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser2.attribValue
              );
            } else {
              var tag = parser2.tag;
              var parent = parser2.tags[parser2.tags.length - 1] || parser2;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser2.attribValue;
            }
          }
          parser2.attribList.push([parser2.attribName, parser2.attribValue]);
        } else {
          parser2.tag.attributes[parser2.attribName] = parser2.attribValue;
          emitNode(parser2, "onattribute", {
            name: parser2.attribName,
            value: parser2.attribValue
          });
        }
        parser2.attribName = parser2.attribValue = "";
      }
      function openTag(parser2, selfClosing) {
        if (parser2.opt.xmlns) {
          var tag = parser2.tag;
          var qn = qname(parser2.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser2, "Unbound namespace prefix: " + JSON.stringify(parser2.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser2.tags[parser2.tags.length - 1] || parser2;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser2, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser2.attribList.length; i < l; i++) {
            var nv = parser2.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser2, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser2.tag.attributes[name] = a;
            emitNode(parser2, "onattribute", a);
          }
          parser2.attribList.length = 0;
        }
        parser2.tag.isSelfClosing = !!selfClosing;
        parser2.sawRoot = true;
        parser2.tags.push(parser2.tag);
        emitNode(parser2, "onopentag", parser2.tag);
        if (!selfClosing) {
          if (!parser2.noscript && parser2.tagName.toLowerCase() === "script") {
            parser2.state = S.SCRIPT;
          } else {
            parser2.state = S.TEXT;
          }
          parser2.tag = null;
          parser2.tagName = "";
        }
        parser2.attribName = parser2.attribValue = "";
        parser2.attribList.length = 0;
      }
      function closeTag(parser2) {
        if (!parser2.tagName) {
          strictFail(parser2, "Weird empty close tag.");
          parser2.textNode += "</>";
          parser2.state = S.TEXT;
          return;
        }
        if (parser2.script) {
          if (parser2.tagName !== "script") {
            parser2.script += "</" + parser2.tagName + ">";
            parser2.tagName = "";
            parser2.state = S.SCRIPT;
            return;
          }
          emitNode(parser2, "onscript", parser2.script);
          parser2.script = "";
        }
        var t = parser2.tags.length;
        var tagName = parser2.tagName;
        if (!parser2.strict) {
          tagName = tagName[parser2.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser2.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser2, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser2, "Unmatched closing tag: " + parser2.tagName);
          parser2.textNode += "</" + parser2.tagName + ">";
          parser2.state = S.TEXT;
          return;
        }
        parser2.tagName = tagName;
        var s2 = parser2.tags.length;
        while (s2-- > t) {
          var tag = parser2.tag = parser2.tags.pop();
          parser2.tagName = parser2.tag.name;
          emitNode(parser2, "onclosetag", parser2.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser2.tags[parser2.tags.length - 1] || parser2;
          if (parser2.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser2, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser2.closedRoot = true;
        parser2.tagName = parser2.attribValue = parser2.attribName = "";
        parser2.attribList.length = 0;
        parser2.state = S.TEXT;
      }
      function parseEntity(parser2) {
        var entity = parser2.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser2.ENTITIES[entity]) {
          return parser2.ENTITIES[entity];
        }
        if (parser2.ENTITIES[entityLC]) {
          return parser2.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser2, "Invalid character entity");
          return "&" + parser2.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser2, c) {
        if (c === "<") {
          parser2.state = S.OPEN_WAKA;
          parser2.startTagPosition = parser2.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser2, "Non-whitespace before first tag.");
          parser2.textNode = c;
          parser2.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser2 = this;
        if (this.error) {
          throw this.error;
        }
        if (parser2.closed) {
          return error2(
            parser2,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser2);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser2.c = c;
          if (!c) {
            break;
          }
          if (parser2.trackPosition) {
            parser2.position++;
            if (c === "\n") {
              parser2.line++;
              parser2.column = 0;
            } else {
              parser2.column++;
            }
          }
          switch (parser2.state) {
            case S.BEGIN:
              parser2.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser2, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser2, c);
              continue;
            case S.TEXT:
              if (parser2.sawRoot && !parser2.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser2.trackPosition) {
                    parser2.position++;
                    if (c === "\n") {
                      parser2.line++;
                      parser2.column = 0;
                    } else {
                      parser2.column++;
                    }
                  }
                }
                parser2.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser2.sawRoot && parser2.closedRoot && !parser2.strict)) {
                parser2.state = S.OPEN_WAKA;
                parser2.startTagPosition = parser2.position;
              } else {
                if (!isWhitespace(c) && (!parser2.sawRoot || parser2.closedRoot)) {
                  strictFail(parser2, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser2.state = S.TEXT_ENTITY;
                } else {
                  parser2.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser2.state = S.SCRIPT_ENDING;
              } else {
                parser2.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser2.state = S.CLOSE_TAG;
              } else {
                parser2.script += "<" + c;
                parser2.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser2.state = S.SGML_DECL;
                parser2.sgmlDecl = "";
              } else if (isWhitespace(c)) ;
              else if (isMatch(nameStart, c)) {
                parser2.state = S.OPEN_TAG;
                parser2.tagName = c;
              } else if (c === "/") {
                parser2.state = S.CLOSE_TAG;
                parser2.tagName = "";
              } else if (c === "?") {
                parser2.state = S.PROC_INST;
                parser2.procInstName = parser2.procInstBody = "";
              } else {
                strictFail(parser2, "Unencoded <");
                if (parser2.startTagPosition + 1 < parser2.position) {
                  var pad = parser2.position - parser2.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser2.textNode += "<" + c;
                parser2.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if (parser2.sgmlDecl + c === "--") {
                parser2.state = S.COMMENT;
                parser2.comment = "";
                parser2.sgmlDecl = "";
                continue;
              }
              if (parser2.doctype && parser2.doctype !== true && parser2.sgmlDecl) {
                parser2.state = S.DOCTYPE_DTD;
                parser2.doctype += "<!" + parser2.sgmlDecl + c;
                parser2.sgmlDecl = "";
              } else if ((parser2.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser2, "onopencdata");
                parser2.state = S.CDATA;
                parser2.sgmlDecl = "";
                parser2.cdata = "";
              } else if ((parser2.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser2.state = S.DOCTYPE;
                if (parser2.doctype || parser2.sawRoot) {
                  strictFail(
                    parser2,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser2.doctype = "";
                parser2.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser2, "onsgmldeclaration", parser2.sgmlDecl);
                parser2.sgmlDecl = "";
                parser2.state = S.TEXT;
              } else if (isQuote(c)) {
                parser2.state = S.SGML_DECL_QUOTED;
                parser2.sgmlDecl += c;
              } else {
                parser2.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser2.q) {
                parser2.state = S.SGML_DECL;
                parser2.q = "";
              }
              parser2.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser2.state = S.TEXT;
                emitNode(parser2, "ondoctype", parser2.doctype);
                parser2.doctype = true;
              } else {
                parser2.doctype += c;
                if (c === "[") {
                  parser2.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser2.state = S.DOCTYPE_QUOTED;
                  parser2.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser2.doctype += c;
              if (c === parser2.q) {
                parser2.q = "";
                parser2.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              if (c === "]") {
                parser2.doctype += c;
                parser2.state = S.DOCTYPE;
              } else if (c === "<") {
                parser2.state = S.OPEN_WAKA;
                parser2.startTagPosition = parser2.position;
              } else if (isQuote(c)) {
                parser2.doctype += c;
                parser2.state = S.DOCTYPE_DTD_QUOTED;
                parser2.q = c;
              } else {
                parser2.doctype += c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser2.doctype += c;
              if (c === parser2.q) {
                parser2.state = S.DOCTYPE_DTD;
                parser2.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser2.state = S.COMMENT_ENDING;
              } else {
                parser2.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser2.state = S.COMMENT_ENDED;
                parser2.comment = textopts(parser2.opt, parser2.comment);
                if (parser2.comment) {
                  emitNode(parser2, "oncomment", parser2.comment);
                }
                parser2.comment = "";
              } else {
                parser2.comment += "-" + c;
                parser2.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser2, "Malformed comment");
                parser2.comment += "--" + c;
                parser2.state = S.COMMENT;
              } else if (parser2.doctype && parser2.doctype !== true) {
                parser2.state = S.DOCTYPE_DTD;
              } else {
                parser2.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser2.state = S.CDATA_ENDING;
              } else {
                parser2.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser2.state = S.CDATA_ENDING_2;
              } else {
                parser2.cdata += "]" + c;
                parser2.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser2.cdata) {
                  emitNode(parser2, "oncdata", parser2.cdata);
                }
                emitNode(parser2, "onclosecdata");
                parser2.cdata = "";
                parser2.state = S.TEXT;
              } else if (c === "]") {
                parser2.cdata += "]";
              } else {
                parser2.cdata += "]]" + c;
                parser2.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser2.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser2.state = S.PROC_INST_BODY;
              } else {
                parser2.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser2.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser2.state = S.PROC_INST_ENDING;
              } else {
                parser2.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser2, "onprocessinginstruction", {
                  name: parser2.procInstName,
                  body: parser2.procInstBody
                });
                parser2.procInstName = parser2.procInstBody = "";
                parser2.state = S.TEXT;
              } else {
                parser2.procInstBody += "?" + c;
                parser2.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser2.tagName += c;
              } else {
                newTag(parser2);
                if (c === ">") {
                  openTag(parser2);
                } else if (c === "/") {
                  parser2.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser2, "Invalid character in tag name");
                  }
                  parser2.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser2, true);
                closeTag(parser2);
              } else {
                strictFail(parser2, "Forward-slash in opening tag not followed by >");
                parser2.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser2);
              } else if (c === "/") {
                parser2.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser2.attribName = c;
                parser2.attribValue = "";
                parser2.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser2, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser2.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser2, "Attribute without value");
                parser2.attribValue = parser2.attribName;
                attrib(parser2);
                openTag(parser2);
              } else if (isWhitespace(c)) {
                parser2.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser2.attribName += c;
              } else {
                strictFail(parser2, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser2.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser2, "Attribute without value");
                parser2.tag.attributes[parser2.attribName] = "";
                parser2.attribValue = "";
                emitNode(parser2, "onattribute", {
                  name: parser2.attribName,
                  value: ""
                });
                parser2.attribName = "";
                if (c === ">") {
                  openTag(parser2);
                } else if (isMatch(nameStart, c)) {
                  parser2.attribName = c;
                  parser2.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser2, "Invalid attribute name");
                  parser2.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser2.q = c;
                parser2.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser2.opt.unquotedAttributeValues) {
                  error2(parser2, "Unquoted attribute value");
                }
                parser2.state = S.ATTRIB_VALUE_UNQUOTED;
                parser2.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser2.q) {
                if (c === "&") {
                  parser2.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser2.attribValue += c;
                }
                continue;
              }
              attrib(parser2);
              parser2.q = "";
              parser2.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser2.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser2);
              } else if (c === "/") {
                parser2.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser2, "No whitespace between attributes");
                parser2.attribName = c;
                parser2.attribValue = "";
                parser2.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser2, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser2.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser2.attribValue += c;
                }
                continue;
              }
              attrib(parser2);
              if (c === ">") {
                openTag(parser2);
              } else {
                parser2.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser2.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser2.script) {
                    parser2.script += "</" + c;
                    parser2.state = S.SCRIPT;
                  } else {
                    strictFail(parser2, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser2.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser2);
              } else if (isMatch(nameBody, c)) {
                parser2.tagName += c;
              } else if (parser2.script) {
                parser2.script += "</" + parser2.tagName;
                parser2.tagName = "";
                parser2.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser2, "Invalid tagname in closing tag");
                }
                parser2.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser2);
              } else {
                strictFail(parser2, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser2.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser2);
                if (parser2.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                  parser2.entity = "";
                  parser2.state = returnState;
                  parser2.write(parsedEntity);
                } else {
                  parser2[buffer] += parsedEntity;
                  parser2.entity = "";
                  parser2.state = returnState;
                }
              } else if (isMatch(parser2.entity.length ? entityBody : entityStart, c)) {
                parser2.entity += c;
              } else {
                strictFail(parser2, "Invalid character in entity name");
                parser2[buffer] += "&" + parser2.entity + c;
                parser2.entity = "";
                parser2.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser2, "Unknown state: " + parser2.state);
            }
          }
        }
        if (parser2.position >= parser2.bufferCheckPosition) {
          checkBufferLength(parser2);
        }
        return parser2;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports);
  })(sax);
  return sax;
}
var hasRequiredXml;
function requireXml() {
  if (hasRequiredXml) return xml;
  hasRequiredXml = 1;
  Object.defineProperty(xml, "__esModule", { value: true });
  xml.XElement = void 0;
  xml.parseXml = parseXml;
  const sax2 = requireSax();
  const error_1 = requireError();
  class XElement {
    constructor(name) {
      this.name = name;
      this.value = "";
      this.attributes = null;
      this.isCData = false;
      this.elements = null;
      if (!name) {
        throw (0, error_1.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
      }
      if (!isValidName(name)) {
        throw (0, error_1.newError)(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
      }
    }
    attribute(name) {
      const result = this.attributes === null ? null : this.attributes[name];
      if (result == null) {
        throw (0, error_1.newError)(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
      }
      return result;
    }
    removeAttribute(name) {
      if (this.attributes !== null) {
        delete this.attributes[name];
      }
    }
    element(name, ignoreCase = false, errorIfMissed = null) {
      const result = this.elementOrNull(name, ignoreCase);
      if (result === null) {
        throw (0, error_1.newError)(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
      }
      return result;
    }
    elementOrNull(name, ignoreCase = false) {
      if (this.elements === null) {
        return null;
      }
      for (const element of this.elements) {
        if (isNameEquals(element, name, ignoreCase)) {
          return element;
        }
      }
      return null;
    }
    getElements(name, ignoreCase = false) {
      if (this.elements === null) {
        return [];
      }
      return this.elements.filter((it) => isNameEquals(it, name, ignoreCase));
    }
    elementValueOrEmpty(name, ignoreCase = false) {
      const element = this.elementOrNull(name, ignoreCase);
      return element === null ? "" : element.value;
    }
  }
  xml.XElement = XElement;
  const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
  function isValidName(name) {
    return NAME_REG_EXP.test(name);
  }
  function isNameEquals(element, name, ignoreCase) {
    const elementName = element.name;
    return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
  }
  function parseXml(data) {
    let rootElement = null;
    const parser2 = sax2.parser(true, {});
    const elements = [];
    parser2.onopentag = (saxElement) => {
      const element = new XElement(saxElement.name);
      element.attributes = saxElement.attributes;
      if (rootElement === null) {
        rootElement = element;
      } else {
        const parent = elements[elements.length - 1];
        if (parent.elements == null) {
          parent.elements = [];
        }
        parent.elements.push(element);
      }
      elements.push(element);
    };
    parser2.onclosetag = () => {
      elements.pop();
    };
    parser2.ontext = (text) => {
      if (elements.length > 0) {
        elements[elements.length - 1].value = text;
      }
    };
    parser2.oncdata = (cdata) => {
      const element = elements[elements.length - 1];
      element.value = cdata;
      element.isCData = true;
    };
    parser2.onerror = (err) => {
      throw err;
    };
    parser2.write(data);
    return rootElement;
  }
  return xml;
}
var MemoLazy = {};
var hasRequiredMemoLazy;
function requireMemoLazy() {
  if (hasRequiredMemoLazy) return MemoLazy;
  hasRequiredMemoLazy = 1;
  Object.defineProperty(MemoLazy, "__esModule", { value: true });
  MemoLazy.MemoLazy = void 0;
  let MemoLazy$1 = class MemoLazy {
    constructor(selector, creator) {
      this.selector = selector;
      this.creator = creator;
      this.selected = void 0;
      this._value = void 0;
    }
    get hasValue() {
      return this._value !== void 0;
    }
    get value() {
      const selected = this.selector();
      if (this._value !== void 0 && equals(this.selected, selected)) {
        return this._value;
      }
      this.selected = selected;
      const result = this.creator(selected);
      this.value = result;
      return result;
    }
    set value(value) {
      this._value = value;
    }
  };
  MemoLazy.MemoLazy = MemoLazy$1;
  function equals(firstValue, secondValue) {
    const isFirstObject = typeof firstValue === "object" && firstValue !== null;
    const isSecondObject = typeof secondValue === "object" && secondValue !== null;
    if (isFirstObject && isSecondObject) {
      const keys1 = Object.keys(firstValue);
      const keys2 = Object.keys(secondValue);
      return keys1.length === keys2.length && keys1.every((key) => equals(firstValue[key], secondValue[key]));
    }
    return firstValue === secondValue;
  }
  return MemoLazy;
}
var retry = {};
var hasRequiredRetry;
function requireRetry() {
  if (hasRequiredRetry) return retry;
  hasRequiredRetry = 1;
  Object.defineProperty(retry, "__esModule", { value: true });
  retry.retry = retry$1;
  const CancellationToken_1 = requireCancellationToken();
  async function retry$1(task, retryCount, interval, backoff = 0, attempt = 0, shouldRetry) {
    var _a;
    const cancellationToken = new CancellationToken_1.CancellationToken();
    try {
      return await task();
    } catch (error2) {
      if (((_a = shouldRetry === null || shouldRetry === void 0 ? void 0 : shouldRetry(error2)) !== null && _a !== void 0 ? _a : true) && retryCount > 0 && !cancellationToken.cancelled) {
        await new Promise((resolve) => setTimeout(resolve, interval + backoff * attempt));
        return await retry$1(task, retryCount - 1, interval, backoff, attempt + 1, shouldRetry);
      } else {
        throw error2;
      }
    }
  }
  return retry;
}
var hasRequiredOut;
function requireOut() {
  if (hasRequiredOut) return out;
  hasRequiredOut = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CURRENT_APP_PACKAGE_FILE_NAME = exports.CURRENT_APP_INSTALLER_FILE_NAME = exports.retry = exports.MemoLazy = exports.newError = exports.XElement = exports.parseXml = exports.ProgressCallbackTransform = exports.UUID = exports.parseDn = exports.githubUrl = exports.getS3LikeProviderBaseUrl = exports.configureRequestUrl = exports.parseJson = exports.safeStringifyJson = exports.configureRequestOptionsFromUrl = exports.configureRequestOptions = exports.safeGetHeader = exports.DigestTransform = exports.HttpExecutor = exports.createHttpError = exports.HttpError = exports.CancellationError = exports.CancellationToken = void 0;
    exports.asArray = asArray;
    var CancellationToken_1 = requireCancellationToken();
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return CancellationToken_1.CancellationToken;
    } });
    Object.defineProperty(exports, "CancellationError", { enumerable: true, get: function() {
      return CancellationToken_1.CancellationError;
    } });
    var httpExecutor_1 = requireHttpExecutor();
    Object.defineProperty(exports, "HttpError", { enumerable: true, get: function() {
      return httpExecutor_1.HttpError;
    } });
    Object.defineProperty(exports, "createHttpError", { enumerable: true, get: function() {
      return httpExecutor_1.createHttpError;
    } });
    Object.defineProperty(exports, "HttpExecutor", { enumerable: true, get: function() {
      return httpExecutor_1.HttpExecutor;
    } });
    Object.defineProperty(exports, "DigestTransform", { enumerable: true, get: function() {
      return httpExecutor_1.DigestTransform;
    } });
    Object.defineProperty(exports, "safeGetHeader", { enumerable: true, get: function() {
      return httpExecutor_1.safeGetHeader;
    } });
    Object.defineProperty(exports, "configureRequestOptions", { enumerable: true, get: function() {
      return httpExecutor_1.configureRequestOptions;
    } });
    Object.defineProperty(exports, "configureRequestOptionsFromUrl", { enumerable: true, get: function() {
      return httpExecutor_1.configureRequestOptionsFromUrl;
    } });
    Object.defineProperty(exports, "safeStringifyJson", { enumerable: true, get: function() {
      return httpExecutor_1.safeStringifyJson;
    } });
    Object.defineProperty(exports, "parseJson", { enumerable: true, get: function() {
      return httpExecutor_1.parseJson;
    } });
    Object.defineProperty(exports, "configureRequestUrl", { enumerable: true, get: function() {
      return httpExecutor_1.configureRequestUrl;
    } });
    var publishOptions_1 = requirePublishOptions();
    Object.defineProperty(exports, "getS3LikeProviderBaseUrl", { enumerable: true, get: function() {
      return publishOptions_1.getS3LikeProviderBaseUrl;
    } });
    Object.defineProperty(exports, "githubUrl", { enumerable: true, get: function() {
      return publishOptions_1.githubUrl;
    } });
    var rfc2253Parser_1 = requireRfc2253Parser();
    Object.defineProperty(exports, "parseDn", { enumerable: true, get: function() {
      return rfc2253Parser_1.parseDn;
    } });
    var uuid_1 = requireUuid();
    Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
      return uuid_1.UUID;
    } });
    var ProgressCallbackTransform_1 = requireProgressCallbackTransform();
    Object.defineProperty(exports, "ProgressCallbackTransform", { enumerable: true, get: function() {
      return ProgressCallbackTransform_1.ProgressCallbackTransform;
    } });
    var xml_1 = requireXml();
    Object.defineProperty(exports, "parseXml", { enumerable: true, get: function() {
      return xml_1.parseXml;
    } });
    Object.defineProperty(exports, "XElement", { enumerable: true, get: function() {
      return xml_1.XElement;
    } });
    var error_1 = requireError();
    Object.defineProperty(exports, "newError", { enumerable: true, get: function() {
      return error_1.newError;
    } });
    var MemoLazy_1 = requireMemoLazy();
    Object.defineProperty(exports, "MemoLazy", { enumerable: true, get: function() {
      return MemoLazy_1.MemoLazy;
    } });
    var retry_1 = requireRetry();
    Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    exports.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe";
    exports.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
    function asArray(v) {
      if (v == null) {
        return [];
      } else if (Array.isArray(v)) {
        return v;
      } else {
        return [v];
      }
    }
  })(out);
  return out;
}
var fs = {};
var universalify = {};
var hasRequiredUniversalify;
function requireUniversalify() {
  if (hasRequiredUniversalify) return universalify;
  hasRequiredUniversalify = 1;
  universalify.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function") fn.apply(this, args);
      else {
        return new Promise((resolve, reject) => {
          args.push((err, res) => err != null ? reject(err) : resolve(res));
          fn.apply(this, args);
        });
      }
    }, "name", { value: fn.name });
  };
  universalify.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function") return fn.apply(this, args);
      else {
        args.pop();
        fn.apply(this, args).then((r) => cb(null, r), cb);
      }
    }, "name", { value: fn.name });
  };
  return universalify;
}
var polyfills;
var hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var constants2 = require$$0$5;
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
  }
  polyfills = patch;
  function patch(fs2) {
    if (constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs2);
    }
    if (!fs2.lutimes) {
      patchLutimes(fs2);
    }
    fs2.chown = chownFix(fs2.chown);
    fs2.fchown = chownFix(fs2.fchown);
    fs2.lchown = chownFix(fs2.lchown);
    fs2.chmod = chmodFix(fs2.chmod);
    fs2.fchmod = chmodFix(fs2.fchmod);
    fs2.lchmod = chmodFix(fs2.lchmod);
    fs2.chownSync = chownFixSync(fs2.chownSync);
    fs2.fchownSync = chownFixSync(fs2.fchownSync);
    fs2.lchownSync = chownFixSync(fs2.lchownSync);
    fs2.chmodSync = chmodFixSync(fs2.chmodSync);
    fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
    fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
    fs2.stat = statFix(fs2.stat);
    fs2.fstat = statFix(fs2.fstat);
    fs2.lstat = statFix(fs2.lstat);
    fs2.statSync = statFixSync(fs2.statSync);
    fs2.fstatSync = statFixSync(fs2.fstatSync);
    fs2.lstatSync = statFixSync(fs2.lstatSync);
    if (fs2.chmod && !fs2.lchmod) {
      fs2.lchmod = function(path, mode, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchmodSync = function() {
      };
    }
    if (fs2.chown && !fs2.lchown) {
      fs2.lchown = function(path, uid, gid, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs2.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb) cb(er);
          });
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs2.rename);
    }
    fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs2.read);
    fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs2, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs2.readSync);
    function patchLchmod(fs22) {
      fs22.lchmod = function(path, mode, callback) {
        fs22.open(
          path,
          constants2.O_WRONLY | constants2.O_SYMLINK,
          mode,
          function(err, fd) {
            if (err) {
              if (callback) callback(err);
              return;
            }
            fs22.fchmod(fd, mode, function(err2) {
              fs22.close(fd, function(err22) {
                if (callback) callback(err2 || err22);
              });
            });
          }
        );
      };
      fs22.lchmodSync = function(path, mode) {
        var fd = fs22.openSync(path, constants2.O_WRONLY | constants2.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs22.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs22.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs22.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs22) {
      if (constants2.hasOwnProperty("O_SYMLINK") && fs22.futimes) {
        fs22.lutimes = function(path, at, mt, cb) {
          fs22.open(path, constants2.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb) cb(er);
              return;
            }
            fs22.futimes(fd, at, mt, function(er2) {
              fs22.close(fd, function(er22) {
                if (cb) cb(er2 || er22);
              });
            });
          });
        };
        fs22.lutimesSync = function(path, at, mt) {
          var fd = fs22.openSync(path, constants2.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs22.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs22.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs22.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs22.futimes) {
        fs22.lutimes = function(_a, _b, _c, cb) {
          if (cb) process.nextTick(cb);
        };
        fs22.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig) return orig;
      return function(target, mode, cb) {
        return orig.call(fs2, target, mode, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig) return orig;
      return function(target, mode) {
        try {
          return orig.call(fs2, target, mode);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig) return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig) return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig) return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          if (cb) cb.apply(this, arguments);
        }
        return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig) return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
  return polyfills;
}
var legacyStreams;
var hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var Stream = require$$0$4.Stream;
  legacyStreams = legacy;
  function legacy(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream)) return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding) this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if ("number" !== typeof this.end) {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream)) return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs2.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
  return legacyStreams;
}
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1;
  clone_1 = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy2 = { __proto__: getPrototypeOf(obj) };
    else
      var copy2 = /* @__PURE__ */ Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy2;
  }
  return clone_1;
}
var gracefulFs;
var hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var fs2 = require$$1$2;
  var polyfills2 = requirePolyfills();
  var legacy = requireLegacyStreams();
  var clone = requireClone();
  var util2 = require$$1$6;
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util2.debuglog)
    debug = util2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util2.format.apply(util2, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    };
  if (!fs2[gracefulQueue]) {
    var queue = commonjsGlobal[gracefulQueue] || [];
    publishQueue(fs2, queue);
    fs2.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs2.close);
    fs2.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs2.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs2[gracefulQueue]);
        require$$5$1.equal(fs2[gracefulQueue].length, 0);
      });
    }
  }
  if (!commonjsGlobal[gracefulQueue]) {
    publishQueue(commonjsGlobal, fs2[gracefulQueue]);
  }
  gracefulFs = patch(clone(fs2));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
    gracefulFs = patch(fs2);
    fs2.__patched = true;
  }
  function patch(fs22) {
    polyfills2(fs22);
    fs22.gracefulify = patch;
    fs22.createReadStream = createReadStream;
    fs22.createWriteStream = createWriteStream;
    var fs$readFile = fs22.readFile;
    fs22.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2, startTime) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs22.writeFile;
    fs22.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2, startTime) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs22.appendFile;
    if (fs$appendFile)
      fs22.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2, startTime) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs22.copyFile;
    if (fs$copyFile)
      fs22.copyFile = copyFile;
    function copyFile(src2, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src2, dest, flags, cb);
      function go$copyFile(src22, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src22, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src22, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs22.readdir;
    fs22.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
        return fs$readdir(path2, fs$readdirCallback(
          path2,
          options2,
          cb2,
          startTime
        ));
      } : function go$readdir2(path2, options2, cb2, startTime) {
        return fs$readdir(path2, options2, fs$readdirCallback(
          path2,
          options2,
          cb2,
          startTime
        ));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path2, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path2, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs22);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs22.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs22.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs22, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs22, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs22, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs22, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs22.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs22.WriteStream(path, options);
    }
    var fs$open = fs22.open;
    fs22.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2, startTime) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs22;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs2[gracefulQueue].push(elem);
    retry2();
  }
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
      if (fs2[gracefulQueue][i].length > 2) {
        fs2[gracefulQueue][i][3] = now;
        fs2[gracefulQueue][i][4] = now;
      }
    }
    retry2();
  }
  function retry2() {
    clearTimeout(retryTimer);
    retryTimer = void 0;
    if (fs2[gracefulQueue].length === 0)
      return;
    var elem = fs2[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === void 0) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 6e4) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs2[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === void 0) {
      retryTimer = setTimeout(retry2, 0);
    }
  }
  return gracefulFs;
}
var hasRequiredFs;
function requireFs() {
  if (hasRequiredFs) return fs;
  hasRequiredFs = 1;
  (function(exports) {
    const u = requireUniversalify().fromCallback;
    const fs2 = requireGracefulFs();
    const api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs2[key] === "function";
    });
    Object.assign(exports, fs2);
    api.forEach((method) => {
      exports[method] = u(fs2[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs2.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs2.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs2.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs2.writev === "function") {
      exports.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs2.writev(fd, buffers, ...args);
        }
        return new Promise((resolve, reject) => {
          fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err) return reject(err);
            resolve({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
    if (typeof fs2.realpath.native === "function") {
      exports.realpath.native = u(fs2.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  })(fs);
  return fs;
}
var makeDir = {};
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  const path = require$$1$1;
  utils$1.checkPath = function checkPath(pth) {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error2 = new Error(`Path contains invalid characters: ${pth}`);
        error2.code = "EINVAL";
        throw error2;
      }
    }
  };
  return utils$1;
}
var hasRequiredMakeDir;
function requireMakeDir() {
  if (hasRequiredMakeDir) return makeDir;
  hasRequiredMakeDir = 1;
  const fs2 = /* @__PURE__ */ requireFs();
  const { checkPath } = /* @__PURE__ */ requireUtils$1();
  const getMode = (options) => {
    const defaults = { mode: 511 };
    if (typeof options === "number") return options;
    return { ...defaults, ...options }.mode;
  };
  makeDir.makeDir = async (dir, options) => {
    checkPath(dir);
    return fs2.mkdir(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  makeDir.makeDirSync = (dir, options) => {
    checkPath(dir);
    return fs2.mkdirSync(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  return makeDir;
}
var mkdirs;
var hasRequiredMkdirs;
function requireMkdirs() {
  if (hasRequiredMkdirs) return mkdirs;
  hasRequiredMkdirs = 1;
  const u = requireUniversalify().fromPromise;
  const { makeDir: _makeDir, makeDirSync } = /* @__PURE__ */ requireMakeDir();
  const makeDir2 = u(_makeDir);
  mkdirs = {
    mkdirs: makeDir2,
    mkdirsSync: makeDirSync,
    // alias
    mkdirp: makeDir2,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir2,
    ensureDirSync: makeDirSync
  };
  return mkdirs;
}
var pathExists_1;
var hasRequiredPathExists;
function requirePathExists() {
  if (hasRequiredPathExists) return pathExists_1;
  hasRequiredPathExists = 1;
  const u = requireUniversalify().fromPromise;
  const fs2 = /* @__PURE__ */ requireFs();
  function pathExists(path) {
    return fs2.access(path).then(() => true).catch(() => false);
  }
  pathExists_1 = {
    pathExists: u(pathExists),
    pathExistsSync: fs2.existsSync
  };
  return pathExists_1;
}
var utimes;
var hasRequiredUtimes;
function requireUtimes() {
  if (hasRequiredUtimes) return utimes;
  hasRequiredUtimes = 1;
  const fs2 = requireGracefulFs();
  function utimesMillis(path, atime, mtime, callback) {
    fs2.open(path, "r+", (err, fd) => {
      if (err) return callback(err);
      fs2.futimes(fd, atime, mtime, (futimesErr) => {
        fs2.close(fd, (closeErr) => {
          if (callback) callback(futimesErr || closeErr);
        });
      });
    });
  }
  function utimesMillisSync(path, atime, mtime) {
    const fd = fs2.openSync(path, "r+");
    fs2.futimesSync(fd, atime, mtime);
    return fs2.closeSync(fd);
  }
  utimes = {
    utimesMillis,
    utimesMillisSync
  };
  return utimes;
}
var stat;
var hasRequiredStat;
function requireStat() {
  if (hasRequiredStat) return stat;
  hasRequiredStat = 1;
  const fs2 = /* @__PURE__ */ requireFs();
  const path = require$$1$1;
  const util2 = require$$1$6;
  function getStats(src2, dest, opts) {
    const statFunc = opts.dereference ? (file2) => fs2.stat(file2, { bigint: true }) : (file2) => fs2.lstat(file2, { bigint: true });
    return Promise.all([
      statFunc(src2),
      statFunc(dest).catch((err) => {
        if (err.code === "ENOENT") return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
  }
  function getStatsSync(src2, dest, opts) {
    let destStat;
    const statFunc = opts.dereference ? (file2) => fs2.statSync(file2, { bigint: true }) : (file2) => fs2.lstatSync(file2, { bigint: true });
    const srcStat = statFunc(src2);
    try {
      destStat = statFunc(dest);
    } catch (err) {
      if (err.code === "ENOENT") return { srcStat, destStat: null };
      throw err;
    }
    return { srcStat, destStat };
  }
  function checkPaths(src2, dest, funcName, opts, cb) {
    util2.callbackify(getStats)(src2, dest, opts, (err, stats) => {
      if (err) return cb(err);
      const { srcStat, destStat } = stats;
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path.basename(src2);
          const destBaseName = path.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return cb(null, { srcStat, destStat, isChangingCase: true });
          }
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`));
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`));
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
        return cb(new Error(errMsg(src2, dest, funcName)));
      }
      return cb(null, { srcStat, destStat });
    });
  }
  function checkPathsSync(src2, dest, funcName, opts) {
    const { srcStat, destStat } = getStatsSync(src2, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src2);
        const destBaseName = path.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return { srcStat, destStat, isChangingCase: true };
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
      throw new Error(errMsg(src2, dest, funcName));
    }
    return { srcStat, destStat };
  }
  function checkParentPaths(src2, srcStat, dest, funcName, cb) {
    const srcParent = path.resolve(path.dirname(src2));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();
    fs2.stat(destParent, { bigint: true }, (err, destStat) => {
      if (err) {
        if (err.code === "ENOENT") return cb();
        return cb(err);
      }
      if (areIdentical(srcStat, destStat)) {
        return cb(new Error(errMsg(src2, dest, funcName)));
      }
      return checkParentPaths(src2, srcStat, destParent, funcName, cb);
    });
  }
  function checkParentPathsSync(src2, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src2));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return;
    let destStat;
    try {
      destStat = fs2.statSync(destParent, { bigint: true });
    } catch (err) {
      if (err.code === "ENOENT") return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src2, dest, funcName));
    }
    return checkParentPathsSync(src2, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  }
  function isSrcSubdir(src2, dest) {
    const srcArr = path.resolve(src2).split(path.sep).filter((i) => i);
    const destArr = path.resolve(dest).split(path.sep).filter((i) => i);
    return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
  }
  function errMsg(src2, dest, funcName) {
    return `Cannot ${funcName} '${src2}' to a subdirectory of itself, '${dest}'.`;
  }
  stat = {
    checkPaths,
    checkPathsSync,
    checkParentPaths,
    checkParentPathsSync,
    isSrcSubdir,
    areIdentical
  };
  return stat;
}
var copy_1;
var hasRequiredCopy$1;
function requireCopy$1() {
  if (hasRequiredCopy$1) return copy_1;
  hasRequiredCopy$1 = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$1;
  const mkdirs2 = requireMkdirs().mkdirs;
  const pathExists = requirePathExists().pathExists;
  const utimesMillis = requireUtimes().utimesMillis;
  const stat2 = /* @__PURE__ */ requireStat();
  function copy2(src2, dest, opts, cb) {
    if (typeof opts === "function" && !cb) {
      cb = opts;
      opts = {};
    } else if (typeof opts === "function") {
      opts = { filter: opts };
    }
    cb = cb || function() {
    };
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(
        "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
        "Warning",
        "fs-extra-WARN0001"
      );
    }
    stat2.checkPaths(src2, dest, "copy", opts, (err, stats) => {
      if (err) return cb(err);
      const { srcStat, destStat } = stats;
      stat2.checkParentPaths(src2, srcStat, dest, "copy", (err2) => {
        if (err2) return cb(err2);
        if (opts.filter) return handleFilter(checkParentDir, destStat, src2, dest, opts, cb);
        return checkParentDir(destStat, src2, dest, opts, cb);
      });
    });
  }
  function checkParentDir(destStat, src2, dest, opts, cb) {
    const destParent = path.dirname(dest);
    pathExists(destParent, (err, dirExists) => {
      if (err) return cb(err);
      if (dirExists) return getStats(destStat, src2, dest, opts, cb);
      mkdirs2(destParent, (err2) => {
        if (err2) return cb(err2);
        return getStats(destStat, src2, dest, opts, cb);
      });
    });
  }
  function handleFilter(onInclude, destStat, src2, dest, opts, cb) {
    Promise.resolve(opts.filter(src2, dest)).then((include) => {
      if (include) return onInclude(destStat, src2, dest, opts, cb);
      return cb();
    }, (error2) => cb(error2));
  }
  function startCopy(destStat, src2, dest, opts, cb) {
    if (opts.filter) return handleFilter(getStats, destStat, src2, dest, opts, cb);
    return getStats(destStat, src2, dest, opts, cb);
  }
  function getStats(destStat, src2, dest, opts, cb) {
    const stat3 = opts.dereference ? fs2.stat : fs2.lstat;
    stat3(src2, (err, srcStat) => {
      if (err) return cb(err);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src2, dest, opts, cb);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src2, dest, opts, cb);
      else if (srcStat.isSymbolicLink()) return onLink(destStat, src2, dest, opts, cb);
      else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src2}`));
      else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src2}`));
      return cb(new Error(`Unknown file: ${src2}`));
    });
  }
  function onFile(srcStat, destStat, src2, dest, opts, cb) {
    if (!destStat) return copyFile(srcStat, src2, dest, opts, cb);
    return mayCopyFile(srcStat, src2, dest, opts, cb);
  }
  function mayCopyFile(srcStat, src2, dest, opts, cb) {
    if (opts.overwrite) {
      fs2.unlink(dest, (err) => {
        if (err) return cb(err);
        return copyFile(srcStat, src2, dest, opts, cb);
      });
    } else if (opts.errorOnExist) {
      return cb(new Error(`'${dest}' already exists`));
    } else return cb();
  }
  function copyFile(srcStat, src2, dest, opts, cb) {
    fs2.copyFile(src2, dest, (err) => {
      if (err) return cb(err);
      if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src2, dest, cb);
      return setDestMode(dest, srcStat.mode, cb);
    });
  }
  function handleTimestampsAndMode(srcMode, src2, dest, cb) {
    if (fileIsNotWritable(srcMode)) {
      return makeFileWritable(dest, srcMode, (err) => {
        if (err) return cb(err);
        return setDestTimestampsAndMode(srcMode, src2, dest, cb);
      });
    }
    return setDestTimestampsAndMode(srcMode, src2, dest, cb);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode, cb) {
    return setDestMode(dest, srcMode | 128, cb);
  }
  function setDestTimestampsAndMode(srcMode, src2, dest, cb) {
    setDestTimestamps(src2, dest, (err) => {
      if (err) return cb(err);
      return setDestMode(dest, srcMode, cb);
    });
  }
  function setDestMode(dest, srcMode, cb) {
    return fs2.chmod(dest, srcMode, cb);
  }
  function setDestTimestamps(src2, dest, cb) {
    fs2.stat(src2, (err, updatedSrcStat) => {
      if (err) return cb(err);
      return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
    });
  }
  function onDir(srcStat, destStat, src2, dest, opts, cb) {
    if (!destStat) return mkDirAndCopy(srcStat.mode, src2, dest, opts, cb);
    return copyDir(src2, dest, opts, cb);
  }
  function mkDirAndCopy(srcMode, src2, dest, opts, cb) {
    fs2.mkdir(dest, (err) => {
      if (err) return cb(err);
      copyDir(src2, dest, opts, (err2) => {
        if (err2) return cb(err2);
        return setDestMode(dest, srcMode, cb);
      });
    });
  }
  function copyDir(src2, dest, opts, cb) {
    fs2.readdir(src2, (err, items) => {
      if (err) return cb(err);
      return copyDirItems(items, src2, dest, opts, cb);
    });
  }
  function copyDirItems(items, src2, dest, opts, cb) {
    const item = items.pop();
    if (!item) return cb();
    return copyDirItem(items, item, src2, dest, opts, cb);
  }
  function copyDirItem(items, item, src2, dest, opts, cb) {
    const srcItem = path.join(src2, item);
    const destItem = path.join(dest, item);
    stat2.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
      if (err) return cb(err);
      const { destStat } = stats;
      startCopy(destStat, srcItem, destItem, opts, (err2) => {
        if (err2) return cb(err2);
        return copyDirItems(items, src2, dest, opts, cb);
      });
    });
  }
  function onLink(destStat, src2, dest, opts, cb) {
    fs2.readlink(src2, (err, resolvedSrc) => {
      if (err) return cb(err);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs2.symlink(resolvedSrc, dest, cb);
      } else {
        fs2.readlink(dest, (err2, resolvedDest) => {
          if (err2) {
            if (err2.code === "EINVAL" || err2.code === "UNKNOWN") return fs2.symlink(resolvedSrc, dest, cb);
            return cb(err2);
          }
          if (opts.dereference) {
            resolvedDest = path.resolve(process.cwd(), resolvedDest);
          }
          if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
            return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
          }
          if (destStat.isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
            return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
          }
          return copyLink(resolvedSrc, dest, cb);
        });
      }
    });
  }
  function copyLink(resolvedSrc, dest, cb) {
    fs2.unlink(dest, (err) => {
      if (err) return cb(err);
      return fs2.symlink(resolvedSrc, dest, cb);
    });
  }
  copy_1 = copy2;
  return copy_1;
}
var copySync_1;
var hasRequiredCopySync;
function requireCopySync() {
  if (hasRequiredCopySync) return copySync_1;
  hasRequiredCopySync = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$1;
  const mkdirsSync = requireMkdirs().mkdirsSync;
  const utimesMillisSync = requireUtimes().utimesMillisSync;
  const stat2 = /* @__PURE__ */ requireStat();
  function copySync(src2, dest, opts) {
    if (typeof opts === "function") {
      opts = { filter: opts };
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      process.emitWarning(
        "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
        "Warning",
        "fs-extra-WARN0002"
      );
    }
    const { srcStat, destStat } = stat2.checkPathsSync(src2, dest, "copy", opts);
    stat2.checkParentPathsSync(src2, srcStat, dest, "copy");
    return handleFilterAndCopy(destStat, src2, dest, opts);
  }
  function handleFilterAndCopy(destStat, src2, dest, opts) {
    if (opts.filter && !opts.filter(src2, dest)) return;
    const destParent = path.dirname(dest);
    if (!fs2.existsSync(destParent)) mkdirsSync(destParent);
    return getStats(destStat, src2, dest, opts);
  }
  function startCopy(destStat, src2, dest, opts) {
    if (opts.filter && !opts.filter(src2, dest)) return;
    return getStats(destStat, src2, dest, opts);
  }
  function getStats(destStat, src2, dest, opts) {
    const statSync = opts.dereference ? fs2.statSync : fs2.lstatSync;
    const srcStat = statSync(src2);
    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src2, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src2, dest, opts);
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src2, dest, opts);
    else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src2}`);
    else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src2}`);
    throw new Error(`Unknown file: ${src2}`);
  }
  function onFile(srcStat, destStat, src2, dest, opts) {
    if (!destStat) return copyFile(srcStat, src2, dest, opts);
    return mayCopyFile(srcStat, src2, dest, opts);
  }
  function mayCopyFile(srcStat, src2, dest, opts) {
    if (opts.overwrite) {
      fs2.unlinkSync(dest);
      return copyFile(srcStat, src2, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src2, dest, opts) {
    fs2.copyFileSync(src2, dest);
    if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src2, dest);
    return setDestMode(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src2, dest) {
    if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
    return setDestTimestamps(src2, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  }
  function setDestMode(dest, srcMode) {
    return fs2.chmodSync(dest, srcMode);
  }
  function setDestTimestamps(src2, dest) {
    const updatedSrcStat = fs2.statSync(src2);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src2, dest, opts) {
    if (!destStat) return mkDirAndCopy(srcStat.mode, src2, dest, opts);
    return copyDir(src2, dest, opts);
  }
  function mkDirAndCopy(srcMode, src2, dest, opts) {
    fs2.mkdirSync(dest);
    copyDir(src2, dest, opts);
    return setDestMode(dest, srcMode);
  }
  function copyDir(src2, dest, opts) {
    fs2.readdirSync(src2).forEach((item) => copyDirItem(item, src2, dest, opts));
  }
  function copyDirItem(item, src2, dest, opts) {
    const srcItem = path.join(src2, item);
    const destItem = path.join(dest, item);
    const { destStat } = stat2.checkPathsSync(srcItem, destItem, "copy", opts);
    return startCopy(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src2, dest, opts) {
    let resolvedSrc = fs2.readlinkSync(src2);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs2.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs2.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs2.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (fs2.statSync(dest).isDirectory() && stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs2.unlinkSync(dest);
    return fs2.symlinkSync(resolvedSrc, dest);
  }
  copySync_1 = copySync;
  return copySync_1;
}
var copy;
var hasRequiredCopy;
function requireCopy() {
  if (hasRequiredCopy) return copy;
  hasRequiredCopy = 1;
  const u = requireUniversalify().fromCallback;
  copy = {
    copy: u(/* @__PURE__ */ requireCopy$1()),
    copySync: /* @__PURE__ */ requireCopySync()
  };
  return copy;
}
var rimraf_1;
var hasRequiredRimraf;
function requireRimraf() {
  if (hasRequiredRimraf) return rimraf_1;
  hasRequiredRimraf = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$1;
  const assert = require$$5$1;
  const isWindows = process.platform === "win32";
  function defaults(options) {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m) => {
      options[m] = options[m] || fs2[m];
      m = m + "Sync";
      options[m] = options[m] || fs2[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
  }
  function rimraf(p, options, cb) {
    let busyTries = 0;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    rimraf_(p, options, function CB(er) {
      if (er) {
        if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
          busyTries++;
          const time = busyTries * 100;
          return setTimeout(() => rimraf_(p, options, CB), time);
        }
        if (er.code === "ENOENT") er = null;
      }
      cb(er);
    });
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT") {
        return cb(null);
      }
      if (er && er.code === "EPERM" && isWindows) {
        return fixWinEPERM(p, options, er, cb);
      }
      if (st && st.isDirectory()) {
        return rmdir(p, options, er, cb);
      }
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT") {
            return cb(null);
          }
          if (er2.code === "EPERM") {
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          }
          if (er2.code === "EISDIR") {
            return rmdir(p, options, er2, cb);
          }
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2) {
        cb(er2.code === "ENOENT" ? null : er);
      } else {
        options.stat(p, (er3, stats) => {
          if (er3) {
            cb(er3.code === "ENOENT" ? null : er);
          } else if (stats.isDirectory()) {
            rmdir(p, options, er, cb);
          } else {
            options.unlink(p, cb);
          }
        });
      }
    });
  }
  function fixWinEPERMSync(p, options, er) {
    let stats;
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    if (stats.isDirectory()) {
      rmdirSync(p, options, er);
    } else {
      options.unlinkSync(p);
    }
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
        rmkids(p, options, cb);
      } else if (er && er.code === "ENOTDIR") {
        cb(originalEr);
      } else {
        cb(er);
      }
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er) return cb(er);
      let n = files.length;
      let errState;
      if (n === 0) return options.rmdir(p, cb);
      files.forEach((f) => {
        rimraf(path.join(p, f), options, (er2) => {
          if (errState) {
            return;
          }
          if (er2) return cb(errState = er2);
          if (--n === 0) {
            options.rmdir(p, cb);
          }
        });
      });
    });
  }
  function rimrafSync(p, options) {
    let st;
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    try {
      st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      }
      if (er.code === "EPERM" && isWindows) {
        fixWinEPERMSync(p, options, er);
      }
    }
    try {
      if (st && st.isDirectory()) {
        rmdirSync(p, options, null);
      } else {
        options.unlinkSync(p);
      }
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      } else if (er.code === "EPERM") {
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
      } else if (er.code !== "EISDIR") {
        throw er;
      }
      rmdirSync(p, options, er);
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOTDIR") {
        throw originalEr;
      } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
        rmkidsSync(p, options);
      } else if (er.code !== "ENOENT") {
        throw er;
      }
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
    if (isWindows) {
      const startTime = Date.now();
      do {
        try {
          const ret = options.rmdirSync(p, options);
          return ret;
        } catch {
        }
      } while (Date.now() - startTime < 500);
    } else {
      const ret = options.rmdirSync(p, options);
      return ret;
    }
  }
  rimraf_1 = rimraf;
  rimraf.sync = rimrafSync;
  return rimraf_1;
}
var remove_1;
var hasRequiredRemove;
function requireRemove() {
  if (hasRequiredRemove) return remove_1;
  hasRequiredRemove = 1;
  const fs2 = requireGracefulFs();
  const u = requireUniversalify().fromCallback;
  const rimraf = /* @__PURE__ */ requireRimraf();
  function remove(path, callback) {
    if (fs2.rm) return fs2.rm(path, { recursive: true, force: true }, callback);
    rimraf(path, callback);
  }
  function removeSync(path) {
    if (fs2.rmSync) return fs2.rmSync(path, { recursive: true, force: true });
    rimraf.sync(path);
  }
  remove_1 = {
    remove: u(remove),
    removeSync
  };
  return remove_1;
}
var empty;
var hasRequiredEmpty;
function requireEmpty() {
  if (hasRequiredEmpty) return empty;
  hasRequiredEmpty = 1;
  const u = requireUniversalify().fromPromise;
  const fs2 = /* @__PURE__ */ requireFs();
  const path = require$$1$1;
  const mkdir = /* @__PURE__ */ requireMkdirs();
  const remove = /* @__PURE__ */ requireRemove();
  const emptyDir = u(async function emptyDir2(dir) {
    let items;
    try {
      items = await fs2.readdir(dir);
    } catch {
      return mkdir.mkdirs(dir);
    }
    return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs2.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path.join(dir, item);
      remove.removeSync(item);
    });
  }
  empty = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
  return empty;
}
var file$1;
var hasRequiredFile$2;
function requireFile$2() {
  if (hasRequiredFile$2) return file$1;
  hasRequiredFile$2 = 1;
  const u = requireUniversalify().fromCallback;
  const path = require$$1$1;
  const fs2 = requireGracefulFs();
  const mkdir = /* @__PURE__ */ requireMkdirs();
  function createFile(file2, callback) {
    function makeFile() {
      fs2.writeFile(file2, "", (err) => {
        if (err) return callback(err);
        callback();
      });
    }
    fs2.stat(file2, (err, stats) => {
      if (!err && stats.isFile()) return callback();
      const dir = path.dirname(file2);
      fs2.stat(dir, (err2, stats2) => {
        if (err2) {
          if (err2.code === "ENOENT") {
            return mkdir.mkdirs(dir, (err3) => {
              if (err3) return callback(err3);
              makeFile();
            });
          }
          return callback(err2);
        }
        if (stats2.isDirectory()) makeFile();
        else {
          fs2.readdir(dir, (err3) => {
            if (err3) return callback(err3);
          });
        }
      });
    });
  }
  function createFileSync(file2) {
    let stats;
    try {
      stats = fs2.statSync(file2);
    } catch {
    }
    if (stats && stats.isFile()) return;
    const dir = path.dirname(file2);
    try {
      if (!fs2.statSync(dir).isDirectory()) {
        fs2.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT") mkdir.mkdirsSync(dir);
      else throw err;
    }
    fs2.writeFileSync(file2, "");
  }
  file$1 = {
    createFile: u(createFile),
    createFileSync
  };
  return file$1;
}
var link;
var hasRequiredLink;
function requireLink() {
  if (hasRequiredLink) return link;
  hasRequiredLink = 1;
  const u = requireUniversalify().fromCallback;
  const path = require$$1$1;
  const fs2 = requireGracefulFs();
  const mkdir = /* @__PURE__ */ requireMkdirs();
  const pathExists = requirePathExists().pathExists;
  const { areIdentical } = /* @__PURE__ */ requireStat();
  function createLink(srcpath, dstpath, callback) {
    function makeLink(srcpath2, dstpath2) {
      fs2.link(srcpath2, dstpath2, (err) => {
        if (err) return callback(err);
        callback(null);
      });
    }
    fs2.lstat(dstpath, (_, dstStat) => {
      fs2.lstat(srcpath, (err, srcStat) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureLink");
          return callback(err);
        }
        if (dstStat && areIdentical(srcStat, dstStat)) return callback(null);
        const dir = path.dirname(dstpath);
        pathExists(dir, (err2, dirExists) => {
          if (err2) return callback(err2);
          if (dirExists) return makeLink(srcpath, dstpath);
          mkdir.mkdirs(dir, (err3) => {
            if (err3) return callback(err3);
            makeLink(srcpath, dstpath);
          });
        });
      });
    });
  }
  function createLinkSync(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = fs2.lstatSync(dstpath);
    } catch {
    }
    try {
      const srcStat = fs2.lstatSync(srcpath);
      if (dstStat && areIdentical(srcStat, dstStat)) return;
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path.dirname(dstpath);
    const dirExists = fs2.existsSync(dir);
    if (dirExists) return fs2.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs2.linkSync(srcpath, dstpath);
  }
  link = {
    createLink: u(createLink),
    createLinkSync
  };
  return link;
}
var symlinkPaths_1;
var hasRequiredSymlinkPaths;
function requireSymlinkPaths() {
  if (hasRequiredSymlinkPaths) return symlinkPaths_1;
  hasRequiredSymlinkPaths = 1;
  const path = require$$1$1;
  const fs2 = requireGracefulFs();
  const pathExists = requirePathExists().pathExists;
  function symlinkPaths(srcpath, dstpath, callback) {
    if (path.isAbsolute(srcpath)) {
      return fs2.lstat(srcpath, (err) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          return callback(err);
        }
        return callback(null, {
          toCwd: srcpath,
          toDst: srcpath
        });
      });
    } else {
      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);
      return pathExists(relativeToDst, (err, exists) => {
        if (err) return callback(err);
        if (exists) {
          return callback(null, {
            toCwd: relativeToDst,
            toDst: srcpath
          });
        } else {
          return fs2.lstat(srcpath, (err2) => {
            if (err2) {
              err2.message = err2.message.replace("lstat", "ensureSymlink");
              return callback(err2);
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: path.relative(dstdir, srcpath)
            });
          });
        }
      });
    }
  }
  function symlinkPathsSync(srcpath, dstpath) {
    let exists;
    if (path.isAbsolute(srcpath)) {
      exists = fs2.existsSync(srcpath);
      if (!exists) throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    } else {
      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);
      exists = fs2.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      } else {
        exists = fs2.existsSync(srcpath);
        if (!exists) throw new Error("relative srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: path.relative(dstdir, srcpath)
        };
      }
    }
  }
  symlinkPaths_1 = {
    symlinkPaths,
    symlinkPathsSync
  };
  return symlinkPaths_1;
}
var symlinkType_1;
var hasRequiredSymlinkType;
function requireSymlinkType() {
  if (hasRequiredSymlinkType) return symlinkType_1;
  hasRequiredSymlinkType = 1;
  const fs2 = requireGracefulFs();
  function symlinkType(srcpath, type2, callback) {
    callback = typeof type2 === "function" ? type2 : callback;
    type2 = typeof type2 === "function" ? false : type2;
    if (type2) return callback(null, type2);
    fs2.lstat(srcpath, (err, stats) => {
      if (err) return callback(null, "file");
      type2 = stats && stats.isDirectory() ? "dir" : "file";
      callback(null, type2);
    });
  }
  function symlinkTypeSync(srcpath, type2) {
    let stats;
    if (type2) return type2;
    try {
      stats = fs2.lstatSync(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  symlinkType_1 = {
    symlinkType,
    symlinkTypeSync
  };
  return symlinkType_1;
}
var symlink;
var hasRequiredSymlink;
function requireSymlink() {
  if (hasRequiredSymlink) return symlink;
  hasRequiredSymlink = 1;
  const u = requireUniversalify().fromCallback;
  const path = require$$1$1;
  const fs2 = /* @__PURE__ */ requireFs();
  const _mkdirs = /* @__PURE__ */ requireMkdirs();
  const mkdirs2 = _mkdirs.mkdirs;
  const mkdirsSync = _mkdirs.mkdirsSync;
  const _symlinkPaths = /* @__PURE__ */ requireSymlinkPaths();
  const symlinkPaths = _symlinkPaths.symlinkPaths;
  const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
  const _symlinkType = /* @__PURE__ */ requireSymlinkType();
  const symlinkType = _symlinkType.symlinkType;
  const symlinkTypeSync = _symlinkType.symlinkTypeSync;
  const pathExists = requirePathExists().pathExists;
  const { areIdentical } = /* @__PURE__ */ requireStat();
  function createSymlink(srcpath, dstpath, type2, callback) {
    callback = typeof type2 === "function" ? type2 : callback;
    type2 = typeof type2 === "function" ? false : type2;
    fs2.lstat(dstpath, (err, stats) => {
      if (!err && stats.isSymbolicLink()) {
        Promise.all([
          fs2.stat(srcpath),
          fs2.stat(dstpath)
        ]).then(([srcStat, dstStat]) => {
          if (areIdentical(srcStat, dstStat)) return callback(null);
          _createSymlink(srcpath, dstpath, type2, callback);
        });
      } else _createSymlink(srcpath, dstpath, type2, callback);
    });
  }
  function _createSymlink(srcpath, dstpath, type2, callback) {
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err);
      srcpath = relative.toDst;
      symlinkType(relative.toCwd, type2, (err2, type3) => {
        if (err2) return callback(err2);
        const dir = path.dirname(dstpath);
        pathExists(dir, (err3, dirExists) => {
          if (err3) return callback(err3);
          if (dirExists) return fs2.symlink(srcpath, dstpath, type3, callback);
          mkdirs2(dir, (err4) => {
            if (err4) return callback(err4);
            fs2.symlink(srcpath, dstpath, type3, callback);
          });
        });
      });
    });
  }
  function createSymlinkSync(srcpath, dstpath, type2) {
    let stats;
    try {
      stats = fs2.lstatSync(dstpath);
    } catch {
    }
    if (stats && stats.isSymbolicLink()) {
      const srcStat = fs2.statSync(srcpath);
      const dstStat = fs2.statSync(dstpath);
      if (areIdentical(srcStat, dstStat)) return;
    }
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type2 = symlinkTypeSync(relative.toCwd, type2);
    const dir = path.dirname(dstpath);
    const exists = fs2.existsSync(dir);
    if (exists) return fs2.symlinkSync(srcpath, dstpath, type2);
    mkdirsSync(dir);
    return fs2.symlinkSync(srcpath, dstpath, type2);
  }
  symlink = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
  return symlink;
}
var ensure;
var hasRequiredEnsure;
function requireEnsure() {
  if (hasRequiredEnsure) return ensure;
  hasRequiredEnsure = 1;
  const { createFile, createFileSync } = /* @__PURE__ */ requireFile$2();
  const { createLink, createLinkSync } = /* @__PURE__ */ requireLink();
  const { createSymlink, createSymlinkSync } = /* @__PURE__ */ requireSymlink();
  ensure = {
    // file
    createFile,
    createFileSync,
    ensureFile: createFile,
    ensureFileSync: createFileSync,
    // link
    createLink,
    createLinkSync,
    ensureLink: createLink,
    ensureLinkSync: createLinkSync,
    // symlink
    createSymlink,
    createSymlinkSync,
    ensureSymlink: createSymlink,
    ensureSymlinkSync: createSymlinkSync
  };
  return ensure;
}
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
    const EOF = finalEOL ? EOL : "";
    const str2 = JSON.stringify(obj, replacer, spaces);
    return str2.replace(/\n/g, EOL) + EOF;
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content)) content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  }
  utils = { stringify, stripBom };
  return utils;
}
var jsonfile_1;
var hasRequiredJsonfile$1;
function requireJsonfile$1() {
  if (hasRequiredJsonfile$1) return jsonfile_1;
  hasRequiredJsonfile$1 = 1;
  let _fs;
  try {
    _fs = requireGracefulFs();
  } catch (_) {
    _fs = require$$1$2;
  }
  const universalify2 = requireUniversalify();
  const { stringify, stripBom } = requireUtils();
  async function _readFile(file2, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs2 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    let data = await universalify2.fromCallback(fs2.readFile)(file2, options);
    data = stripBom(data);
    let obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file2}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj;
  }
  const readFile = universalify2.fromPromise(_readFile);
  function readFileSync(file2, options = {}) {
    if (typeof options === "string") {
      options = { encoding: options };
    }
    const fs2 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs2.readFileSync(file2, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file2}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  async function _writeFile(file2, obj, options = {}) {
    const fs2 = options.fs || _fs;
    const str2 = stringify(obj, options);
    await universalify2.fromCallback(fs2.writeFile)(file2, str2, options);
  }
  const writeFile = universalify2.fromPromise(_writeFile);
  function writeFileSync(file2, obj, options = {}) {
    const fs2 = options.fs || _fs;
    const str2 = stringify(obj, options);
    return fs2.writeFileSync(file2, str2, options);
  }
  const jsonfile2 = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  jsonfile_1 = jsonfile2;
  return jsonfile_1;
}
var jsonfile;
var hasRequiredJsonfile;
function requireJsonfile() {
  if (hasRequiredJsonfile) return jsonfile;
  hasRequiredJsonfile = 1;
  const jsonFile = requireJsonfile$1();
  jsonfile = {
    // jsonfile exports
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
  return jsonfile;
}
var outputFile_1;
var hasRequiredOutputFile;
function requireOutputFile() {
  if (hasRequiredOutputFile) return outputFile_1;
  hasRequiredOutputFile = 1;
  const u = requireUniversalify().fromCallback;
  const fs2 = requireGracefulFs();
  const path = require$$1$1;
  const mkdir = /* @__PURE__ */ requireMkdirs();
  const pathExists = requirePathExists().pathExists;
  function outputFile(file2, data, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = "utf8";
    }
    const dir = path.dirname(file2);
    pathExists(dir, (err, itDoes) => {
      if (err) return callback(err);
      if (itDoes) return fs2.writeFile(file2, data, encoding, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2) return callback(err2);
        fs2.writeFile(file2, data, encoding, callback);
      });
    });
  }
  function outputFileSync(file2, ...args) {
    const dir = path.dirname(file2);
    if (fs2.existsSync(dir)) {
      return fs2.writeFileSync(file2, ...args);
    }
    mkdir.mkdirsSync(dir);
    fs2.writeFileSync(file2, ...args);
  }
  outputFile_1 = {
    outputFile: u(outputFile),
    outputFileSync
  };
  return outputFile_1;
}
var outputJson_1;
var hasRequiredOutputJson;
function requireOutputJson() {
  if (hasRequiredOutputJson) return outputJson_1;
  hasRequiredOutputJson = 1;
  const { stringify } = requireUtils();
  const { outputFile } = /* @__PURE__ */ requireOutputFile();
  async function outputJson(file2, data, options = {}) {
    const str2 = stringify(data, options);
    await outputFile(file2, str2, options);
  }
  outputJson_1 = outputJson;
  return outputJson_1;
}
var outputJsonSync_1;
var hasRequiredOutputJsonSync;
function requireOutputJsonSync() {
  if (hasRequiredOutputJsonSync) return outputJsonSync_1;
  hasRequiredOutputJsonSync = 1;
  const { stringify } = requireUtils();
  const { outputFileSync } = /* @__PURE__ */ requireOutputFile();
  function outputJsonSync(file2, data, options) {
    const str2 = stringify(data, options);
    outputFileSync(file2, str2, options);
  }
  outputJsonSync_1 = outputJsonSync;
  return outputJsonSync_1;
}
var json$1;
var hasRequiredJson$1;
function requireJson$1() {
  if (hasRequiredJson$1) return json$1;
  hasRequiredJson$1 = 1;
  const u = requireUniversalify().fromPromise;
  const jsonFile = /* @__PURE__ */ requireJsonfile();
  jsonFile.outputJson = u(/* @__PURE__ */ requireOutputJson());
  jsonFile.outputJsonSync = /* @__PURE__ */ requireOutputJsonSync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  json$1 = jsonFile;
  return json$1;
}
var move_1;
var hasRequiredMove$1;
function requireMove$1() {
  if (hasRequiredMove$1) return move_1;
  hasRequiredMove$1 = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$1;
  const copy2 = requireCopy().copy;
  const remove = requireRemove().remove;
  const mkdirp = requireMkdirs().mkdirp;
  const pathExists = requirePathExists().pathExists;
  const stat2 = /* @__PURE__ */ requireStat();
  function move2(src2, dest, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    stat2.checkPaths(src2, dest, "move", opts, (err, stats) => {
      if (err) return cb(err);
      const { srcStat, isChangingCase = false } = stats;
      stat2.checkParentPaths(src2, srcStat, dest, "move", (err2) => {
        if (err2) return cb(err2);
        if (isParentRoot(dest)) return doRename(src2, dest, overwrite, isChangingCase, cb);
        mkdirp(path.dirname(dest), (err3) => {
          if (err3) return cb(err3);
          return doRename(src2, dest, overwrite, isChangingCase, cb);
        });
      });
    });
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src2, dest, overwrite, isChangingCase, cb) {
    if (isChangingCase) return rename(src2, dest, overwrite, cb);
    if (overwrite) {
      return remove(dest, (err) => {
        if (err) return cb(err);
        return rename(src2, dest, overwrite, cb);
      });
    }
    pathExists(dest, (err, destExists) => {
      if (err) return cb(err);
      if (destExists) return cb(new Error("dest already exists."));
      return rename(src2, dest, overwrite, cb);
    });
  }
  function rename(src2, dest, overwrite, cb) {
    fs2.rename(src2, dest, (err) => {
      if (!err) return cb();
      if (err.code !== "EXDEV") return cb(err);
      return moveAcrossDevice(src2, dest, overwrite, cb);
    });
  }
  function moveAcrossDevice(src2, dest, overwrite, cb) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copy2(src2, dest, opts, (err) => {
      if (err) return cb(err);
      return remove(src2, cb);
    });
  }
  move_1 = move2;
  return move_1;
}
var moveSync_1;
var hasRequiredMoveSync;
function requireMoveSync() {
  if (hasRequiredMoveSync) return moveSync_1;
  hasRequiredMoveSync = 1;
  const fs2 = requireGracefulFs();
  const path = require$$1$1;
  const copySync = requireCopy().copySync;
  const removeSync = requireRemove().removeSync;
  const mkdirpSync = requireMkdirs().mkdirpSync;
  const stat2 = /* @__PURE__ */ requireStat();
  function moveSync(src2, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat, isChangingCase = false } = stat2.checkPathsSync(src2, dest, "move", opts);
    stat2.checkParentPathsSync(src2, srcStat, dest, "move");
    if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest));
    return doRename(src2, dest, overwrite, isChangingCase);
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src2, dest, overwrite, isChangingCase) {
    if (isChangingCase) return rename(src2, dest, overwrite);
    if (overwrite) {
      removeSync(dest);
      return rename(src2, dest, overwrite);
    }
    if (fs2.existsSync(dest)) throw new Error("dest already exists.");
    return rename(src2, dest, overwrite);
  }
  function rename(src2, dest, overwrite) {
    try {
      fs2.renameSync(src2, dest);
    } catch (err) {
      if (err.code !== "EXDEV") throw err;
      return moveAcrossDevice(src2, dest, overwrite);
    }
  }
  function moveAcrossDevice(src2, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copySync(src2, dest, opts);
    return removeSync(src2);
  }
  moveSync_1 = moveSync;
  return moveSync_1;
}
var move;
var hasRequiredMove;
function requireMove() {
  if (hasRequiredMove) return move;
  hasRequiredMove = 1;
  const u = requireUniversalify().fromCallback;
  move = {
    move: u(/* @__PURE__ */ requireMove$1()),
    moveSync: /* @__PURE__ */ requireMoveSync()
  };
  return move;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  lib = {
    // Export promiseified graceful-fs:
    .../* @__PURE__ */ requireFs(),
    // Export extra methods:
    .../* @__PURE__ */ requireCopy(),
    .../* @__PURE__ */ requireEmpty(),
    .../* @__PURE__ */ requireEnsure(),
    .../* @__PURE__ */ requireJson$1(),
    .../* @__PURE__ */ requireMkdirs(),
    .../* @__PURE__ */ requireMove(),
    .../* @__PURE__ */ requireOutputFile(),
    .../* @__PURE__ */ requirePathExists(),
    .../* @__PURE__ */ requireRemove()
  };
  return lib;
}
var BaseUpdater = {};
var AppUpdater = {};
var jsYaml = {};
var loader = {};
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [sequence];
  }
  function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  common.isNothing = isNothing;
  common.isObject = isObject;
  common.toArray = toArray;
  common.repeat = repeat;
  common.isNegativeZero = isNegativeZero;
  common.extend = extend;
  return common;
}
var exception;
var hasRequiredException;
function requireException() {
  if (hasRequiredException) return exception;
  hasRequiredException = 1;
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    if (!exception2.mark) return message;
    if (exception2.mark.name) {
      where += 'in "' + exception2.mark.name + '" ';
    }
    where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
    if (!compact && exception2.mark.snippet) {
      where += "\n\n" + exception2.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;
  YAMLException.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  exception = YAMLException;
  return exception;
}
var snippet;
var hasRequiredSnippet;
function requireSnippet() {
  if (hasRequiredSnippet) return snippet;
  hasRequiredSnippet = 1;
  var common2 = requireCommon();
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
      tail = " ...";
      lineEnd = position + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "") + tail,
      pos: position - lineStart + head.length
      // relative position
    };
  }
  function padStart(string, max) {
    return common2.repeat(" ", max - string.length) + string;
  }
  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== "number") options.indent = 1;
    if (typeof options.linesBefore !== "number") options.linesBefore = 3;
    if (typeof options.linesAfter !== "number") options.linesAfter = 2;
    var re2 = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while (match = re2.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);
      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = "", i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for (i = 1; i <= options.linesBefore; i++) {
      if (foundLineNo - i < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      );
      result = common2.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common2.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common2.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
    for (i = 1; i <= options.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      );
      result += common2.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
  }
  snippet = makeSnippet;
  return snippet;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  var YAMLException = requireException();
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    if (map2 !== null) {
      Object.keys(map2).forEach(function(style2) {
        map2[style2].forEach(function(alias) {
          result[String(alias)] = style2;
        });
      });
    }
    return result;
  }
  function Type(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options;
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  type = Type;
  return type;
}
var schema;
var hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema) return schema;
  hasRequiredSchema = 1;
  var YAMLException = requireException();
  var Type = requireType();
  function compileList(schema2, name) {
    var result = [];
    schema2[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema(definition) {
    return this.extend(definition);
  }
  Schema.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof Type) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else {
      throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type2) {
      if (!(type2 instanceof Type)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type2.loadKind && type2.loadKind !== "scalar") {
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type2.multi) {
        throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type2) {
      if (!(type2 instanceof Type)) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  schema = Schema;
  return schema;
}
var str;
var hasRequiredStr;
function requireStr() {
  if (hasRequiredStr) return str;
  hasRequiredStr = 1;
  var Type = requireType();
  str = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
  return str;
}
var seq;
var hasRequiredSeq;
function requireSeq() {
  if (hasRequiredSeq) return seq;
  hasRequiredSeq = 1;
  var Type = requireType();
  seq = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  return seq;
}
var map;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map;
  hasRequiredMap = 1;
  var Type = requireType();
  map = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  return map;
}
var failsafe;
var hasRequiredFailsafe;
function requireFailsafe() {
  if (hasRequiredFailsafe) return failsafe;
  hasRequiredFailsafe = 1;
  var Schema = requireSchema();
  failsafe = new Schema({
    explicit: [
      requireStr(),
      requireSeq(),
      requireMap()
    ]
  });
  return failsafe;
}
var _null;
var hasRequired_null;
function require_null() {
  if (hasRequired_null) return _null;
  hasRequired_null = 1;
  var Type = requireType();
  function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object2) {
    return object2 === null;
  }
  _null = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  return _null;
}
var bool;
var hasRequiredBool;
function requireBool() {
  if (hasRequiredBool) return bool;
  hasRequiredBool = 1;
  var Type = requireType();
  function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object2) {
    return Object.prototype.toString.call(object2) === "[object Boolean]";
  }
  bool = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object2) {
        return object2 ? "true" : "false";
      },
      uppercase: function(object2) {
        return object2 ? "TRUE" : "FALSE";
      },
      camelcase: function(object2) {
        return object2 ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  return bool;
}
var int;
var hasRequiredInt;
function requireInt() {
  if (hasRequiredInt) return int;
  hasRequiredInt = 1;
  var common2 = requireCommon();
  var Type = requireType();
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max) return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (ch !== "0" && ch !== "1") return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_") return false;
    for (; index < max; index++) {
      ch = data[index];
      if (ch === "_") continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_") return false;
    return true;
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-") sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
      if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object2) {
    return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 === 0 && !common2.isNegativeZero(object2));
  }
  int = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  return int;
}
var float;
var hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  hasRequiredFloat = 1;
  var common2 = requireCommon();
  var Type = requireType();
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object2, style2) {
    var res;
    if (isNaN(object2)) {
      switch (style2) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object2) {
      switch (style2) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object2) {
      switch (style2) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common2.isNegativeZero(object2)) {
      return "-0.0";
    }
    res = object2.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object2) {
    return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 !== 0 || common2.isNegativeZero(object2));
  }
  float = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  return float;
}
var json;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  json = requireFailsafe().extend({
    implicit: [
      require_null(),
      requireBool(),
      requireInt(),
      requireFloat()
    ]
  });
  return json;
}
var core;
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  core = requireJson();
  return core;
}
var timestamp;
var hasRequiredTimestamp;
function requireTimestamp() {
  if (hasRequiredTimestamp) return timestamp;
  hasRequiredTimestamp = 1;
  var Type = requireType();
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object2) {
    return object2.toISOString();
  }
  timestamp = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  return timestamp;
}
var merge;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge;
  hasRequiredMerge = 1;
  var Type = requireType();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  merge = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  return merge;
}
var binary;
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary;
  hasRequiredBinary = 1;
  var Type = requireType();
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      code = map2.indexOf(data.charAt(idx));
      if (code > 64) continue;
      if (code < 0) return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map2.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object2) {
    var result = "", bits = 0, idx, tail, max = object2.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      }
      bits = (bits << 8) + object2[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    } else if (tail === 2) {
      result += map2[bits >> 10 & 63];
      result += map2[bits >> 4 & 63];
      result += map2[bits << 2 & 63];
      result += map2[64];
    } else if (tail === 1) {
      result += map2[bits >> 2 & 63];
      result += map2[bits << 4 & 63];
      result += map2[64];
      result += map2[64];
    }
    return result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  binary = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  return binary;
}
var omap;
var hasRequiredOmap;
function requireOmap() {
  if (hasRequiredOmap) return omap;
  hasRequiredOmap = 1;
  var Type = requireType();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object2 = data;
    for (index = 0, length = object2.length; index < length; index += 1) {
      pair = object2[index];
      pairHasKey = false;
      if (_toString.call(pair) !== "[object Object]") return false;
      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }
      if (!pairHasKey) return false;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  omap = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  return omap;
}
var pairs;
var hasRequiredPairs;
function requirePairs() {
  if (hasRequiredPairs) return pairs;
  hasRequiredPairs = 1;
  var Type = requireType();
  var _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object2 = data;
    result = new Array(object2.length);
    for (index = 0, length = object2.length; index < length; index += 1) {
      pair = object2[index];
      if (_toString.call(pair) !== "[object Object]") return false;
      keys = Object.keys(pair);
      if (keys.length !== 1) return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object2 = data;
    result = new Array(object2.length);
    for (index = 0, length = object2.length; index < length; index += 1) {
      pair = object2[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  pairs = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  return pairs;
}
var set;
var hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set;
  hasRequiredSet = 1;
  var Type = requireType();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object2 = data;
    for (key in object2) {
      if (_hasOwnProperty.call(object2, key)) {
        if (object2[key] !== null) return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  set = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  return set;
}
var _default;
var hasRequired_default;
function require_default() {
  if (hasRequired_default) return _default;
  hasRequired_default = 1;
  _default = requireCore().extend({
    implicit: [
      requireTimestamp(),
      requireMerge()
    ],
    explicit: [
      requireBinary(),
      requireOmap(),
      requirePairs(),
      requireSet()
    ]
  });
  return _default;
}
var hasRequiredLoader;
function requireLoader() {
  if (hasRequiredLoader) return loader;
  hasRequiredLoader = 1;
  var common2 = requireCommon();
  var YAMLException = requireException();
  var makeSnippet = requireSnippet();
  var DEFAULT_SCHEMA = require_default();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? "" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode(
      (c - 65536 >> 10) + 55296,
      (c - 65536 & 1023) + 56320
    );
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  function State(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || DEFAULT_SCHEMA;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = makeSnippet(mark);
    return new YAMLException(message, mark);
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common2.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      if (keyNode === "__proto__") {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 9 && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common2.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      } else if (ch === 44) {
        throwError(state, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common2.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common2.repeat("\n", emptyLines);
        }
      } else {
        state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33) return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38) return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      } else {
        type2 = null;
        typeList = state.typeMap.multi[state.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result, state.tag)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = /* @__PURE__ */ Object.create(null);
    state.anchorMap = /* @__PURE__ */ Object.create(null);
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0) readLineBreak(state);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
  }
  loader.loadAll = loadAll;
  loader.load = load;
  return loader;
}
var dumper = {};
var hasRequiredDumper;
function requireDumper() {
  if (hasRequiredDumper) return dumper;
  hasRequiredDumper = 1;
  var common2 = requireCommon();
  var YAMLException = requireException();
  var DEFAULT_SCHEMA = require_default();
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style2, type2;
    if (map2 === null) return {};
    result = {};
    keys = Object.keys(map2);
    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style2 = String(map2[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style2)) {
        style2 = type2.styleAliases[style2];
      }
      result[tag] = style2;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common2.repeat("0", length - string.length) + string;
  }
  var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
  function State(options) {
    this.schema = options["schema"] || DEFAULT_SCHEMA;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common2.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while (position < length) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n") result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common2.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type2 = state.implicitTypes[index];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
  }
  function isNsCharOrWhitespace(c) {
    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
    );
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c) {
    return !isWhitespace(c) && c !== CHAR_COLON;
  }
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = function() {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(
        string,
        singleLineOnly,
        state.indent,
        lineWidth,
        testAmbiguity,
        state.quotingType,
        state.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string[i];
        if (char >= 65536) result += string[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  }
  function writeFlowSequence(state, level, object2) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object2.length; index < length; index += 1) {
      value = object2[index];
      if (state.replacer) {
        value = state.replacer.call(object2, String(index), value);
      }
      if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
        if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object2, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object2.length; index < length; index += 1) {
      value = object2[index];
      if (state.replacer) {
        value = state.replacer.call(object2, String(index), value);
      }
      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object2) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (_result !== "") pairBuffer += ", ";
      if (state.condenseFlow) pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object2[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object2, objectKey, objectValue);
      }
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024) pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object2, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object2[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object2, objectKey, objectValue);
      }
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object2, explicit) {
    var _result, typeList, index, length, type2, style2;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
      type2 = typeList[index];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object2 === "object" && object2 instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object2))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state.tag = type2.representName(object2);
          } else {
            state.tag = type2.tag;
          }
        } else {
          state.tag = "?";
        }
        if (type2.represent) {
          style2 = state.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object2, style2);
          } else if (_hasOwnProperty.call(type2.represent, style2)) {
            _result = type2.represent[style2](object2, style2);
          } else {
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style2 + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object2, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object2;
    if (!detectType(state, object2, false)) {
      detectType(state, object2, true);
    }
    var type2 = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object2);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      if (state.tag !== null && state.tag !== "?") {
        tagStr = encodeURI(
          state.tag[0] === "!" ? state.tag.slice(1) : state.tag
        ).replace(/!/g, "%21");
        if (state.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state.dump = tagStr + " " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object2, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object2, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object2, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object2 !== null && typeof object2 === "object") {
      index = objects.indexOf(object2);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object2);
        if (Array.isArray(object2)) {
          for (index = 0, length = object2.length; index < length; index += 1) {
            inspectNode(object2[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object2);
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object2[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
      value = state.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
    return "";
  }
  dumper.dump = dump;
  return dumper;
}
var hasRequiredJsYaml;
function requireJsYaml() {
  if (hasRequiredJsYaml) return jsYaml;
  hasRequiredJsYaml = 1;
  var loader2 = requireLoader();
  var dumper2 = requireDumper();
  function renamed(from, to) {
    return function() {
      throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  jsYaml.Type = requireType();
  jsYaml.Schema = requireSchema();
  jsYaml.FAILSAFE_SCHEMA = requireFailsafe();
  jsYaml.JSON_SCHEMA = requireJson();
  jsYaml.CORE_SCHEMA = requireCore();
  jsYaml.DEFAULT_SCHEMA = require_default();
  jsYaml.load = loader2.load;
  jsYaml.loadAll = loader2.loadAll;
  jsYaml.dump = dumper2.dump;
  jsYaml.YAMLException = requireException();
  jsYaml.types = {
    binary: requireBinary(),
    float: requireFloat(),
    map: requireMap(),
    null: require_null(),
    pairs: requirePairs(),
    set: requireSet(),
    timestamp: requireTimestamp(),
    bool: requireBool(),
    int: requireInt(),
    merge: requireMerge(),
    omap: requireOmap(),
    seq: requireSeq(),
    str: requireStr()
  };
  jsYaml.safeLoad = renamed("safeLoad", "load");
  jsYaml.safeLoadAll = renamed("safeLoadAll", "loadAll");
  jsYaml.safeDump = renamed("safeDump", "dump");
  return jsYaml;
}
var main$1 = {};
var hasRequiredMain$2;
function requireMain$2() {
  if (hasRequiredMain$2) return main$1;
  hasRequiredMain$2 = 1;
  Object.defineProperty(main$1, "__esModule", { value: true });
  main$1.Lazy = void 0;
  class Lazy {
    constructor(creator) {
      this._value = null;
      this.creator = creator;
    }
    get hasValue() {
      return this.creator == null;
    }
    get value() {
      if (this.creator == null) {
        return this._value;
      }
      const result = this.creator();
      this.value = result;
      return result;
    }
    set value(value) {
      this._value = value;
      this.creator = null;
    }
  }
  main$1.Lazy = Lazy;
  return main$1;
}
var re = { exports: {} };
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH = 256;
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  constants = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  return constants;
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  const debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  debug_1 = debug;
  return debug_1;
}
var hasRequiredRe;
function requireRe() {
  if (hasRequiredRe) return re.exports;
  hasRequiredRe = 1;
  (function(module, exports) {
    const {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = requireConstants();
    const debug = requireDebug();
    exports = module.exports = {};
    const re2 = exports.re = [];
    const safeRe = exports.safeRe = [];
    const src2 = exports.src = [];
    const safeSrc = exports.safeSrc = [];
    const t = exports.t = {};
    let R = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    const makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src2[index] = value;
      safeSrc[index] = safe;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src2[t.NUMERICIDENTIFIER]})\\.(${src2[t.NUMERICIDENTIFIER]})\\.(${src2[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src2[t.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src2[t.NUMERICIDENTIFIER]}|${src2[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t.NUMERICIDENTIFIERLOOSE]}|${src2[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src2[t.PRERELEASEIDENTIFIER]}(?:\\.${src2[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src2[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src2[t.BUILDIDENTIFIER]}(?:\\.${src2[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src2[t.MAINVERSION]}${src2[t.PRERELEASE]}?${src2[t.BUILD]}?`);
    createToken("FULL", `^${src2[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src2[t.MAINVERSIONLOOSE]}${src2[t.PRERELEASELOOSE]}?${src2[t.BUILD]}?`);
    createToken("LOOSE", `^${src2[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src2[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src2[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t.XRANGEIDENTIFIER]})(?:\\.(${src2[t.XRANGEIDENTIFIER]})(?:\\.(${src2[t.XRANGEIDENTIFIER]})(?:${src2[t.PRERELEASE]})?${src2[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t.XRANGEIDENTIFIERLOOSE]})(?:${src2[t.PRERELEASELOOSE]})?${src2[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src2[t.GTLT]}\\s*${src2[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src2[t.GTLT]}\\s*${src2[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src2[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src2[t.COERCEPLAIN] + `(?:${src2[t.PRERELEASE]})?(?:${src2[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src2[t.COERCE], true);
    createToken("COERCERTLFULL", src2[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src2[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src2[t.LONETILDE]}${src2[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src2[t.LONETILDE]}${src2[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src2[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src2[t.LONECARET]}${src2[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src2[t.LONECARET]}${src2[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src2[t.GTLT]}\\s*(${src2[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src2[t.GTLT]}\\s*(${src2[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src2[t.GTLT]}\\s*(${src2[t.LOOSEPLAIN]}|${src2[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src2[t.XRANGEPLAIN]})\\s+-\\s+(${src2[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re, re.exports);
  return re.exports;
}
var parseOptions_1;
var hasRequiredParseOptions;
function requireParseOptions() {
  if (hasRequiredParseOptions) return parseOptions_1;
  hasRequiredParseOptions = 1;
  const looseOption = Object.freeze({ loose: true });
  const emptyOpts = Object.freeze({});
  const parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  parseOptions_1 = parseOptions;
  return parseOptions_1;
}
var identifiers;
var hasRequiredIdentifiers;
function requireIdentifiers() {
  if (hasRequiredIdentifiers) return identifiers;
  hasRequiredIdentifiers = 1;
  const numeric = /^[0-9]+$/;
  const compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  };
  return identifiers;
}
var semver$1;
var hasRequiredSemver$1;
function requireSemver$1() {
  if (hasRequiredSemver$1) return semver$1;
  hasRequiredSemver$1 = 1;
  const debug = requireDebug();
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
  const { safeRe: re2, safeSrc: src2, t } = requireRe();
  const parseOptions = requireParseOptions();
  const { compareIdentifiers } = requireIdentifiers();
  class SemVer {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(
          `version is longer than ${MAX_LENGTH} characters`
        );
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const r = new RegExp(`^${this.options.loose ? src2[t.PRERELEASELOOSE] : src2[t.PRERELEASE]}$`);
          const match = `-${identifier}`.match(r);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  semver$1 = SemVer;
  return semver$1;
}
var parse_1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  const SemVer = requireSemver$1();
  const parse2 = (version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  parse_1 = parse2;
  return parse_1;
}
var valid_1;
var hasRequiredValid$1;
function requireValid$1() {
  if (hasRequiredValid$1) return valid_1;
  hasRequiredValid$1 = 1;
  const parse2 = requireParse();
  const valid2 = (version2, options) => {
    const v = parse2(version2, options);
    return v ? v.version : null;
  };
  valid_1 = valid2;
  return valid_1;
}
var clean_1;
var hasRequiredClean;
function requireClean() {
  if (hasRequiredClean) return clean_1;
  hasRequiredClean = 1;
  const parse2 = requireParse();
  const clean = (version2, options) => {
    const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  clean_1 = clean;
  return clean_1;
}
var inc_1;
var hasRequiredInc;
function requireInc() {
  if (hasRequiredInc) return inc_1;
  hasRequiredInc = 1;
  const SemVer = requireSemver$1();
  const inc = (version2, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer(
        version2 instanceof SemVer ? version2.version : version2,
        options
      ).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  inc_1 = inc;
  return inc_1;
}
var diff_1;
var hasRequiredDiff;
function requireDiff() {
  if (hasRequiredDiff) return diff_1;
  hasRequiredDiff = 1;
  const parse2 = requireParse();
  const diff = (version1, version2) => {
    const v1 = parse2(version1, null, true);
    const v2 = parse2(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  diff_1 = diff;
  return diff_1;
}
var major_1;
var hasRequiredMajor;
function requireMajor() {
  if (hasRequiredMajor) return major_1;
  hasRequiredMajor = 1;
  const SemVer = requireSemver$1();
  const major = (a, loose) => new SemVer(a, loose).major;
  major_1 = major;
  return major_1;
}
var minor_1;
var hasRequiredMinor;
function requireMinor() {
  if (hasRequiredMinor) return minor_1;
  hasRequiredMinor = 1;
  const SemVer = requireSemver$1();
  const minor = (a, loose) => new SemVer(a, loose).minor;
  minor_1 = minor;
  return minor_1;
}
var patch_1;
var hasRequiredPatch;
function requirePatch() {
  if (hasRequiredPatch) return patch_1;
  hasRequiredPatch = 1;
  const SemVer = requireSemver$1();
  const patch = (a, loose) => new SemVer(a, loose).patch;
  patch_1 = patch;
  return patch_1;
}
var prerelease_1;
var hasRequiredPrerelease;
function requirePrerelease() {
  if (hasRequiredPrerelease) return prerelease_1;
  hasRequiredPrerelease = 1;
  const parse2 = requireParse();
  const prerelease = (version2, options) => {
    const parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  prerelease_1 = prerelease;
  return prerelease_1;
}
var compare_1;
var hasRequiredCompare;
function requireCompare() {
  if (hasRequiredCompare) return compare_1;
  hasRequiredCompare = 1;
  const SemVer = requireSemver$1();
  const compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  compare_1 = compare;
  return compare_1;
}
var rcompare_1;
var hasRequiredRcompare;
function requireRcompare() {
  if (hasRequiredRcompare) return rcompare_1;
  hasRequiredRcompare = 1;
  const compare = requireCompare();
  const rcompare = (a, b, loose) => compare(b, a, loose);
  rcompare_1 = rcompare;
  return rcompare_1;
}
var compareLoose_1;
var hasRequiredCompareLoose;
function requireCompareLoose() {
  if (hasRequiredCompareLoose) return compareLoose_1;
  hasRequiredCompareLoose = 1;
  const compare = requireCompare();
  const compareLoose = (a, b) => compare(a, b, true);
  compareLoose_1 = compareLoose;
  return compareLoose_1;
}
var compareBuild_1;
var hasRequiredCompareBuild;
function requireCompareBuild() {
  if (hasRequiredCompareBuild) return compareBuild_1;
  hasRequiredCompareBuild = 1;
  const SemVer = requireSemver$1();
  const compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  compareBuild_1 = compareBuild;
  return compareBuild_1;
}
var sort_1;
var hasRequiredSort;
function requireSort() {
  if (hasRequiredSort) return sort_1;
  hasRequiredSort = 1;
  const compareBuild = requireCompareBuild();
  const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  sort_1 = sort;
  return sort_1;
}
var rsort_1;
var hasRequiredRsort;
function requireRsort() {
  if (hasRequiredRsort) return rsort_1;
  hasRequiredRsort = 1;
  const compareBuild = requireCompareBuild();
  const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  rsort_1 = rsort;
  return rsort_1;
}
var gt_1;
var hasRequiredGt;
function requireGt() {
  if (hasRequiredGt) return gt_1;
  hasRequiredGt = 1;
  const compare = requireCompare();
  const gt = (a, b, loose) => compare(a, b, loose) > 0;
  gt_1 = gt;
  return gt_1;
}
var lt_1;
var hasRequiredLt;
function requireLt() {
  if (hasRequiredLt) return lt_1;
  hasRequiredLt = 1;
  const compare = requireCompare();
  const lt = (a, b, loose) => compare(a, b, loose) < 0;
  lt_1 = lt;
  return lt_1;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  const compare = requireCompare();
  const eq = (a, b, loose) => compare(a, b, loose) === 0;
  eq_1 = eq;
  return eq_1;
}
var neq_1;
var hasRequiredNeq;
function requireNeq() {
  if (hasRequiredNeq) return neq_1;
  hasRequiredNeq = 1;
  const compare = requireCompare();
  const neq = (a, b, loose) => compare(a, b, loose) !== 0;
  neq_1 = neq;
  return neq_1;
}
var gte_1;
var hasRequiredGte;
function requireGte() {
  if (hasRequiredGte) return gte_1;
  hasRequiredGte = 1;
  const compare = requireCompare();
  const gte = (a, b, loose) => compare(a, b, loose) >= 0;
  gte_1 = gte;
  return gte_1;
}
var lte_1;
var hasRequiredLte;
function requireLte() {
  if (hasRequiredLte) return lte_1;
  hasRequiredLte = 1;
  const compare = requireCompare();
  const lte = (a, b, loose) => compare(a, b, loose) <= 0;
  lte_1 = lte;
  return lte_1;
}
var cmp_1;
var hasRequiredCmp;
function requireCmp() {
  if (hasRequiredCmp) return cmp_1;
  hasRequiredCmp = 1;
  const eq = requireEq();
  const neq = requireNeq();
  const gt = requireGt();
  const gte = requireGte();
  const lt = requireLt();
  const lte = requireLte();
  const cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  cmp_1 = cmp;
  return cmp_1;
}
var coerce_1;
var hasRequiredCoerce;
function requireCoerce() {
  if (hasRequiredCoerce) return coerce_1;
  hasRequiredCoerce = 1;
  const SemVer = requireSemver$1();
  const parse2 = requireParse();
  const { safeRe: re2, t } = requireRe();
  const coerce = (version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version2.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  coerce_1 = coerce;
  return coerce_1;
}
var lrucache;
var hasRequiredLrucache;
function requireLrucache() {
  if (hasRequiredLrucache) return lrucache;
  hasRequiredLrucache = 1;
  class LRUCache {
    constructor() {
      this.max = 1e3;
      this.map = /* @__PURE__ */ new Map();
    }
    get(key) {
      const value = this.map.get(key);
      if (value === void 0) {
        return void 0;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== void 0) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  lrucache = LRUCache;
  return lrucache;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range {
    constructor(range2, options) {
      options = parseOptions(options);
      if (range2 instanceof Range) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range2);
      range2 = range2.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range2);
      range2 = range2.replace(re2[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range2);
      range2 = range2.replace(re2[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range;
  const LRU = requireLrucache();
  const cache = new LRU();
  const parseOptions = requireParseOptions();
  const Comparator = requireComparator();
  const debug = requireDebug();
  const SemVer = requireSemver$1();
  const {
    safeRe: re2,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = requireRe();
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re2[t.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set2, version2, options) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug(set2[i].semver);
        if (set2[i].semver === Comparator.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY = Symbol("SemVer ANY");
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator;
  const parseOptions = requireParseOptions();
  const { safeRe: re2, t } = requireRe();
  const cmp = requireCmp();
  const debug = requireDebug();
  const SemVer = requireSemver$1();
  const Range = requireRange();
  return comparator;
}
var satisfies_1;
var hasRequiredSatisfies;
function requireSatisfies() {
  if (hasRequiredSatisfies) return satisfies_1;
  hasRequiredSatisfies = 1;
  const Range = requireRange();
  const satisfies = (version2, range2, options) => {
    try {
      range2 = new Range(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version2);
  };
  satisfies_1 = satisfies;
  return satisfies_1;
}
var toComparators_1;
var hasRequiredToComparators;
function requireToComparators() {
  if (hasRequiredToComparators) return toComparators_1;
  hasRequiredToComparators = 1;
  const Range = requireRange();
  const toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  toComparators_1 = toComparators;
  return toComparators_1;
}
var maxSatisfying_1;
var hasRequiredMaxSatisfying;
function requireMaxSatisfying() {
  if (hasRequiredMaxSatisfying) return maxSatisfying_1;
  hasRequiredMaxSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const maxSatisfying = (versions, range2, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  maxSatisfying_1 = maxSatisfying;
  return maxSatisfying_1;
}
var minSatisfying_1;
var hasRequiredMinSatisfying;
function requireMinSatisfying() {
  if (hasRequiredMinSatisfying) return minSatisfying_1;
  hasRequiredMinSatisfying = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const minSatisfying = (versions, range2, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  minSatisfying_1 = minSatisfying;
  return minSatisfying_1;
}
var minVersion_1;
var hasRequiredMinVersion;
function requireMinVersion() {
  if (hasRequiredMinVersion) return minVersion_1;
  hasRequiredMinVersion = 1;
  const SemVer = requireSemver$1();
  const Range = requireRange();
  const gt = requireGt();
  const minVersion = (range2, loose) => {
    range2 = new Range(range2, loose);
    let minver = new SemVer("0.0.0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let setMin = null;
      comparators.forEach((comparator2) => {
        const compver = new SemVer(comparator2.semver.version);
        switch (comparator2.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          /* fallthrough */
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${comparator2.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range2.test(minver)) {
      return minver;
    }
    return null;
  };
  minVersion_1 = minVersion;
  return minVersion_1;
}
var valid;
var hasRequiredValid;
function requireValid() {
  if (hasRequiredValid) return valid;
  hasRequiredValid = 1;
  const Range = requireRange();
  const validRange = (range2, options) => {
    try {
      return new Range(range2, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  valid = validRange;
  return valid;
}
var outside_1;
var hasRequiredOutside;
function requireOutside() {
  if (hasRequiredOutside) return outside_1;
  hasRequiredOutside = 1;
  const SemVer = requireSemver$1();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const Range = requireRange();
  const satisfies = requireSatisfies();
  const gt = requireGt();
  const lt = requireLt();
  const lte = requireLte();
  const gte = requireGte();
  const outside = (version2, range2, hilo, options) => {
    version2 = new SemVer(version2, options);
    range2 = new Range(range2, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range2, options)) {
      return false;
    }
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator2) => {
        if (comparator2.semver === ANY) {
          comparator2 = new Comparator(">=0.0.0");
        }
        high = high || comparator2;
        low = low || comparator2;
        if (gtfn(comparator2.semver, high.semver, options)) {
          high = comparator2;
        } else if (ltfn(comparator2.semver, low.semver, options)) {
          low = comparator2;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  outside_1 = outside;
  return outside_1;
}
var gtr_1;
var hasRequiredGtr;
function requireGtr() {
  if (hasRequiredGtr) return gtr_1;
  hasRequiredGtr = 1;
  const outside = requireOutside();
  const gtr = (version2, range2, options) => outside(version2, range2, ">", options);
  gtr_1 = gtr;
  return gtr_1;
}
var ltr_1;
var hasRequiredLtr;
function requireLtr() {
  if (hasRequiredLtr) return ltr_1;
  hasRequiredLtr = 1;
  const outside = requireOutside();
  const ltr = (version2, range2, options) => outside(version2, range2, "<", options);
  ltr_1 = ltr;
  return ltr_1;
}
var intersects_1;
var hasRequiredIntersects;
function requireIntersects() {
  if (hasRequiredIntersects) return intersects_1;
  hasRequiredIntersects = 1;
  const Range = requireRange();
  const intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  intersects_1 = intersects;
  return intersects_1;
}
var simplify;
var hasRequiredSimplify;
function requireSimplify() {
  if (hasRequiredSimplify) return simplify;
  hasRequiredSimplify = 1;
  const satisfies = requireSatisfies();
  const compare = requireCompare();
  simplify = (versions, range2, options) => {
    const set2 = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version2 of v) {
      const included = satisfies(version2, range2, options);
      if (included) {
        prev = version2;
        if (!first) {
          first = version2;
        }
      } else {
        if (prev) {
          set2.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set2.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set2) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range2.raw === "string" ? range2.raw : String(range2);
    return simplified.length < original.length ? simplified : range2;
  };
  return simplify;
}
var subset_1;
var hasRequiredSubset;
function requireSubset() {
  if (hasRequiredSubset) return subset_1;
  hasRequiredSubset = 1;
  const Range = requireRange();
  const Comparator = requireComparator();
  const { ANY } = Comparator;
  const satisfies = requireSatisfies();
  const compare = requireCompare();
  const subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
    return true;
  };
  const minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  const minimumVersion = [new Comparator(">=0.0.0")];
  const simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = /* @__PURE__ */ new Set();
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  const higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  const lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  subset_1 = subset;
  return subset_1;
}
var semver;
var hasRequiredSemver;
function requireSemver() {
  if (hasRequiredSemver) return semver;
  hasRequiredSemver = 1;
  const internalRe = requireRe();
  const constants2 = requireConstants();
  const SemVer = requireSemver$1();
  const identifiers2 = requireIdentifiers();
  const parse2 = requireParse();
  const valid2 = requireValid$1();
  const clean = requireClean();
  const inc = requireInc();
  const diff = requireDiff();
  const major = requireMajor();
  const minor = requireMinor();
  const patch = requirePatch();
  const prerelease = requirePrerelease();
  const compare = requireCompare();
  const rcompare = requireRcompare();
  const compareLoose = requireCompareLoose();
  const compareBuild = requireCompareBuild();
  const sort = requireSort();
  const rsort = requireRsort();
  const gt = requireGt();
  const lt = requireLt();
  const eq = requireEq();
  const neq = requireNeq();
  const gte = requireGte();
  const lte = requireLte();
  const cmp = requireCmp();
  const coerce = requireCoerce();
  const Comparator = requireComparator();
  const Range = requireRange();
  const satisfies = requireSatisfies();
  const toComparators = requireToComparators();
  const maxSatisfying = requireMaxSatisfying();
  const minSatisfying = requireMinSatisfying();
  const minVersion = requireMinVersion();
  const validRange = requireValid();
  const outside = requireOutside();
  const gtr = requireGtr();
  const ltr = requireLtr();
  const intersects = requireIntersects();
  const simplifyRange = requireSimplify();
  const subset = requireSubset();
  semver = {
    parse: parse2,
    valid: valid2,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants2.RELEASE_TYPES,
    compareIdentifiers: identifiers2.compareIdentifiers,
    rcompareIdentifiers: identifiers2.rcompareIdentifiers
  };
  return semver;
}
var DownloadedUpdateHelper = {};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
var hasRequiredLodash_isequal;
function requireLodash_isequal() {
  if (hasRequiredLodash_isequal) return lodash_isequal.exports;
  hasRequiredLodash_isequal = 1;
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs2 = data.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs2);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (hasOwnProperty.call(value, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object2);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols);
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  })(lodash_isequal, lodash_isequal.exports);
  return lodash_isequal.exports;
}
var hasRequiredDownloadedUpdateHelper;
function requireDownloadedUpdateHelper() {
  if (hasRequiredDownloadedUpdateHelper) return DownloadedUpdateHelper;
  hasRequiredDownloadedUpdateHelper = 1;
  Object.defineProperty(DownloadedUpdateHelper, "__esModule", { value: true });
  DownloadedUpdateHelper.DownloadedUpdateHelper = void 0;
  DownloadedUpdateHelper.createTempUpdateFile = createTempUpdateFile;
  const crypto_1 = require$$1$3;
  const fs_1 = require$$1$2;
  const isEqual = requireLodash_isequal();
  const fs_extra_1 = /* @__PURE__ */ requireLib();
  const path = require$$1$1;
  let DownloadedUpdateHelper$1 = class DownloadedUpdateHelper {
    constructor(cacheDir) {
      this.cacheDir = cacheDir;
      this._file = null;
      this._packageFile = null;
      this.versionInfo = null;
      this.fileInfo = null;
      this._downloadedFileInfo = null;
    }
    get downloadedFileInfo() {
      return this._downloadedFileInfo;
    }
    get file() {
      return this._file;
    }
    get packageFile() {
      return this._packageFile;
    }
    get cacheDirForPendingUpdate() {
      return path.join(this.cacheDir, "pending");
    }
    async validateDownloadedPath(updateFile, updateInfo, fileInfo, logger) {
      if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {
        if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && await (0, fs_extra_1.pathExists)(updateFile)) {
          return updateFile;
        } else {
          return null;
        }
      }
      const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger);
      if (cachedUpdateFile === null) {
        return null;
      }
      logger.info(`Update has already been downloaded to ${updateFile}).`);
      this._file = cachedUpdateFile;
      return cachedUpdateFile;
    }
    async setDownloadedFile(downloadedFile, packageFile, versionInfo, fileInfo, updateFileName, isSaveCache) {
      this._file = downloadedFile;
      this._packageFile = packageFile;
      this.versionInfo = versionInfo;
      this.fileInfo = fileInfo;
      this._downloadedFileInfo = {
        fileName: updateFileName,
        sha512: fileInfo.info.sha512,
        isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true
      };
      if (isSaveCache) {
        await (0, fs_extra_1.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
      }
    }
    async clear() {
      this._file = null;
      this._packageFile = null;
      this.versionInfo = null;
      this.fileInfo = null;
      await this.cleanCacheDirForPendingUpdate();
    }
    async cleanCacheDirForPendingUpdate() {
      try {
        await (0, fs_extra_1.emptyDir)(this.cacheDirForPendingUpdate);
      } catch (_ignore) {
      }
    }
    /**
     * Returns "update-info.json" which is created in the update cache directory's "pending" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.
     * @param fileInfo
     * @param logger
     */
    async getValidCachedUpdateFile(fileInfo, logger) {
      const updateInfoFilePath = this.getUpdateInfoFile();
      const doesUpdateInfoFileExist = await (0, fs_extra_1.pathExists)(updateInfoFilePath);
      if (!doesUpdateInfoFileExist) {
        return null;
      }
      let cachedInfo;
      try {
        cachedInfo = await (0, fs_extra_1.readJson)(updateInfoFilePath);
      } catch (error2) {
        let message = `No cached update info available`;
        if (error2.code !== "ENOENT") {
          await this.cleanCacheDirForPendingUpdate();
          message += ` (error on read: ${error2.message})`;
        }
        logger.info(message);
        return null;
      }
      const isCachedInfoFileNameValid = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null;
      if (!isCachedInfoFileNameValid) {
        logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);
        await this.cleanCacheDirForPendingUpdate();
        return null;
      }
      if (fileInfo.info.sha512 !== cachedInfo.sha512) {
        logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);
        await this.cleanCacheDirForPendingUpdate();
        return null;
      }
      const updateFile = path.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);
      if (!await (0, fs_extra_1.pathExists)(updateFile)) {
        logger.info("Cached update file doesn't exist");
        return null;
      }
      const sha512 = await hashFile(updateFile);
      if (fileInfo.info.sha512 !== sha512) {
        logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);
        await this.cleanCacheDirForPendingUpdate();
        return null;
      }
      this._downloadedFileInfo = cachedInfo;
      return updateFile;
    }
    getUpdateInfoFile() {
      return path.join(this.cacheDirForPendingUpdate, "update-info.json");
    }
  };
  DownloadedUpdateHelper.DownloadedUpdateHelper = DownloadedUpdateHelper$1;
  function hashFile(file2, algorithm = "sha512", encoding = "base64", options) {
    return new Promise((resolve, reject) => {
      const hash = (0, crypto_1.createHash)(algorithm);
      hash.on("error", reject).setEncoding(encoding);
      (0, fs_1.createReadStream)(file2, {
        ...options,
        highWaterMark: 1024 * 1024
        /* better to use more memory but hash faster */
      }).on("error", reject).on("end", () => {
        hash.end();
        resolve(hash.read());
      }).pipe(hash, { end: false });
    });
  }
  async function createTempUpdateFile(name, cacheDir, log2) {
    let nameCounter = 0;
    let result = path.join(cacheDir, name);
    for (let i = 0; i < 3; i++) {
      try {
        await (0, fs_extra_1.unlink)(result);
        return result;
      } catch (e) {
        if (e.code === "ENOENT") {
          return result;
        }
        log2.warn(`Error on remove temp update file: ${e}`);
        result = path.join(cacheDir, `${nameCounter++}-${name}`);
      }
    }
    return result;
  }
  return DownloadedUpdateHelper;
}
var ElectronAppAdapter = {};
var AppAdapter = {};
var hasRequiredAppAdapter;
function requireAppAdapter() {
  if (hasRequiredAppAdapter) return AppAdapter;
  hasRequiredAppAdapter = 1;
  Object.defineProperty(AppAdapter, "__esModule", { value: true });
  AppAdapter.getAppCacheDir = getAppCacheDir;
  const path = require$$1$1;
  const os_1 = require$$2$1;
  function getAppCacheDir() {
    const homedir = (0, os_1.homedir)();
    let result;
    if (process.platform === "win32") {
      result = process.env["LOCALAPPDATA"] || path.join(homedir, "AppData", "Local");
    } else if (process.platform === "darwin") {
      result = path.join(homedir, "Library", "Caches");
    } else {
      result = process.env["XDG_CACHE_HOME"] || path.join(homedir, ".cache");
    }
    return result;
  }
  return AppAdapter;
}
var hasRequiredElectronAppAdapter;
function requireElectronAppAdapter() {
  if (hasRequiredElectronAppAdapter) return ElectronAppAdapter;
  hasRequiredElectronAppAdapter = 1;
  Object.defineProperty(ElectronAppAdapter, "__esModule", { value: true });
  ElectronAppAdapter.ElectronAppAdapter = void 0;
  const path = require$$1$1;
  const AppAdapter_1 = requireAppAdapter();
  let ElectronAppAdapter$1 = class ElectronAppAdapter {
    constructor(app2 = require$$1$7.app) {
      this.app = app2;
    }
    whenReady() {
      return this.app.whenReady();
    }
    get version() {
      return this.app.getVersion();
    }
    get name() {
      return this.app.getName();
    }
    get isPackaged() {
      return this.app.isPackaged === true;
    }
    get appUpdateConfigPath() {
      return this.isPackaged ? path.join(process.resourcesPath, "app-update.yml") : path.join(this.app.getAppPath(), "dev-app-update.yml");
    }
    get userDataPath() {
      return this.app.getPath("userData");
    }
    get baseCachePath() {
      return (0, AppAdapter_1.getAppCacheDir)();
    }
    quit() {
      this.app.quit();
    }
    relaunch() {
      this.app.relaunch();
    }
    onQuit(handler) {
      this.app.once("quit", (_, exitCode) => handler(exitCode));
    }
  };
  ElectronAppAdapter.ElectronAppAdapter = ElectronAppAdapter$1;
  return ElectronAppAdapter;
}
var electronHttpExecutor = {};
var hasRequiredElectronHttpExecutor;
function requireElectronHttpExecutor() {
  if (hasRequiredElectronHttpExecutor) return electronHttpExecutor;
  hasRequiredElectronHttpExecutor = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ElectronHttpExecutor = exports.NET_SESSION_NAME = void 0;
    exports.getNetSession = getNetSession;
    const builder_util_runtime_1 = requireOut();
    exports.NET_SESSION_NAME = "electron-updater";
    function getNetSession() {
      return require$$1$7.session.fromPartition(exports.NET_SESSION_NAME, {
        cache: false
      });
    }
    class ElectronHttpExecutor extends builder_util_runtime_1.HttpExecutor {
      constructor(proxyLoginCallback) {
        super();
        this.proxyLoginCallback = proxyLoginCallback;
        this.cachedSession = null;
      }
      async download(url, destination, options) {
        return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {
          const requestOptions = {
            headers: options.headers || void 0,
            redirect: "manual"
          };
          (0, builder_util_runtime_1.configureRequestUrl)(url, requestOptions);
          (0, builder_util_runtime_1.configureRequestOptions)(requestOptions);
          this.doDownload(requestOptions, {
            destination,
            options,
            onCancel,
            callback: (error2) => {
              if (error2 == null) {
                resolve(destination);
              } else {
                reject(error2);
              }
            },
            responseHandler: null
          }, 0);
        });
      }
      createRequest(options, callback) {
        if (options.headers && options.headers.Host) {
          options.host = options.headers.Host;
          delete options.headers.Host;
        }
        if (this.cachedSession == null) {
          this.cachedSession = getNetSession();
        }
        const request = require$$1$7.net.request({
          ...options,
          session: this.cachedSession
        });
        request.on("response", callback);
        if (this.proxyLoginCallback != null) {
          request.on("login", this.proxyLoginCallback);
        }
        return request;
      }
      addRedirectHandlers(request, options, reject, redirectCount, handler) {
        request.on("redirect", (statusCode, method, redirectUrl) => {
          request.abort();
          if (redirectCount > this.maxRedirects) {
            reject(this.createMaxRedirectError());
          } else {
            handler(builder_util_runtime_1.HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
          }
        });
      }
    }
    exports.ElectronHttpExecutor = ElectronHttpExecutor;
  })(electronHttpExecutor);
  return electronHttpExecutor;
}
var GenericProvider = {};
var util = {};
var lodash_escaperegexp;
var hasRequiredLodash_escaperegexp;
function requireLodash_escaperegexp() {
  if (hasRequiredLodash_escaperegexp) return lodash_escaperegexp;
  hasRequiredLodash_escaperegexp = 1;
  var symbolTag = "[object Symbol]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function escapeRegExp(string) {
    string = toString(string);
    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
  }
  lodash_escaperegexp = escapeRegExp;
  return lodash_escaperegexp;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.newBaseUrl = newBaseUrl;
  util.newUrlFromBase = newUrlFromBase;
  util.getChannelFilename = getChannelFilename;
  util.blockmapFiles = blockmapFiles;
  const url_1 = require$$4$2;
  const escapeRegExp = requireLodash_escaperegexp();
  function newBaseUrl(url) {
    const result = new url_1.URL(url);
    if (!result.pathname.endsWith("/")) {
      result.pathname += "/";
    }
    return result;
  }
  function newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {
    const result = new url_1.URL(pathname, baseUrl);
    const search = baseUrl.search;
    if (search != null && search.length !== 0) {
      result.search = search;
    } else if (addRandomQueryToAvoidCaching) {
      result.search = `noCache=${Date.now().toString(32)}`;
    }
    return result;
  }
  function getChannelFilename(channel) {
    return `${channel}.yml`;
  }
  function blockmapFiles(baseUrl, oldVersion, newVersion) {
    const newBlockMapUrl = newUrlFromBase(`${baseUrl.pathname}.blockmap`, baseUrl);
    const oldBlockMapUrl = newUrlFromBase(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), "g"), oldVersion)}.blockmap`, baseUrl);
    return [oldBlockMapUrl, newBlockMapUrl];
  }
  return util;
}
var Provider = {};
var hasRequiredProvider;
function requireProvider() {
  if (hasRequiredProvider) return Provider;
  hasRequiredProvider = 1;
  Object.defineProperty(Provider, "__esModule", { value: true });
  Provider.Provider = void 0;
  Provider.findFile = findFile;
  Provider.parseUpdateInfo = parseUpdateInfo;
  Provider.getFileList = getFileList;
  Provider.resolveFiles = resolveFiles;
  const builder_util_runtime_1 = requireOut();
  const js_yaml_1 = requireJsYaml();
  const util_1 = requireUtil();
  let Provider$1 = class Provider {
    constructor(runtimeOptions) {
      this.runtimeOptions = runtimeOptions;
      this.requestHeaders = null;
      this.executor = runtimeOptions.executor;
    }
    get isUseMultipleRangeRequest() {
      return this.runtimeOptions.isUseMultipleRangeRequest !== false;
    }
    getChannelFilePrefix() {
      if (this.runtimeOptions.platform === "linux") {
        const arch = process.env["TEST_UPDATER_ARCH"] || process.arch;
        const archSuffix = arch === "x64" ? "" : `-${arch}`;
        return "-linux" + archSuffix;
      } else {
        return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
      }
    }
    // due to historical reasons for windows we use channel name without platform specifier
    getDefaultChannelName() {
      return this.getCustomChannelName("latest");
    }
    getCustomChannelName(channel) {
      return `${channel}${this.getChannelFilePrefix()}`;
    }
    get fileExtraDownloadHeaders() {
      return null;
    }
    setRequestHeaders(value) {
      this.requestHeaders = value;
    }
    /**
     * Method to perform API request only to resolve update info, but not to download update.
     */
    httpRequest(url, headers, cancellationToken) {
      return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);
    }
    createRequestOptions(url, headers) {
      const result = {};
      if (this.requestHeaders == null) {
        if (headers != null) {
          result.headers = headers;
        }
      } else {
        result.headers = headers == null ? this.requestHeaders : { ...this.requestHeaders, ...headers };
      }
      (0, builder_util_runtime_1.configureRequestUrl)(url, result);
      return result;
    }
  };
  Provider.Provider = Provider$1;
  function findFile(files, extension, not) {
    if (files.length === 0) {
      throw (0, builder_util_runtime_1.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
    }
    const result = files.find((it) => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
    if (result != null) {
      return result;
    } else if (not == null) {
      return files[0];
    } else {
      return files.find((fileInfo) => !not.some((ext) => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
    }
  }
  function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
    if (rawData == null) {
      throw (0, builder_util_runtime_1.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    let result;
    try {
      result = (0, js_yaml_1.load)(rawData);
    } catch (e) {
      throw (0, builder_util_runtime_1.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    return result;
  }
  function getFileList(updateInfo) {
    const files = updateInfo.files;
    if (files != null && files.length > 0) {
      return files;
    }
    if (updateInfo.path != null) {
      return [
        {
          url: updateInfo.path,
          sha2: updateInfo.sha2,
          sha512: updateInfo.sha512
        }
      ];
    } else {
      throw (0, builder_util_runtime_1.newError)(`No files provided: ${(0, builder_util_runtime_1.safeStringifyJson)(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
    }
  }
  function resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {
    const files = getFileList(updateInfo);
    const result = files.map((fileInfo) => {
      if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
        throw (0, builder_util_runtime_1.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, builder_util_runtime_1.safeStringifyJson)(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
      }
      return {
        url: (0, util_1.newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),
        info: fileInfo
      };
    });
    const packages = updateInfo.packages;
    const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
    if (packageInfo != null) {
      result[0].packageInfo = {
        ...packageInfo,
        path: (0, util_1.newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href
      };
    }
    return result;
  }
  return Provider;
}
var hasRequiredGenericProvider;
function requireGenericProvider() {
  if (hasRequiredGenericProvider) return GenericProvider;
  hasRequiredGenericProvider = 1;
  Object.defineProperty(GenericProvider, "__esModule", { value: true });
  GenericProvider.GenericProvider = void 0;
  const builder_util_runtime_1 = requireOut();
  const util_1 = requireUtil();
  const Provider_1 = requireProvider();
  let GenericProvider$1 = class GenericProvider extends Provider_1.Provider {
    constructor(configuration, updater2, runtimeOptions) {
      super(runtimeOptions);
      this.configuration = configuration;
      this.updater = updater2;
      this.baseUrl = (0, util_1.newBaseUrl)(this.configuration.url);
    }
    get channel() {
      const result = this.updater.channel || this.configuration.channel;
      return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
    }
    async getLatestVersion() {
      const channelFile = (0, util_1.getChannelFilename)(this.channel);
      const channelUrl = (0, util_1.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
      for (let attemptNumber = 0; ; attemptNumber++) {
        try {
          return (0, Provider_1.parseUpdateInfo)(await this.httpRequest(channelUrl), channelFile, channelUrl);
        } catch (e) {
          if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {
            throw (0, builder_util_runtime_1.newError)(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
          } else if (e.code === "ECONNREFUSED") {
            if (attemptNumber < 3) {
              await new Promise((resolve, reject) => {
                try {
                  setTimeout(resolve, 1e3 * attemptNumber);
                } catch (e2) {
                  reject(e2);
                }
              });
              continue;
            }
          }
          throw e;
        }
      }
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl);
    }
  };
  GenericProvider.GenericProvider = GenericProvider$1;
  return GenericProvider;
}
var providerFactory = {};
var BitbucketProvider = {};
var hasRequiredBitbucketProvider;
function requireBitbucketProvider() {
  if (hasRequiredBitbucketProvider) return BitbucketProvider;
  hasRequiredBitbucketProvider = 1;
  Object.defineProperty(BitbucketProvider, "__esModule", { value: true });
  BitbucketProvider.BitbucketProvider = void 0;
  const builder_util_runtime_1 = requireOut();
  const util_1 = requireUtil();
  const Provider_1 = requireProvider();
  let BitbucketProvider$1 = class BitbucketProvider extends Provider_1.Provider {
    constructor(configuration, updater2, runtimeOptions) {
      super({
        ...runtimeOptions,
        isUseMultipleRangeRequest: false
      });
      this.configuration = configuration;
      this.updater = updater2;
      const { owner, slug } = configuration;
      this.baseUrl = (0, util_1.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${owner}/${slug}/downloads`);
    }
    get channel() {
      return this.updater.channel || this.configuration.channel || "latest";
    }
    async getLatestVersion() {
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const channelFile = (0, util_1.getChannelFilename)(this.getCustomChannelName(this.channel));
      const channelUrl = (0, util_1.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
      try {
        const updateInfo = await this.httpRequest(channelUrl, void 0, cancellationToken);
        return (0, Provider_1.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl);
    }
    toString() {
      const { owner, slug } = this.configuration;
      return `Bitbucket (owner: ${owner}, slug: ${slug}, channel: ${this.channel})`;
    }
  };
  BitbucketProvider.BitbucketProvider = BitbucketProvider$1;
  return BitbucketProvider;
}
var GitHubProvider = {};
var hasRequiredGitHubProvider;
function requireGitHubProvider() {
  if (hasRequiredGitHubProvider) return GitHubProvider;
  hasRequiredGitHubProvider = 1;
  Object.defineProperty(GitHubProvider, "__esModule", { value: true });
  GitHubProvider.GitHubProvider = GitHubProvider.BaseGitHubProvider = void 0;
  GitHubProvider.computeReleaseNotes = computeReleaseNotes;
  const builder_util_runtime_1 = requireOut();
  const semver2 = requireSemver();
  const url_1 = require$$4$2;
  const util_1 = requireUtil();
  const Provider_1 = requireProvider();
  const hrefRegExp = /\/tag\/([^/]+)$/;
  class BaseGitHubProvider extends Provider_1.Provider {
    constructor(options, defaultHost, runtimeOptions) {
      super({
        ...runtimeOptions,
        /* because GitHib uses S3 */
        isUseMultipleRangeRequest: false
      });
      this.options = options;
      this.baseUrl = (0, util_1.newBaseUrl)((0, builder_util_runtime_1.githubUrl)(options, defaultHost));
      const apiHost = defaultHost === "github.com" ? "api.github.com" : defaultHost;
      this.baseApiUrl = (0, util_1.newBaseUrl)((0, builder_util_runtime_1.githubUrl)(options, apiHost));
    }
    computeGithubBasePath(result) {
      const host = this.options.host;
      return host && !["github.com", "api.github.com"].includes(host) ? `/api/v3${result}` : result;
    }
  }
  GitHubProvider.BaseGitHubProvider = BaseGitHubProvider;
  let GitHubProvider$1 = class GitHubProvider extends BaseGitHubProvider {
    constructor(options, updater2, runtimeOptions) {
      super(options, "github.com", runtimeOptions);
      this.options = options;
      this.updater = updater2;
    }
    get channel() {
      const result = this.updater.channel || this.options.channel;
      return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
    }
    async getLatestVersion() {
      var _a, _b, _c, _d, _e;
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const feedXml = await this.httpRequest((0, util_1.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
        accept: "application/xml, application/atom+xml, text/xml, */*"
      }, cancellationToken);
      const feed = (0, builder_util_runtime_1.parseXml)(feedXml);
      let latestRelease = feed.element("entry", false, `No published versions on GitHub`);
      let tag = null;
      try {
        if (this.updater.allowPrerelease) {
          const currentChannel = ((_a = this.updater) === null || _a === void 0 ? void 0 : _a.channel) || ((_b = semver2.prerelease(this.updater.currentVersion)) === null || _b === void 0 ? void 0 : _b[0]) || null;
          if (currentChannel === null) {
            tag = hrefRegExp.exec(latestRelease.element("link").attribute("href"))[1];
          } else {
            for (const element of feed.getElements("entry")) {
              const hrefElement = hrefRegExp.exec(element.element("link").attribute("href"));
              if (hrefElement === null)
                continue;
              const hrefTag = hrefElement[1];
              const hrefChannel = ((_c = semver2.prerelease(hrefTag)) === null || _c === void 0 ? void 0 : _c[0]) || null;
              const shouldFetchVersion = !currentChannel || ["alpha", "beta"].includes(currentChannel);
              const isCustomChannel = hrefChannel !== null && !["alpha", "beta"].includes(String(hrefChannel));
              const channelMismatch = currentChannel === "beta" && hrefChannel === "alpha";
              if (shouldFetchVersion && !isCustomChannel && !channelMismatch) {
                tag = hrefTag;
                break;
              }
              const isNextPreRelease = hrefChannel && hrefChannel === currentChannel;
              if (isNextPreRelease) {
                tag = hrefTag;
                break;
              }
            }
          }
        } else {
          tag = await this.getLatestTagName(cancellationToken);
          for (const element of feed.getElements("entry")) {
            if (hrefRegExp.exec(element.element("link").attribute("href"))[1] === tag) {
              latestRelease = element;
              break;
            }
          }
        }
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Cannot parse releases feed: ${e.stack || e.message},
XML:
${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
      }
      if (tag == null) {
        throw (0, builder_util_runtime_1.newError)(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
      }
      let rawData;
      let channelFile = "";
      let channelFileUrl = "";
      const fetchData = async (channelName) => {
        channelFile = (0, util_1.getChannelFilename)(channelName);
        channelFileUrl = (0, util_1.newUrlFromBase)(this.getBaseDownloadPath(String(tag), channelFile), this.baseUrl);
        const requestOptions = this.createRequestOptions(channelFileUrl);
        try {
          return await this.executor.request(requestOptions, cancellationToken);
        } catch (e) {
          if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {
            throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
          }
          throw e;
        }
      };
      try {
        let channel = this.channel;
        if (this.updater.allowPrerelease && ((_d = semver2.prerelease(tag)) === null || _d === void 0 ? void 0 : _d[0])) {
          channel = this.getCustomChannelName(String((_e = semver2.prerelease(tag)) === null || _e === void 0 ? void 0 : _e[0]));
        }
        rawData = await fetchData(channel);
      } catch (e) {
        if (this.updater.allowPrerelease) {
          rawData = await fetchData(this.getDefaultChannelName());
        } else {
          throw e;
        }
      }
      const result = (0, Provider_1.parseUpdateInfo)(rawData, channelFile, channelFileUrl);
      if (result.releaseName == null) {
        result.releaseName = latestRelease.elementValueOrEmpty("title");
      }
      if (result.releaseNotes == null) {
        result.releaseNotes = computeReleaseNotes(this.updater.currentVersion, this.updater.fullChangelog, feed, latestRelease);
      }
      return {
        tag,
        ...result
      };
    }
    async getLatestTagName(cancellationToken) {
      const options = this.options;
      const url = options.host == null || options.host === "github.com" ? (0, util_1.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new url_1.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);
      try {
        const rawData = await this.httpRequest(url, { Accept: "application/json" }, cancellationToken);
        if (rawData == null) {
          return null;
        }
        const releaseInfo = JSON.parse(rawData);
        return releaseInfo.tag_name;
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    get basePath() {
      return `/${this.options.owner}/${this.options.repo}/releases`;
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl, (p) => this.getBaseDownloadPath(updateInfo.tag, p.replace(/ /g, "-")));
    }
    getBaseDownloadPath(tag, fileName) {
      return `${this.basePath}/download/${tag}/${fileName}`;
    }
  };
  GitHubProvider.GitHubProvider = GitHubProvider$1;
  function getNoteValue(parent) {
    const result = parent.elementValueOrEmpty("content");
    return result === "No content." ? "" : result;
  }
  function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
    if (!isFullChangelog) {
      return getNoteValue(latestRelease);
    }
    const releaseNotes = [];
    for (const release of feed.getElements("entry")) {
      const versionRelease = /\/tag\/v?([^/]+)$/.exec(release.element("link").attribute("href"))[1];
      if (semver2.lt(currentVersion, versionRelease)) {
        releaseNotes.push({
          version: versionRelease,
          note: getNoteValue(release)
        });
      }
    }
    return releaseNotes.sort((a, b) => semver2.rcompare(a.version, b.version));
  }
  return GitHubProvider;
}
var KeygenProvider = {};
var hasRequiredKeygenProvider;
function requireKeygenProvider() {
  if (hasRequiredKeygenProvider) return KeygenProvider;
  hasRequiredKeygenProvider = 1;
  Object.defineProperty(KeygenProvider, "__esModule", { value: true });
  KeygenProvider.KeygenProvider = void 0;
  const builder_util_runtime_1 = requireOut();
  const util_1 = requireUtil();
  const Provider_1 = requireProvider();
  let KeygenProvider$1 = class KeygenProvider extends Provider_1.Provider {
    constructor(configuration, updater2, runtimeOptions) {
      super({
        ...runtimeOptions,
        isUseMultipleRangeRequest: false
      });
      this.configuration = configuration;
      this.updater = updater2;
      this.baseUrl = (0, util_1.newBaseUrl)(`https://api.keygen.sh/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
    }
    get channel() {
      return this.updater.channel || this.configuration.channel || "stable";
    }
    async getLatestVersion() {
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const channelFile = (0, util_1.getChannelFilename)(this.getCustomChannelName(this.channel));
      const channelUrl = (0, util_1.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
      try {
        const updateInfo = await this.httpRequest(channelUrl, {
          Accept: "application/vnd.api+json",
          "Keygen-Version": "1.1"
        }, cancellationToken);
        return (0, Provider_1.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.resolveFiles)(updateInfo, this.baseUrl);
    }
    toString() {
      const { account, product, platform } = this.configuration;
      return `Keygen (account: ${account}, product: ${product}, platform: ${platform}, channel: ${this.channel})`;
    }
  };
  KeygenProvider.KeygenProvider = KeygenProvider$1;
  return KeygenProvider;
}
var PrivateGitHubProvider = {};
var hasRequiredPrivateGitHubProvider;
function requirePrivateGitHubProvider() {
  if (hasRequiredPrivateGitHubProvider) return PrivateGitHubProvider;
  hasRequiredPrivateGitHubProvider = 1;
  Object.defineProperty(PrivateGitHubProvider, "__esModule", { value: true });
  PrivateGitHubProvider.PrivateGitHubProvider = void 0;
  const builder_util_runtime_1 = requireOut();
  const js_yaml_1 = requireJsYaml();
  const path = require$$1$1;
  const url_1 = require$$4$2;
  const util_1 = requireUtil();
  const GitHubProvider_1 = requireGitHubProvider();
  const Provider_1 = requireProvider();
  let PrivateGitHubProvider$1 = class PrivateGitHubProvider extends GitHubProvider_1.BaseGitHubProvider {
    constructor(options, updater2, token, runtimeOptions) {
      super(options, "api.github.com", runtimeOptions);
      this.updater = updater2;
      this.token = token;
    }
    createRequestOptions(url, headers) {
      const result = super.createRequestOptions(url, headers);
      result.redirect = "manual";
      return result;
    }
    async getLatestVersion() {
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      const channelFile = (0, util_1.getChannelFilename)(this.getDefaultChannelName());
      const releaseInfo = await this.getLatestVersionInfo(cancellationToken);
      const asset = releaseInfo.assets.find((it) => it.name === channelFile);
      if (asset == null) {
        throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      const url = new url_1.URL(asset.url);
      let result;
      try {
        result = (0, js_yaml_1.load)(await this.httpRequest(url, this.configureHeaders("application/octet-stream"), cancellationToken));
      } catch (e) {
        if (e instanceof builder_util_runtime_1.HttpError && e.statusCode === 404) {
          throw (0, builder_util_runtime_1.newError)(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        }
        throw e;
      }
      result.assets = releaseInfo.assets;
      return result;
    }
    get fileExtraDownloadHeaders() {
      return this.configureHeaders("application/octet-stream");
    }
    configureHeaders(accept) {
      return {
        accept,
        authorization: `token ${this.token}`
      };
    }
    async getLatestVersionInfo(cancellationToken) {
      const allowPrerelease = this.updater.allowPrerelease;
      let basePath = this.basePath;
      if (!allowPrerelease) {
        basePath = `${basePath}/latest`;
      }
      const url = (0, util_1.newUrlFromBase)(basePath, this.baseUrl);
      try {
        const version2 = JSON.parse(await this.httpRequest(url, this.configureHeaders("application/vnd.github.v3+json"), cancellationToken));
        if (allowPrerelease) {
          return version2.find((it) => it.prerelease) || version2[0];
        } else {
          return version2;
        }
      } catch (e) {
        throw (0, builder_util_runtime_1.newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
    }
    get basePath() {
      return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
    }
    resolveFiles(updateInfo) {
      return (0, Provider_1.getFileList)(updateInfo).map((it) => {
        const name = path.posix.basename(it.url).replace(/ /g, "-");
        const asset = updateInfo.assets.find((it2) => it2 != null && it2.name === name);
        if (asset == null) {
          throw (0, builder_util_runtime_1.newError)(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
        }
        return {
          url: new url_1.URL(asset.url),
          info: it
        };
      });
    }
  };
  PrivateGitHubProvider.PrivateGitHubProvider = PrivateGitHubProvider$1;
  return PrivateGitHubProvider;
}
var hasRequiredProviderFactory;
function requireProviderFactory() {
  if (hasRequiredProviderFactory) return providerFactory;
  hasRequiredProviderFactory = 1;
  Object.defineProperty(providerFactory, "__esModule", { value: true });
  providerFactory.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;
  providerFactory.createClient = createClient;
  const builder_util_runtime_1 = requireOut();
  const BitbucketProvider_1 = requireBitbucketProvider();
  const GenericProvider_1 = requireGenericProvider();
  const GitHubProvider_1 = requireGitHubProvider();
  const KeygenProvider_1 = requireKeygenProvider();
  const PrivateGitHubProvider_1 = requirePrivateGitHubProvider();
  function isUrlProbablySupportMultiRangeRequests(url) {
    return !url.includes("s3.amazonaws.com");
  }
  function createClient(data, updater2, runtimeOptions) {
    if (typeof data === "string") {
      throw (0, builder_util_runtime_1.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
    }
    const provider = data.provider;
    switch (provider) {
      case "github": {
        const githubOptions = data;
        const token = (githubOptions.private ? process.env["GH_TOKEN"] || process.env["GITHUB_TOKEN"] : null) || githubOptions.token;
        if (token == null) {
          return new GitHubProvider_1.GitHubProvider(githubOptions, updater2, runtimeOptions);
        } else {
          return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater2, token, runtimeOptions);
        }
      }
      case "bitbucket":
        return new BitbucketProvider_1.BitbucketProvider(data, updater2, runtimeOptions);
      case "keygen":
        return new KeygenProvider_1.KeygenProvider(data, updater2, runtimeOptions);
      case "s3":
      case "spaces":
        return new GenericProvider_1.GenericProvider({
          provider: "generic",
          url: (0, builder_util_runtime_1.getS3LikeProviderBaseUrl)(data),
          channel: data.channel || null
        }, updater2, {
          ...runtimeOptions,
          // https://github.com/minio/minio/issues/5285#issuecomment-350428955
          isUseMultipleRangeRequest: false
        });
      case "generic": {
        const options = data;
        return new GenericProvider_1.GenericProvider(options, updater2, {
          ...runtimeOptions,
          isUseMultipleRangeRequest: options.useMultipleRangeRequest !== false && isUrlProbablySupportMultiRangeRequests(options.url)
        });
      }
      case "custom": {
        const options = data;
        const constructor = options.updateProvider;
        if (!constructor) {
          throw (0, builder_util_runtime_1.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
        }
        return new constructor(options, updater2, runtimeOptions);
      }
      default:
        throw (0, builder_util_runtime_1.newError)(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
    }
  }
  return providerFactory;
}
var GenericDifferentialDownloader = {};
var DifferentialDownloader = {};
var DataSplitter = {};
var downloadPlanBuilder = {};
var hasRequiredDownloadPlanBuilder;
function requireDownloadPlanBuilder() {
  if (hasRequiredDownloadPlanBuilder) return downloadPlanBuilder;
  hasRequiredDownloadPlanBuilder = 1;
  Object.defineProperty(downloadPlanBuilder, "__esModule", { value: true });
  downloadPlanBuilder.OperationKind = void 0;
  downloadPlanBuilder.computeOperations = computeOperations;
  var OperationKind;
  (function(OperationKind2) {
    OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
    OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
  })(OperationKind || (downloadPlanBuilder.OperationKind = OperationKind = {}));
  function computeOperations(oldBlockMap, newBlockMap, logger) {
    const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
    const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
    let lastOperation = null;
    const blockMapFile = newBlockMap.files[0];
    const operations = [];
    const name = blockMapFile.name;
    const oldEntry = nameToOldBlocks.get(name);
    if (oldEntry == null) {
      throw new Error(`no file ${name} in old blockmap`);
    }
    const newFile = nameToNewBlocks.get(name);
    let changedBlockCount = 0;
    const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger);
    let newOffset = blockMapFile.offset;
    for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {
      const blockSize = newFile.sizes[i];
      const checksum = newFile.checksums[i];
      let oldOffset = checksumToOldOffset.get(checksum);
      if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
        logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
        oldOffset = void 0;
      }
      if (oldOffset === void 0) {
        changedBlockCount++;
        if (lastOperation != null && lastOperation.kind === OperationKind.DOWNLOAD && lastOperation.end === newOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind.DOWNLOAD,
            start: newOffset,
            end: newOffset + blockSize
            // oldBlocks: null,
          };
          validateAndAdd(lastOperation, operations, checksum, i);
        }
      } else {
        if (lastOperation != null && lastOperation.kind === OperationKind.COPY && lastOperation.end === oldOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind.COPY,
            start: oldOffset,
            end: oldOffset + blockSize
            // oldBlocks: [checksum]
          };
          validateAndAdd(lastOperation, operations, checksum, i);
        }
      }
    }
    if (changedBlockCount > 0) {
      logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
    }
    return operations;
  }
  const isValidateOperationRange = process.env["DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES"] === "true";
  function validateAndAdd(operation, operations, checksum, index) {
    if (isValidateOperationRange && operations.length !== 0) {
      const lastOperation = operations[operations.length - 1];
      if (lastOperation.kind === operation.kind && operation.start < lastOperation.end && operation.start > lastOperation.start) {
        const min = [lastOperation.start, lastOperation.end, operation.start, operation.end].reduce((p, v) => p < v ? p : v);
        throw new Error(`operation (block index: ${index}, checksum: ${checksum}, kind: ${OperationKind[operation.kind]}) overlaps previous operation (checksum: ${checksum}):
abs: ${lastOperation.start} until ${lastOperation.end} and ${operation.start} until ${operation.end}
rel: ${lastOperation.start - min} until ${lastOperation.end - min} and ${operation.start - min} until ${operation.end - min}`);
      }
    }
    operations.push(operation);
  }
  function buildChecksumMap(file2, fileOffset, logger) {
    const checksumToOffset = /* @__PURE__ */ new Map();
    const checksumToSize = /* @__PURE__ */ new Map();
    let offset = fileOffset;
    for (let i = 0; i < file2.checksums.length; i++) {
      const checksum = file2.checksums[i];
      const size = file2.sizes[i];
      const existing = checksumToSize.get(checksum);
      if (existing === void 0) {
        checksumToOffset.set(checksum, offset);
        checksumToSize.set(checksum, size);
      } else if (logger.debug != null) {
        const sizeExplanation = existing === size ? "(same size)" : `(size: ${existing}, this size: ${size})`;
        logger.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
      }
      offset += size;
    }
    return { checksumToOffset, checksumToOldSize: checksumToSize };
  }
  function buildBlockFileMap(list) {
    const result = /* @__PURE__ */ new Map();
    for (const item of list) {
      result.set(item.name, item);
    }
    return result;
  }
  return downloadPlanBuilder;
}
var hasRequiredDataSplitter;
function requireDataSplitter() {
  if (hasRequiredDataSplitter) return DataSplitter;
  hasRequiredDataSplitter = 1;
  Object.defineProperty(DataSplitter, "__esModule", { value: true });
  DataSplitter.DataSplitter = void 0;
  DataSplitter.copyData = copyData;
  const builder_util_runtime_1 = requireOut();
  const fs_1 = require$$1$2;
  const stream_1 = require$$0$4;
  const downloadPlanBuilder_1 = requireDownloadPlanBuilder();
  const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
  var ReadState;
  (function(ReadState2) {
    ReadState2[ReadState2["INIT"] = 0] = "INIT";
    ReadState2[ReadState2["HEADER"] = 1] = "HEADER";
    ReadState2[ReadState2["BODY"] = 2] = "BODY";
  })(ReadState || (ReadState = {}));
  function copyData(task, out2, oldFileFd, reject, resolve) {
    const readStream = (0, fs_1.createReadStream)("", {
      fd: oldFileFd,
      autoClose: false,
      start: task.start,
      // end is inclusive
      end: task.end - 1
    });
    readStream.on("error", reject);
    readStream.once("end", resolve);
    readStream.pipe(out2, {
      end: false
    });
  }
  let DataSplitter$1 = class DataSplitter extends stream_1.Writable {
    constructor(out2, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
      super();
      this.out = out2;
      this.options = options;
      this.partIndexToTaskIndex = partIndexToTaskIndex;
      this.partIndexToLength = partIndexToLength;
      this.finishHandler = finishHandler;
      this.partIndex = -1;
      this.headerListBuffer = null;
      this.readState = ReadState.INIT;
      this.ignoreByteCount = 0;
      this.remainingPartDataCount = 0;
      this.actualPartLength = 0;
      this.boundaryLength = boundary.length + 4;
      this.ignoreByteCount = this.boundaryLength - 2;
    }
    get isFinished() {
      return this.partIndex === this.partIndexToLength.length;
    }
    // noinspection JSUnusedGlobalSymbols
    _write(data, encoding, callback) {
      if (this.isFinished) {
        console.error(`Trailing ignored data: ${data.length} bytes`);
        return;
      }
      this.handleData(data).then(callback).catch(callback);
    }
    async handleData(chunk) {
      let start = 0;
      if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {
        throw (0, builder_util_runtime_1.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
      }
      if (this.ignoreByteCount > 0) {
        const toIgnore = Math.min(this.ignoreByteCount, chunk.length);
        this.ignoreByteCount -= toIgnore;
        start = toIgnore;
      } else if (this.remainingPartDataCount > 0) {
        const toRead = Math.min(this.remainingPartDataCount, chunk.length);
        this.remainingPartDataCount -= toRead;
        await this.processPartData(chunk, 0, toRead);
        start = toRead;
      }
      if (start === chunk.length) {
        return;
      }
      if (this.readState === ReadState.HEADER) {
        const headerListEnd = this.searchHeaderListEnd(chunk, start);
        if (headerListEnd === -1) {
          return;
        }
        start = headerListEnd;
        this.readState = ReadState.BODY;
        this.headerListBuffer = null;
      }
      while (true) {
        if (this.readState === ReadState.BODY) {
          this.readState = ReadState.INIT;
        } else {
          this.partIndex++;
          let taskIndex = this.partIndexToTaskIndex.get(this.partIndex);
          if (taskIndex == null) {
            if (this.isFinished) {
              taskIndex = this.options.end;
            } else {
              throw (0, builder_util_runtime_1.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
            }
          }
          const prevTaskIndex = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
          if (prevTaskIndex < taskIndex) {
            await this.copyExistingData(prevTaskIndex, taskIndex);
          } else if (prevTaskIndex > taskIndex) {
            throw (0, builder_util_runtime_1.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
          }
          if (this.isFinished) {
            this.onPartEnd();
            this.finishHandler();
            return;
          }
          start = this.searchHeaderListEnd(chunk, start);
          if (start === -1) {
            this.readState = ReadState.HEADER;
            return;
          }
        }
        const partLength = this.partIndexToLength[this.partIndex];
        const end = start + partLength;
        const effectiveEnd = Math.min(end, chunk.length);
        await this.processPartStarted(chunk, start, effectiveEnd);
        this.remainingPartDataCount = partLength - (effectiveEnd - start);
        if (this.remainingPartDataCount > 0) {
          return;
        }
        start = end + this.boundaryLength;
        if (start >= chunk.length) {
          this.ignoreByteCount = this.boundaryLength - (chunk.length - end);
          return;
        }
      }
    }
    copyExistingData(index, end) {
      return new Promise((resolve, reject) => {
        const w = () => {
          if (index === end) {
            resolve();
            return;
          }
          const task = this.options.tasks[index];
          if (task.kind !== downloadPlanBuilder_1.OperationKind.COPY) {
            reject(new Error("Task kind must be COPY"));
            return;
          }
          copyData(task, this.out, this.options.oldFileFd, reject, () => {
            index++;
            w();
          });
        };
        w();
      });
    }
    searchHeaderListEnd(chunk, readOffset) {
      const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
      if (headerListEnd !== -1) {
        return headerListEnd + DOUBLE_CRLF.length;
      }
      const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
      if (this.headerListBuffer == null) {
        this.headerListBuffer = partialChunk;
      } else {
        this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
      }
      return -1;
    }
    onPartEnd() {
      const expectedLength = this.partIndexToLength[this.partIndex - 1];
      if (this.actualPartLength !== expectedLength) {
        throw (0, builder_util_runtime_1.newError)(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
      }
      this.actualPartLength = 0;
    }
    processPartStarted(data, start, end) {
      if (this.partIndex !== 0) {
        this.onPartEnd();
      }
      return this.processPartData(data, start, end);
    }
    processPartData(data, start, end) {
      this.actualPartLength += end - start;
      const out2 = this.out;
      if (out2.write(start === 0 && data.length === end ? data : data.slice(start, end))) {
        return Promise.resolve();
      } else {
        return new Promise((resolve, reject) => {
          out2.on("error", reject);
          out2.once("drain", () => {
            out2.removeListener("error", reject);
            resolve();
          });
        });
      }
    }
  };
  DataSplitter.DataSplitter = DataSplitter$1;
  return DataSplitter;
}
var multipleRangeDownloader = {};
var hasRequiredMultipleRangeDownloader;
function requireMultipleRangeDownloader() {
  if (hasRequiredMultipleRangeDownloader) return multipleRangeDownloader;
  hasRequiredMultipleRangeDownloader = 1;
  Object.defineProperty(multipleRangeDownloader, "__esModule", { value: true });
  multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = executeTasksUsingMultipleRangeRequests;
  multipleRangeDownloader.checkIsRangesSupported = checkIsRangesSupported;
  const builder_util_runtime_1 = requireOut();
  const DataSplitter_1 = requireDataSplitter();
  const downloadPlanBuilder_1 = requireDownloadPlanBuilder();
  function executeTasksUsingMultipleRangeRequests(differentialDownloader, tasks, out2, oldFileFd, reject) {
    const w = (taskOffset) => {
      if (taskOffset >= tasks.length) {
        if (differentialDownloader.fileMetadataBuffer != null) {
          out2.write(differentialDownloader.fileMetadataBuffer);
        }
        out2.end();
        return;
      }
      const nextOffset = taskOffset + 1e3;
      doExecuteTasks(differentialDownloader, {
        tasks,
        start: taskOffset,
        end: Math.min(tasks.length, nextOffset),
        oldFileFd
      }, out2, () => w(nextOffset), reject);
    };
    return w;
  }
  function doExecuteTasks(differentialDownloader, options, out2, resolve, reject) {
    let ranges = "bytes=";
    let partCount = 0;
    const partIndexToTaskIndex = /* @__PURE__ */ new Map();
    const partIndexToLength = [];
    for (let i = options.start; i < options.end; i++) {
      const task = options.tasks[i];
      if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
        ranges += `${task.start}-${task.end - 1}, `;
        partIndexToTaskIndex.set(partCount, i);
        partCount++;
        partIndexToLength.push(task.end - task.start);
      }
    }
    if (partCount <= 1) {
      const w = (index) => {
        if (index >= options.end) {
          resolve();
          return;
        }
        const task = options.tasks[index++];
        if (task.kind === downloadPlanBuilder_1.OperationKind.COPY) {
          (0, DataSplitter_1.copyData)(task, out2, options.oldFileFd, reject, () => w(index));
        } else {
          const requestOptions2 = differentialDownloader.createRequestOptions();
          requestOptions2.headers.Range = `bytes=${task.start}-${task.end - 1}`;
          const request2 = differentialDownloader.httpExecutor.createRequest(requestOptions2, (response) => {
            if (!checkIsRangesSupported(response, reject)) {
              return;
            }
            response.pipe(out2, {
              end: false
            });
            response.once("end", () => w(index));
          });
          differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);
          request2.end();
        }
      };
      w(options.start);
      return;
    }
    const requestOptions = differentialDownloader.createRequestOptions();
    requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
    const request = differentialDownloader.httpExecutor.createRequest(requestOptions, (response) => {
      if (!checkIsRangesSupported(response, reject)) {
        return;
      }
      const contentType = (0, builder_util_runtime_1.safeGetHeader)(response, "content-type");
      const m = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
      if (m == null) {
        reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
        return;
      }
      const dicer = new DataSplitter_1.DataSplitter(out2, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve);
      dicer.on("error", reject);
      response.pipe(dicer);
      response.on("end", () => {
        setTimeout(() => {
          request.abort();
          reject(new Error("Response ends without calling any handlers"));
        }, 1e4);
      });
    });
    differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
    request.end();
  }
  function checkIsRangesSupported(response, reject) {
    if (response.statusCode >= 400) {
      reject((0, builder_util_runtime_1.createHttpError)(response));
      return false;
    }
    if (response.statusCode !== 206) {
      const acceptRanges = (0, builder_util_runtime_1.safeGetHeader)(response, "accept-ranges");
      if (acceptRanges == null || acceptRanges === "none") {
        reject(new Error(`Server doesn't support Accept-Ranges (response code ${response.statusCode})`));
        return false;
      }
    }
    return true;
  }
  return multipleRangeDownloader;
}
var ProgressDifferentialDownloadCallbackTransform = {};
var hasRequiredProgressDifferentialDownloadCallbackTransform;
function requireProgressDifferentialDownloadCallbackTransform() {
  if (hasRequiredProgressDifferentialDownloadCallbackTransform) return ProgressDifferentialDownloadCallbackTransform;
  hasRequiredProgressDifferentialDownloadCallbackTransform = 1;
  Object.defineProperty(ProgressDifferentialDownloadCallbackTransform, "__esModule", { value: true });
  ProgressDifferentialDownloadCallbackTransform.ProgressDifferentialDownloadCallbackTransform = void 0;
  const stream_1 = require$$0$4;
  var OperationKind;
  (function(OperationKind2) {
    OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
    OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
  })(OperationKind || (OperationKind = {}));
  let ProgressDifferentialDownloadCallbackTransform$1 = class ProgressDifferentialDownloadCallbackTransform extends stream_1.Transform {
    constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {
      super();
      this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;
      this.cancellationToken = cancellationToken;
      this.onProgress = onProgress;
      this.start = Date.now();
      this.transferred = 0;
      this.delta = 0;
      this.expectedBytes = 0;
      this.index = 0;
      this.operationType = OperationKind.COPY;
      this.nextUpdate = this.start + 1e3;
    }
    _transform(chunk, encoding, callback) {
      if (this.cancellationToken.cancelled) {
        callback(new Error("cancelled"), null);
        return;
      }
      if (this.operationType == OperationKind.COPY) {
        callback(null, chunk);
        return;
      }
      this.transferred += chunk.length;
      this.delta += chunk.length;
      const now = Date.now();
      if (now >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
        this.nextUpdate = now + 1e3;
        this.onProgress({
          total: this.progressDifferentialDownloadInfo.grandTotal,
          delta: this.delta,
          transferred: this.transferred,
          percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
          bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
        });
        this.delta = 0;
      }
      callback(null, chunk);
    }
    beginFileCopy() {
      this.operationType = OperationKind.COPY;
    }
    beginRangeDownload() {
      this.operationType = OperationKind.DOWNLOAD;
      this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
    }
    endRangeDownload() {
      if (this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
        this.onProgress({
          total: this.progressDifferentialDownloadInfo.grandTotal,
          delta: this.delta,
          transferred: this.transferred,
          percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
          bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
        });
      }
    }
    // Called when we are 100% done with the connection/download
    _flush(callback) {
      if (this.cancellationToken.cancelled) {
        callback(new Error("cancelled"));
        return;
      }
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
      this.delta = 0;
      this.transferred = 0;
      callback(null);
    }
  };
  ProgressDifferentialDownloadCallbackTransform.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform$1;
  return ProgressDifferentialDownloadCallbackTransform;
}
var hasRequiredDifferentialDownloader;
function requireDifferentialDownloader() {
  if (hasRequiredDifferentialDownloader) return DifferentialDownloader;
  hasRequiredDifferentialDownloader = 1;
  Object.defineProperty(DifferentialDownloader, "__esModule", { value: true });
  DifferentialDownloader.DifferentialDownloader = void 0;
  const builder_util_runtime_1 = requireOut();
  const fs_extra_1 = /* @__PURE__ */ requireLib();
  const fs_1 = require$$1$2;
  const DataSplitter_1 = requireDataSplitter();
  const url_1 = require$$4$2;
  const downloadPlanBuilder_1 = requireDownloadPlanBuilder();
  const multipleRangeDownloader_1 = requireMultipleRangeDownloader();
  const ProgressDifferentialDownloadCallbackTransform_1 = requireProgressDifferentialDownloadCallbackTransform();
  let DifferentialDownloader$1 = class DifferentialDownloader {
    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
    constructor(blockAwareFileInfo, httpExecutor2, options) {
      this.blockAwareFileInfo = blockAwareFileInfo;
      this.httpExecutor = httpExecutor2;
      this.options = options;
      this.fileMetadataBuffer = null;
      this.logger = options.logger;
    }
    createRequestOptions() {
      const result = {
        headers: {
          ...this.options.requestHeaders,
          accept: "*/*"
        }
      };
      (0, builder_util_runtime_1.configureRequestUrl)(this.options.newUrl, result);
      (0, builder_util_runtime_1.configureRequestOptions)(result);
      return result;
    }
    doDownload(oldBlockMap, newBlockMap) {
      if (oldBlockMap.version !== newBlockMap.version) {
        throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
      }
      const logger = this.logger;
      const operations = (0, downloadPlanBuilder_1.computeOperations)(oldBlockMap, newBlockMap, logger);
      if (logger.debug != null) {
        logger.debug(JSON.stringify(operations, null, 2));
      }
      let downloadSize = 0;
      let copySize = 0;
      for (const operation of operations) {
        const length = operation.end - operation.start;
        if (operation.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
          downloadSize += length;
        } else {
          copySize += length;
        }
      }
      const newSize = this.blockAwareFileInfo.size;
      if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== newSize) {
        throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newSize: ${newSize}`);
      }
      logger.info(`Full: ${formatBytes(newSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newSize / 100))}%)`);
      return this.downloadFile(operations);
    }
    downloadFile(tasks) {
      const fdList = [];
      const closeFiles = () => {
        return Promise.all(fdList.map((openedFile) => {
          return (0, fs_extra_1.close)(openedFile.descriptor).catch((e) => {
            this.logger.error(`cannot close file "${openedFile.path}": ${e}`);
          });
        }));
      };
      return this.doDownloadFile(tasks, fdList).then(closeFiles).catch((e) => {
        return closeFiles().catch((closeFilesError) => {
          try {
            this.logger.error(`cannot close files: ${closeFilesError}`);
          } catch (errorOnLog) {
            try {
              console.error(errorOnLog);
            } catch (_ignored) {
            }
          }
          throw e;
        }).then(() => {
          throw e;
        });
      });
    }
    async doDownloadFile(tasks, fdList) {
      const oldFileFd = await (0, fs_extra_1.open)(this.options.oldFile, "r");
      fdList.push({ descriptor: oldFileFd, path: this.options.oldFile });
      const newFileFd = await (0, fs_extra_1.open)(this.options.newFile, "w");
      fdList.push({ descriptor: newFileFd, path: this.options.newFile });
      const fileOut = (0, fs_1.createWriteStream)(this.options.newFile, { fd: newFileFd });
      await new Promise((resolve, reject) => {
        const streams2 = [];
        let downloadInfoTransform = void 0;
        if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
          const expectedByteCounts = [];
          let grandTotalBytes = 0;
          for (const task of tasks) {
            if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
              expectedByteCounts.push(task.end - task.start);
              grandTotalBytes += task.end - task.start;
            }
          }
          const progressDifferentialDownloadInfo = {
            expectedByteCounts,
            grandTotal: grandTotalBytes
          };
          downloadInfoTransform = new ProgressDifferentialDownloadCallbackTransform_1.ProgressDifferentialDownloadCallbackTransform(progressDifferentialDownloadInfo, this.options.cancellationToken, this.options.onProgress);
          streams2.push(downloadInfoTransform);
        }
        const digestTransform = new builder_util_runtime_1.DigestTransform(this.blockAwareFileInfo.sha512);
        digestTransform.isValidateOnEnd = false;
        streams2.push(digestTransform);
        fileOut.on("finish", () => {
          fileOut.close(() => {
            fdList.splice(1, 1);
            try {
              digestTransform.validate();
            } catch (e) {
              reject(e);
              return;
            }
            resolve(void 0);
          });
        });
        streams2.push(fileOut);
        let lastStream = null;
        for (const stream2 of streams2) {
          stream2.on("error", reject);
          if (lastStream == null) {
            lastStream = stream2;
          } else {
            lastStream = lastStream.pipe(stream2);
          }
        }
        const firstStream = streams2[0];
        let w;
        if (this.options.isUseMultipleRangeRequest) {
          w = (0, multipleRangeDownloader_1.executeTasksUsingMultipleRangeRequests)(this, tasks, firstStream, oldFileFd, reject);
          w(0);
          return;
        }
        let downloadOperationCount = 0;
        let actualUrl = null;
        this.logger.info(`Differential download: ${this.options.newUrl}`);
        const requestOptions = this.createRequestOptions();
        requestOptions.redirect = "manual";
        w = (index) => {
          var _a, _b;
          if (index >= tasks.length) {
            if (this.fileMetadataBuffer != null) {
              firstStream.write(this.fileMetadataBuffer);
            }
            firstStream.end();
            return;
          }
          const operation = tasks[index++];
          if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {
            if (downloadInfoTransform) {
              downloadInfoTransform.beginFileCopy();
            }
            (0, DataSplitter_1.copyData)(operation, firstStream, oldFileFd, reject, () => w(index));
            return;
          }
          const range2 = `bytes=${operation.start}-${operation.end - 1}`;
          requestOptions.headers.range = range2;
          (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `download range: ${range2}`);
          if (downloadInfoTransform) {
            downloadInfoTransform.beginRangeDownload();
          }
          const request = this.httpExecutor.createRequest(requestOptions, (response) => {
            response.on("error", reject);
            response.on("aborted", () => {
              reject(new Error("response has been aborted by the server"));
            });
            if (response.statusCode >= 400) {
              reject((0, builder_util_runtime_1.createHttpError)(response));
            }
            response.pipe(firstStream, {
              end: false
            });
            response.once("end", () => {
              if (downloadInfoTransform) {
                downloadInfoTransform.endRangeDownload();
              }
              if (++downloadOperationCount === 100) {
                downloadOperationCount = 0;
                setTimeout(() => w(index), 1e3);
              } else {
                w(index);
              }
            });
          });
          request.on("redirect", (statusCode, method, redirectUrl) => {
            this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
            actualUrl = redirectUrl;
            (0, builder_util_runtime_1.configureRequestUrl)(new url_1.URL(actualUrl), requestOptions);
            request.followRedirect();
          });
          this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
          request.end();
        };
        w(0);
      });
    }
    async readRemoteBytes(start, endInclusive) {
      const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
      const requestOptions = this.createRequestOptions();
      requestOptions.headers.range = `bytes=${start}-${endInclusive}`;
      let position = 0;
      await this.request(requestOptions, (chunk) => {
        chunk.copy(buffer, position);
        position += chunk.length;
      });
      if (position !== buffer.length) {
        throw new Error(`Received data length ${position} is not equal to expected ${buffer.length}`);
      }
      return buffer;
    }
    request(requestOptions, dataHandler) {
      return new Promise((resolve, reject) => {
        const request = this.httpExecutor.createRequest(requestOptions, (response) => {
          if (!(0, multipleRangeDownloader_1.checkIsRangesSupported)(response, reject)) {
            return;
          }
          response.on("error", reject);
          response.on("aborted", () => {
            reject(new Error("response has been aborted by the server"));
          });
          response.on("data", dataHandler);
          response.on("end", () => resolve());
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
        request.end();
      });
    }
  };
  DifferentialDownloader.DifferentialDownloader = DifferentialDownloader$1;
  function formatBytes(value, symbol = " KB") {
    return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
  }
  function removeQuery(url) {
    const index = url.indexOf("?");
    return index < 0 ? url : url.substring(0, index);
  }
  return DifferentialDownloader;
}
var hasRequiredGenericDifferentialDownloader;
function requireGenericDifferentialDownloader() {
  if (hasRequiredGenericDifferentialDownloader) return GenericDifferentialDownloader;
  hasRequiredGenericDifferentialDownloader = 1;
  Object.defineProperty(GenericDifferentialDownloader, "__esModule", { value: true });
  GenericDifferentialDownloader.GenericDifferentialDownloader = void 0;
  const DifferentialDownloader_1 = requireDifferentialDownloader();
  let GenericDifferentialDownloader$1 = class GenericDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
    download(oldBlockMap, newBlockMap) {
      return this.doDownload(oldBlockMap, newBlockMap);
    }
  };
  GenericDifferentialDownloader.GenericDifferentialDownloader = GenericDifferentialDownloader$1;
  return GenericDifferentialDownloader;
}
var hasRequiredAppUpdater;
function requireAppUpdater() {
  if (hasRequiredAppUpdater) return AppUpdater;
  hasRequiredAppUpdater = 1;
  Object.defineProperty(AppUpdater, "__esModule", { value: true });
  AppUpdater.NoOpLogger = AppUpdater.AppUpdater = void 0;
  const builder_util_runtime_1 = requireOut();
  const crypto_1 = require$$1$3;
  const os_1 = require$$2$1;
  const events_1 = require$$0$3;
  const fs_extra_1 = /* @__PURE__ */ requireLib();
  const js_yaml_1 = requireJsYaml();
  const lazy_val_1 = requireMain$2();
  const path = require$$1$1;
  const semver_1 = requireSemver();
  const DownloadedUpdateHelper_1 = requireDownloadedUpdateHelper();
  const ElectronAppAdapter_1 = requireElectronAppAdapter();
  const electronHttpExecutor_1 = requireElectronHttpExecutor();
  const GenericProvider_1 = requireGenericProvider();
  const main_1 = requireMain$1();
  const providerFactory_1 = requireProviderFactory();
  const zlib_1 = require$$0$2;
  const util_1 = requireUtil();
  const GenericDifferentialDownloader_1 = requireGenericDifferentialDownloader();
  let AppUpdater$1 = class AppUpdater2 extends events_1.EventEmitter {
    /**
     * Get the update channel. Doesn't return `channel` from the update configuration, only if was previously set.
     */
    get channel() {
      return this._channel;
    }
    /**
     * Set the update channel. Overrides `channel` in the update configuration.
     *
     * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
     */
    set channel(value) {
      if (this._channel != null) {
        if (typeof value !== "string") {
          throw (0, builder_util_runtime_1.newError)(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
        } else if (value.length === 0) {
          throw (0, builder_util_runtime_1.newError)(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
        }
      }
      this._channel = value;
      this.allowDowngrade = true;
    }
    /**
     *  Shortcut for explicitly adding auth tokens to request headers
     */
    addAuthHeader(token) {
      this.requestHeaders = Object.assign({}, this.requestHeaders, {
        authorization: token
      });
    }
    // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
    get netSession() {
      return (0, electronHttpExecutor_1.getNetSession)();
    }
    /**
     * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
     * Set it to `null` if you would like to disable a logging feature.
     */
    get logger() {
      return this._logger;
    }
    set logger(value) {
      this._logger = value == null ? new NoOpLogger() : value;
    }
    // noinspection JSUnusedGlobalSymbols
    /**
     * test only
     * @private
     */
    set updateConfigPath(value) {
      this.clientPromise = null;
      this._appUpdateConfigPath = value;
      this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
    }
    constructor(options, app2) {
      super();
      this.autoDownload = true;
      this.autoInstallOnAppQuit = true;
      this.autoRunAppAfterInstall = true;
      this.allowPrerelease = false;
      this.fullChangelog = false;
      this.allowDowngrade = false;
      this.disableWebInstaller = false;
      this.disableDifferentialDownload = false;
      this.forceDevUpdateConfig = false;
      this._channel = null;
      this.downloadedUpdateHelper = null;
      this.requestHeaders = null;
      this._logger = console;
      this.signals = new main_1.UpdaterSignal(this);
      this._appUpdateConfigPath = null;
      this.clientPromise = null;
      this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());
      this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
      this.checkForUpdatesPromise = null;
      this.downloadPromise = null;
      this.updateInfoAndProvider = null;
      this._testOnlyOptions = null;
      this.on("error", (error2) => {
        this._logger.error(`Error: ${error2.stack || error2.message}`);
      });
      if (app2 == null) {
        this.app = new ElectronAppAdapter_1.ElectronAppAdapter();
        this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
      } else {
        this.app = app2;
        this.httpExecutor = null;
      }
      const currentVersionString = this.app.version;
      const currentVersion = (0, semver_1.parse)(currentVersionString);
      if (currentVersion == null) {
        throw (0, builder_util_runtime_1.newError)(`App version is not a valid semver version: "${currentVersionString}"`, "ERR_UPDATER_INVALID_VERSION");
      }
      this.currentVersion = currentVersion;
      this.allowPrerelease = hasPrereleaseComponents(currentVersion);
      if (options != null) {
        this.setFeedURL(options);
        if (typeof options !== "string" && options.requestHeaders) {
          this.requestHeaders = options.requestHeaders;
        }
      }
    }
    //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
    getFeedURL() {
      return "Deprecated. Do not use it.";
    }
    /**
     * Configure update provider. If value is `string`, [GenericServerOptions](./publish.md#genericserveroptions) will be set with value as `url`.
     * @param options If you want to override configuration in the `app-update.yml`.
     */
    setFeedURL(options) {
      const runtimeOptions = this.createProviderRuntimeOptions();
      let provider;
      if (typeof options === "string") {
        provider = new GenericProvider_1.GenericProvider({ provider: "generic", url: options }, this, {
          ...runtimeOptions,
          isUseMultipleRangeRequest: (0, providerFactory_1.isUrlProbablySupportMultiRangeRequests)(options)
        });
      } else {
        provider = (0, providerFactory_1.createClient)(options, this, runtimeOptions);
      }
      this.clientPromise = Promise.resolve(provider);
    }
    /**
     * Asks the server whether there is an update.
     */
    checkForUpdates() {
      if (!this.isUpdaterActive()) {
        return Promise.resolve(null);
      }
      let checkForUpdatesPromise = this.checkForUpdatesPromise;
      if (checkForUpdatesPromise != null) {
        this._logger.info("Checking for update (already in progress)");
        return checkForUpdatesPromise;
      }
      const nullizePromise = () => this.checkForUpdatesPromise = null;
      this._logger.info("Checking for update");
      checkForUpdatesPromise = this.doCheckForUpdates().then((it) => {
        nullizePromise();
        return it;
      }).catch((e) => {
        nullizePromise();
        this.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
        throw e;
      });
      this.checkForUpdatesPromise = checkForUpdatesPromise;
      return checkForUpdatesPromise;
    }
    isUpdaterActive() {
      const isEnabled = this.app.isPackaged || this.forceDevUpdateConfig;
      if (!isEnabled) {
        this._logger.info("Skip checkForUpdates because application is not packed and dev update config is not forced");
        return false;
      }
      return true;
    }
    // noinspection JSUnusedGlobalSymbols
    checkForUpdatesAndNotify(downloadNotification) {
      return this.checkForUpdates().then((it) => {
        if (!(it === null || it === void 0 ? void 0 : it.downloadPromise)) {
          if (this._logger.debug != null) {
            this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null");
          }
          return it;
        }
        void it.downloadPromise.then(() => {
          const notificationContent = AppUpdater2.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);
          new require$$1$7.Notification(notificationContent).show();
        });
        return it;
      });
    }
    static formatDownloadNotification(version2, appName, downloadNotification) {
      if (downloadNotification == null) {
        downloadNotification = {
          title: "A new update is ready to install",
          body: `{appName} version {version} has been downloaded and will be automatically installed on exit`
        };
      }
      downloadNotification = {
        title: downloadNotification.title.replace("{appName}", appName).replace("{version}", version2),
        body: downloadNotification.body.replace("{appName}", appName).replace("{version}", version2)
      };
      return downloadNotification;
    }
    async isStagingMatch(updateInfo) {
      const rawStagingPercentage = updateInfo.stagingPercentage;
      let stagingPercentage = rawStagingPercentage;
      if (stagingPercentage == null) {
        return true;
      }
      stagingPercentage = parseInt(stagingPercentage, 10);
      if (isNaN(stagingPercentage)) {
        this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
        return true;
      }
      stagingPercentage = stagingPercentage / 100;
      const stagingUserId = await this.stagingUserIdPromise.value;
      const val = builder_util_runtime_1.UUID.parse(stagingUserId).readUInt32BE(12);
      const percentage = val / 4294967295;
      this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
      return percentage < stagingPercentage;
    }
    computeFinalHeaders(headers) {
      if (this.requestHeaders != null) {
        Object.assign(headers, this.requestHeaders);
      }
      return headers;
    }
    async isUpdateAvailable(updateInfo) {
      const latestVersion = (0, semver_1.parse)(updateInfo.version);
      if (latestVersion == null) {
        throw (0, builder_util_runtime_1.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${updateInfo.version}"`, "ERR_UPDATER_INVALID_VERSION");
      }
      const currentVersion = this.currentVersion;
      if ((0, semver_1.eq)(latestVersion, currentVersion)) {
        return false;
      }
      const minimumSystemVersion = updateInfo === null || updateInfo === void 0 ? void 0 : updateInfo.minimumSystemVersion;
      const currentOSVersion = (0, os_1.release)();
      if (minimumSystemVersion) {
        try {
          if ((0, semver_1.lt)(currentOSVersion, minimumSystemVersion)) {
            this._logger.info(`Current OS version ${currentOSVersion} is less than the minimum OS version required ${minimumSystemVersion} for version ${currentOSVersion}`);
            return false;
          }
        } catch (e) {
          this._logger.warn(`Failed to compare current OS version(${currentOSVersion}) with minimum OS version(${minimumSystemVersion}): ${(e.message || e).toString()}`);
        }
      }
      const isStagingMatch = await this.isStagingMatch(updateInfo);
      if (!isStagingMatch) {
        return false;
      }
      const isLatestVersionNewer = (0, semver_1.gt)(latestVersion, currentVersion);
      const isLatestVersionOlder = (0, semver_1.lt)(latestVersion, currentVersion);
      if (isLatestVersionNewer) {
        return true;
      }
      return this.allowDowngrade && isLatestVersionOlder;
    }
    async getUpdateInfoAndProvider() {
      await this.app.whenReady();
      if (this.clientPromise == null) {
        this.clientPromise = this.configOnDisk.value.then((it) => (0, providerFactory_1.createClient)(it, this, this.createProviderRuntimeOptions()));
      }
      const client = await this.clientPromise;
      const stagingUserId = await this.stagingUserIdPromise.value;
      client.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": stagingUserId }));
      return {
        info: await client.getLatestVersion(),
        provider: client
      };
    }
    createProviderRuntimeOptions() {
      return {
        isUseMultipleRangeRequest: true,
        platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
        executor: this.httpExecutor
      };
    }
    async doCheckForUpdates() {
      this.emit("checking-for-update");
      const result = await this.getUpdateInfoAndProvider();
      const updateInfo = result.info;
      if (!await this.isUpdateAvailable(updateInfo)) {
        this._logger.info(`Update for version ${this.currentVersion.format()} is not available (latest version: ${updateInfo.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`);
        this.emit("update-not-available", updateInfo);
        return {
          versionInfo: updateInfo,
          updateInfo
        };
      }
      this.updateInfoAndProvider = result;
      this.onUpdateAvailable(updateInfo);
      const cancellationToken = new builder_util_runtime_1.CancellationToken();
      return {
        versionInfo: updateInfo,
        updateInfo,
        cancellationToken,
        downloadPromise: this.autoDownload ? this.downloadUpdate(cancellationToken) : null
      };
    }
    onUpdateAvailable(updateInfo) {
      this._logger.info(`Found version ${updateInfo.version} (url: ${(0, builder_util_runtime_1.asArray)(updateInfo.files).map((it) => it.url).join(", ")})`);
      this.emit("update-available", updateInfo);
    }
    /**
     * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
     * @returns {Promise<Array<string>>} Paths to downloaded files.
     */
    downloadUpdate(cancellationToken = new builder_util_runtime_1.CancellationToken()) {
      const updateInfoAndProvider = this.updateInfoAndProvider;
      if (updateInfoAndProvider == null) {
        const error2 = new Error("Please check update first");
        this.dispatchError(error2);
        return Promise.reject(error2);
      }
      if (this.downloadPromise != null) {
        this._logger.info("Downloading update (already in progress)");
        return this.downloadPromise;
      }
      this._logger.info(`Downloading update from ${(0, builder_util_runtime_1.asArray)(updateInfoAndProvider.info.files).map((it) => it.url).join(", ")}`);
      const errorHandler = (e) => {
        if (!(e instanceof builder_util_runtime_1.CancellationError)) {
          try {
            this.dispatchError(e);
          } catch (nestedError) {
            this._logger.warn(`Cannot dispatch error event: ${nestedError.stack || nestedError}`);
          }
        }
        return e;
      };
      this.downloadPromise = this.doDownloadUpdate({
        updateInfoAndProvider,
        requestHeaders: this.computeRequestHeaders(updateInfoAndProvider.provider),
        cancellationToken,
        disableWebInstaller: this.disableWebInstaller,
        disableDifferentialDownload: this.disableDifferentialDownload
      }).catch((e) => {
        throw errorHandler(e);
      }).finally(() => {
        this.downloadPromise = null;
      });
      return this.downloadPromise;
    }
    dispatchError(e) {
      this.emit("error", e, (e.stack || e).toString());
    }
    dispatchUpdateDownloaded(event) {
      this.emit(main_1.UPDATE_DOWNLOADED, event);
    }
    async loadUpdateConfig() {
      if (this._appUpdateConfigPath == null) {
        this._appUpdateConfigPath = this.app.appUpdateConfigPath;
      }
      return (0, js_yaml_1.load)(await (0, fs_extra_1.readFile)(this._appUpdateConfigPath, "utf-8"));
    }
    computeRequestHeaders(provider) {
      const fileExtraDownloadHeaders = provider.fileExtraDownloadHeaders;
      if (fileExtraDownloadHeaders != null) {
        const requestHeaders = this.requestHeaders;
        return requestHeaders == null ? fileExtraDownloadHeaders : {
          ...fileExtraDownloadHeaders,
          ...requestHeaders
        };
      }
      return this.computeFinalHeaders({ accept: "*/*" });
    }
    async getOrCreateStagingUserId() {
      const file2 = path.join(this.app.userDataPath, ".updaterId");
      try {
        const id2 = await (0, fs_extra_1.readFile)(file2, "utf-8");
        if (builder_util_runtime_1.UUID.check(id2)) {
          return id2;
        } else {
          this._logger.warn(`Staging user id file exists, but content was invalid: ${id2}`);
        }
      } catch (e) {
        if (e.code !== "ENOENT") {
          this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
        }
      }
      const id = builder_util_runtime_1.UUID.v5((0, crypto_1.randomBytes)(4096), builder_util_runtime_1.UUID.OID);
      this._logger.info(`Generated new staging user ID: ${id}`);
      try {
        await (0, fs_extra_1.outputFile)(file2, id);
      } catch (e) {
        this._logger.warn(`Couldn't write out staging user ID: ${e}`);
      }
      return id;
    }
    /** @internal */
    get isAddNoCacheQuery() {
      const headers = this.requestHeaders;
      if (headers == null) {
        return true;
      }
      for (const headerName of Object.keys(headers)) {
        const s = headerName.toLowerCase();
        if (s === "authorization" || s === "private-token") {
          return false;
        }
      }
      return true;
    }
    async getOrCreateDownloadHelper() {
      let result = this.downloadedUpdateHelper;
      if (result == null) {
        const dirName = (await this.configOnDisk.value).updaterCacheDirName;
        const logger = this._logger;
        if (dirName == null) {
          logger.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
        }
        const cacheDir = path.join(this.app.baseCachePath, dirName || this.app.name);
        if (logger.debug != null) {
          logger.debug(`updater cache dir: ${cacheDir}`);
        }
        result = new DownloadedUpdateHelper_1.DownloadedUpdateHelper(cacheDir);
        this.downloadedUpdateHelper = result;
      }
      return result;
    }
    async executeDownload(taskOptions) {
      const fileInfo = taskOptions.fileInfo;
      const downloadOptions = {
        headers: taskOptions.downloadUpdateOptions.requestHeaders,
        cancellationToken: taskOptions.downloadUpdateOptions.cancellationToken,
        sha2: fileInfo.info.sha2,
        sha512: fileInfo.info.sha512
      };
      if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
      }
      const updateInfo = taskOptions.downloadUpdateOptions.updateInfoAndProvider.info;
      const version2 = updateInfo.version;
      const packageInfo = fileInfo.packageInfo;
      function getCacheUpdateFileName() {
        const urlPath = decodeURIComponent(taskOptions.fileInfo.url.pathname);
        if (urlPath.endsWith(`.${taskOptions.fileExtension}`)) {
          return path.basename(urlPath);
        } else {
          return taskOptions.fileInfo.info.url;
        }
      }
      const downloadedUpdateHelper = await this.getOrCreateDownloadHelper();
      const cacheDir = downloadedUpdateHelper.cacheDirForPendingUpdate;
      await (0, fs_extra_1.mkdir)(cacheDir, { recursive: true });
      const updateFileName = getCacheUpdateFileName();
      let updateFile = path.join(cacheDir, updateFileName);
      const packageFile = packageInfo == null ? null : path.join(cacheDir, `package-${version2}${path.extname(packageInfo.path) || ".7z"}`);
      const done = async (isSaveCache) => {
        await downloadedUpdateHelper.setDownloadedFile(updateFile, packageFile, updateInfo, fileInfo, updateFileName, isSaveCache);
        await taskOptions.done({
          ...updateInfo,
          downloadedFile: updateFile
        });
        return packageFile == null ? [updateFile] : [updateFile, packageFile];
      };
      const log2 = this._logger;
      const cachedUpdateFile = await downloadedUpdateHelper.validateDownloadedPath(updateFile, updateInfo, fileInfo, log2);
      if (cachedUpdateFile != null) {
        updateFile = cachedUpdateFile;
        return await done(false);
      }
      const removeFileIfAny = async () => {
        await downloadedUpdateHelper.clear().catch(() => {
        });
        return await (0, fs_extra_1.unlink)(updateFile).catch(() => {
        });
      };
      const tempUpdateFile = await (0, DownloadedUpdateHelper_1.createTempUpdateFile)(`temp-${updateFileName}`, cacheDir, log2);
      try {
        await taskOptions.task(tempUpdateFile, downloadOptions, packageFile, removeFileIfAny);
        await (0, builder_util_runtime_1.retry)(() => (0, fs_extra_1.rename)(tempUpdateFile, updateFile), 60, 500, 0, 0, (error2) => error2 instanceof Error && /^EBUSY:/.test(error2.message));
      } catch (e) {
        await removeFileIfAny();
        if (e instanceof builder_util_runtime_1.CancellationError) {
          log2.info("cancelled");
          this.emit("update-cancelled", updateInfo);
        }
        throw e;
      }
      log2.info(`New version ${version2} has been downloaded to ${updateFile}`);
      return await done(true);
    }
    async differentialDownloadInstaller(fileInfo, downloadUpdateOptions, installerPath, provider, oldInstallerFileName) {
      try {
        if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {
          return true;
        }
        const blockmapFileUrls = (0, util_1.blockmapFiles)(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version);
        this._logger.info(`Download block maps (old: "${blockmapFileUrls[0]}", new: ${blockmapFileUrls[1]})`);
        const downloadBlockMap = async (url) => {
          const data = await this.httpExecutor.downloadToBuffer(url, {
            headers: downloadUpdateOptions.requestHeaders,
            cancellationToken: downloadUpdateOptions.cancellationToken
          });
          if (data == null || data.length === 0) {
            throw new Error(`Blockmap "${url.href}" is empty`);
          }
          try {
            return JSON.parse((0, zlib_1.gunzipSync)(data).toString());
          } catch (e) {
            throw new Error(`Cannot parse blockmap "${url.href}", error: ${e}`);
          }
        };
        const downloadOptions = {
          newUrl: fileInfo.url,
          oldFile: path.join(this.downloadedUpdateHelper.cacheDir, oldInstallerFileName),
          logger: this._logger,
          newFile: installerPath,
          isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
          requestHeaders: downloadUpdateOptions.requestHeaders,
          cancellationToken: downloadUpdateOptions.cancellationToken
        };
        if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
        }
        const blockMapDataList = await Promise.all(blockmapFileUrls.map((u) => downloadBlockMap(u)));
        await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1]);
        return false;
      } catch (e) {
        this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
        if (this._testOnlyOptions != null) {
          throw e;
        }
        return true;
      }
    }
  };
  AppUpdater.AppUpdater = AppUpdater$1;
  function hasPrereleaseComponents(version2) {
    const versionPrereleaseComponent = (0, semver_1.prerelease)(version2);
    return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
  }
  class NoOpLogger {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    info(message) {
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    warn(message) {
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    error(message) {
    }
  }
  AppUpdater.NoOpLogger = NoOpLogger;
  return AppUpdater;
}
var hasRequiredBaseUpdater;
function requireBaseUpdater() {
  if (hasRequiredBaseUpdater) return BaseUpdater;
  hasRequiredBaseUpdater = 1;
  Object.defineProperty(BaseUpdater, "__esModule", { value: true });
  BaseUpdater.BaseUpdater = void 0;
  const child_process_1 = require$$1$8;
  const AppUpdater_1 = requireAppUpdater();
  let BaseUpdater$1 = class BaseUpdater extends AppUpdater_1.AppUpdater {
    constructor(options, app2) {
      super(options, app2);
      this.quitAndInstallCalled = false;
      this.quitHandlerAdded = false;
    }
    quitAndInstall(isSilent = false, isForceRunAfter = false) {
      this._logger.info(`Install on explicit quitAndInstall`);
      const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : this.autoRunAppAfterInstall);
      if (isInstalled) {
        setImmediate(() => {
          require$$1$7.autoUpdater.emit("before-quit-for-update");
          this.app.quit();
        });
      } else {
        this.quitAndInstallCalled = false;
      }
    }
    executeDownload(taskOptions) {
      return super.executeDownload({
        ...taskOptions,
        done: (event) => {
          this.dispatchUpdateDownloaded(event);
          this.addQuitHandler();
          return Promise.resolve();
        }
      });
    }
    // must be sync (because quit even handler is not async)
    install(isSilent = false, isForceRunAfter = false) {
      if (this.quitAndInstallCalled) {
        this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
        return false;
      }
      const downloadedUpdateHelper = this.downloadedUpdateHelper;
      const installerPath = downloadedUpdateHelper && downloadedUpdateHelper.file ? process.platform === "linux" ? downloadedUpdateHelper.file.replace(/ /g, "\\ ") : downloadedUpdateHelper.file : null;
      const downloadedFileInfo = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.downloadedFileInfo;
      if (installerPath == null || downloadedFileInfo == null) {
        this.dispatchError(new Error("No valid update available, can't quit and install"));
        return false;
      }
      this.quitAndInstallCalled = true;
      try {
        this._logger.info(`Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}`);
        return this.doInstall({
          installerPath,
          isSilent,
          isForceRunAfter,
          isAdminRightsRequired: downloadedFileInfo.isAdminRightsRequired
        });
      } catch (e) {
        this.dispatchError(e);
        return false;
      }
    }
    addQuitHandler() {
      if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {
        return;
      }
      this.quitHandlerAdded = true;
      this.app.onQuit((exitCode) => {
        if (this.quitAndInstallCalled) {
          this._logger.info("Update installer has already been triggered. Quitting application.");
          return;
        }
        if (!this.autoInstallOnAppQuit) {
          this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
          return;
        }
        if (exitCode !== 0) {
          this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);
          return;
        }
        this._logger.info("Auto install update on quit");
        this.install(true, false);
      });
    }
    wrapSudo() {
      const { name } = this.app;
      const installComment = `"${name} would like to update"`;
      const sudo = this.spawnSyncLog("which gksudo || which kdesudo || which pkexec || which beesu");
      const command2 = [sudo];
      if (/kdesudo/i.test(sudo)) {
        command2.push("--comment", installComment);
        command2.push("-c");
      } else if (/gksudo/i.test(sudo)) {
        command2.push("--message", installComment);
      } else if (/pkexec/i.test(sudo)) {
        command2.push("--disable-internal-agent");
      }
      return command2.join(" ");
    }
    spawnSyncLog(cmd, args = [], env = {}) {
      this._logger.info(`Executing: ${cmd} with args: ${args}`);
      const response = (0, child_process_1.spawnSync)(cmd, args, {
        env: { ...process.env, ...env },
        encoding: "utf-8",
        shell: true
      });
      return response.stdout.trim();
    }
    /**
     * This handles both node 8 and node 10 way of emitting error when spawning a process
     *   - node 8: Throws the error
     *   - node 10: Emit the error(Need to listen with on)
     */
    // https://github.com/electron-userland/electron-builder/issues/1129
    // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors
    async spawnLog(cmd, args = [], env = void 0, stdio = "ignore") {
      this._logger.info(`Executing: ${cmd} with args: ${args}`);
      return new Promise((resolve, reject) => {
        try {
          const params = { stdio, env, detached: true };
          const p = (0, child_process_1.spawn)(cmd, args, params);
          p.on("error", (error2) => {
            reject(error2);
          });
          p.unref();
          if (p.pid !== void 0) {
            resolve(true);
          }
        } catch (error2) {
          reject(error2);
        }
      });
    }
  };
  BaseUpdater.BaseUpdater = BaseUpdater$1;
  return BaseUpdater;
}
var AppImageUpdater = {};
var FileWithEmbeddedBlockMapDifferentialDownloader = {};
var hasRequiredFileWithEmbeddedBlockMapDifferentialDownloader;
function requireFileWithEmbeddedBlockMapDifferentialDownloader() {
  if (hasRequiredFileWithEmbeddedBlockMapDifferentialDownloader) return FileWithEmbeddedBlockMapDifferentialDownloader;
  hasRequiredFileWithEmbeddedBlockMapDifferentialDownloader = 1;
  Object.defineProperty(FileWithEmbeddedBlockMapDifferentialDownloader, "__esModule", { value: true });
  FileWithEmbeddedBlockMapDifferentialDownloader.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
  const fs_extra_1 = /* @__PURE__ */ requireLib();
  const DifferentialDownloader_1 = requireDifferentialDownloader();
  const zlib_1 = require$$0$2;
  let FileWithEmbeddedBlockMapDifferentialDownloader$1 = class FileWithEmbeddedBlockMapDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
    async download() {
      const packageInfo = this.blockAwareFileInfo;
      const fileSize = packageInfo.size;
      const offset = fileSize - (packageInfo.blockMapSize + 4);
      this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);
      const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
      await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);
    }
  };
  FileWithEmbeddedBlockMapDifferentialDownloader.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader$1;
  function readBlockMap(data) {
    return JSON.parse((0, zlib_1.inflateRawSync)(data).toString());
  }
  async function readEmbeddedBlockMapData(file2) {
    const fd = await (0, fs_extra_1.open)(file2, "r");
    try {
      const fileSize = (await (0, fs_extra_1.fstat)(fd)).size;
      const sizeBuffer = Buffer.allocUnsafe(4);
      await (0, fs_extra_1.read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
      const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
      await (0, fs_extra_1.read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
      await (0, fs_extra_1.close)(fd);
      return readBlockMap(dataBuffer);
    } catch (e) {
      await (0, fs_extra_1.close)(fd);
      throw e;
    }
  }
  return FileWithEmbeddedBlockMapDifferentialDownloader;
}
var hasRequiredAppImageUpdater;
function requireAppImageUpdater() {
  if (hasRequiredAppImageUpdater) return AppImageUpdater;
  hasRequiredAppImageUpdater = 1;
  Object.defineProperty(AppImageUpdater, "__esModule", { value: true });
  AppImageUpdater.AppImageUpdater = void 0;
  const builder_util_runtime_1 = requireOut();
  const child_process_1 = require$$1$8;
  const fs_extra_1 = /* @__PURE__ */ requireLib();
  const fs_1 = require$$1$2;
  const path = require$$1$1;
  const BaseUpdater_1 = requireBaseUpdater();
  const FileWithEmbeddedBlockMapDifferentialDownloader_1 = requireFileWithEmbeddedBlockMapDifferentialDownloader();
  const main_1 = requireMain$1();
  const Provider_1 = requireProvider();
  let AppImageUpdater$1 = class AppImageUpdater extends BaseUpdater_1.BaseUpdater {
    constructor(options, app2) {
      super(options, app2);
    }
    isUpdaterActive() {
      if (process.env["APPIMAGE"] == null) {
        if (process.env["SNAP"] == null) {
          this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
        } else {
          this._logger.info("SNAP env is defined, updater is disabled");
        }
        return false;
      }
      return super.isUpdaterActive();
    }
    /*** @private */
    doDownloadUpdate(downloadUpdateOptions) {
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "AppImage", ["rpm", "deb"]);
      return this.executeDownload({
        fileExtension: "AppImage",
        fileInfo,
        downloadUpdateOptions,
        task: async (updateFile, downloadOptions) => {
          const oldFile = process.env["APPIMAGE"];
          if (oldFile == null) {
            throw (0, builder_util_runtime_1.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
          }
          let isDownloadFull = false;
          try {
            const downloadOptions2 = {
              newUrl: fileInfo.url,
              oldFile,
              logger: this._logger,
              newFile: updateFile,
              isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
              requestHeaders: downloadUpdateOptions.requestHeaders,
              cancellationToken: downloadUpdateOptions.cancellationToken
            };
            if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
              downloadOptions2.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
            }
            await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions2).download();
          } catch (e) {
            this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
            isDownloadFull = process.platform === "linux";
          }
          if (isDownloadFull) {
            await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
          }
          await (0, fs_extra_1.chmod)(updateFile, 493);
        }
      });
    }
    doInstall(options) {
      const appImageFile = process.env["APPIMAGE"];
      if (appImageFile == null) {
        throw (0, builder_util_runtime_1.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
      }
      (0, fs_1.unlinkSync)(appImageFile);
      let destination;
      const existingBaseName = path.basename(appImageFile);
      if (path.basename(options.installerPath) === existingBaseName || !/\d+\.\d+\.\d+/.test(existingBaseName)) {
        destination = appImageFile;
      } else {
        destination = path.join(path.dirname(appImageFile), path.basename(options.installerPath));
      }
      (0, child_process_1.execFileSync)("mv", ["-f", options.installerPath, destination]);
      if (destination !== appImageFile) {
        this.emit("appimage-filename-updated", destination);
      }
      const env = {
        ...process.env,
        APPIMAGE_SILENT_INSTALL: "true"
      };
      if (options.isForceRunAfter) {
        this.spawnLog(destination, [], env);
      } else {
        env.APPIMAGE_EXIT_AFTER_INSTALL = "true";
        (0, child_process_1.execFileSync)(destination, [], { env });
      }
      return true;
    }
  };
  AppImageUpdater.AppImageUpdater = AppImageUpdater$1;
  return AppImageUpdater;
}
var DebUpdater = {};
var hasRequiredDebUpdater;
function requireDebUpdater() {
  if (hasRequiredDebUpdater) return DebUpdater;
  hasRequiredDebUpdater = 1;
  Object.defineProperty(DebUpdater, "__esModule", { value: true });
  DebUpdater.DebUpdater = void 0;
  const BaseUpdater_1 = requireBaseUpdater();
  const main_1 = requireMain$1();
  const Provider_1 = requireProvider();
  let DebUpdater$1 = class DebUpdater extends BaseUpdater_1.BaseUpdater {
    constructor(options, app2) {
      super(options, app2);
    }
    /*** @private */
    doDownloadUpdate(downloadUpdateOptions) {
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "deb", ["AppImage", "rpm"]);
      return this.executeDownload({
        fileExtension: "deb",
        fileInfo,
        downloadUpdateOptions,
        task: async (updateFile, downloadOptions) => {
          if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
            downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
          }
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
      });
    }
    doInstall(options) {
      const sudo = this.wrapSudo();
      const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
      const cmd = ["dpkg", "-i", options.installerPath, "||", "apt-get", "install", "-f", "-y"];
      this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
      if (options.isForceRunAfter) {
        this.app.relaunch();
      }
      return true;
    }
  };
  DebUpdater.DebUpdater = DebUpdater$1;
  return DebUpdater;
}
var RpmUpdater = {};
var hasRequiredRpmUpdater;
function requireRpmUpdater() {
  if (hasRequiredRpmUpdater) return RpmUpdater;
  hasRequiredRpmUpdater = 1;
  Object.defineProperty(RpmUpdater, "__esModule", { value: true });
  RpmUpdater.RpmUpdater = void 0;
  const BaseUpdater_1 = requireBaseUpdater();
  const main_1 = requireMain$1();
  const Provider_1 = requireProvider();
  let RpmUpdater$1 = class RpmUpdater extends BaseUpdater_1.BaseUpdater {
    constructor(options, app2) {
      super(options, app2);
    }
    /*** @private */
    doDownloadUpdate(downloadUpdateOptions) {
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "rpm", ["AppImage", "deb"]);
      return this.executeDownload({
        fileExtension: "rpm",
        fileInfo,
        downloadUpdateOptions,
        task: async (updateFile, downloadOptions) => {
          if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
            downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
          }
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
      });
    }
    doInstall(options) {
      const upgradePath = options.installerPath;
      const sudo = this.wrapSudo();
      const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
      const packageManager = this.spawnSyncLog("which zypper");
      let cmd;
      if (!packageManager) {
        const packageManager2 = this.spawnSyncLog("which dnf || which yum");
        cmd = [packageManager2, "-y", "install", upgradePath];
      } else {
        cmd = [packageManager, "--no-refresh", "install", "--allow-unsigned-rpm", "-y", "-f", upgradePath];
      }
      this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
      if (options.isForceRunAfter) {
        this.app.relaunch();
      }
      return true;
    }
  };
  RpmUpdater.RpmUpdater = RpmUpdater$1;
  return RpmUpdater;
}
var MacUpdater = {};
var hasRequiredMacUpdater;
function requireMacUpdater() {
  if (hasRequiredMacUpdater) return MacUpdater;
  hasRequiredMacUpdater = 1;
  Object.defineProperty(MacUpdater, "__esModule", { value: true });
  MacUpdater.MacUpdater = void 0;
  const builder_util_runtime_1 = requireOut();
  const fs_extra_1 = /* @__PURE__ */ requireLib();
  const fs_1 = require$$1$2;
  const path = require$$1$1;
  const http_1 = require$$4$3;
  const AppUpdater_1 = requireAppUpdater();
  const Provider_1 = requireProvider();
  const child_process_1 = require$$1$8;
  const crypto_1 = require$$1$3;
  let MacUpdater$1 = class MacUpdater extends AppUpdater_1.AppUpdater {
    constructor(options, app2) {
      super(options, app2);
      this.nativeUpdater = require$$1$7.autoUpdater;
      this.squirrelDownloadedUpdate = false;
      this.nativeUpdater.on("error", (it) => {
        this._logger.warn(it);
        this.emit("error", it);
      });
      this.nativeUpdater.on("update-downloaded", () => {
        this.squirrelDownloadedUpdate = true;
        this.debug("nativeUpdater.update-downloaded");
      });
    }
    debug(message) {
      if (this._logger.debug != null) {
        this._logger.debug(message);
      }
    }
    closeServerIfExists() {
      if (this.server) {
        this.debug("Closing proxy server");
        this.server.close((err) => {
          if (err) {
            this.debug("proxy server wasn't already open, probably attempted closing again as a safety check before quit");
          }
        });
      }
    }
    async doDownloadUpdate(downloadUpdateOptions) {
      let files = downloadUpdateOptions.updateInfoAndProvider.provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info);
      const log2 = this._logger;
      const sysctlRosettaInfoKey = "sysctl.proc_translated";
      let isRosetta = false;
      try {
        this.debug("Checking for macOS Rosetta environment");
        const result = (0, child_process_1.execFileSync)("sysctl", [sysctlRosettaInfoKey], { encoding: "utf8" });
        isRosetta = result.includes(`${sysctlRosettaInfoKey}: 1`);
        log2.info(`Checked for macOS Rosetta environment (isRosetta=${isRosetta})`);
      } catch (e) {
        log2.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${e}`);
      }
      let isArm64Mac = false;
      try {
        this.debug("Checking for arm64 in uname");
        const result = (0, child_process_1.execFileSync)("uname", ["-a"], { encoding: "utf8" });
        const isArm = result.includes("ARM");
        log2.info(`Checked 'uname -a': arm64=${isArm}`);
        isArm64Mac = isArm64Mac || isArm;
      } catch (e) {
        log2.warn(`uname shell command to check for arm64 failed: ${e}`);
      }
      isArm64Mac = isArm64Mac || process.arch === "arm64" || isRosetta;
      const isArm64 = (file2) => {
        var _a;
        return file2.url.pathname.includes("arm64") || ((_a = file2.info.url) === null || _a === void 0 ? void 0 : _a.includes("arm64"));
      };
      if (isArm64Mac && files.some(isArm64)) {
        files = files.filter((file2) => isArm64Mac === isArm64(file2));
      } else {
        files = files.filter((file2) => !isArm64(file2));
      }
      const zipFileInfo = (0, Provider_1.findFile)(files, "zip", ["pkg", "dmg"]);
      if (zipFileInfo == null) {
        throw (0, builder_util_runtime_1.newError)(`ZIP file not provided: ${(0, builder_util_runtime_1.safeStringifyJson)(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
      }
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const CURRENT_MAC_APP_ZIP_FILE_NAME = "update.zip";
      return this.executeDownload({
        fileExtension: "zip",
        fileInfo: zipFileInfo,
        downloadUpdateOptions,
        task: async (destinationFile, downloadOptions) => {
          const cachedUpdateFilePath = path.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);
          const canDifferentialDownload = () => {
            if (!(0, fs_extra_1.pathExistsSync)(cachedUpdateFilePath)) {
              log2.info("Unable to locate previous update.zip for differential download (is this first install?), falling back to full download");
              return false;
            }
            return !downloadUpdateOptions.disableDifferentialDownload;
          };
          let differentialDownloadFailed = true;
          if (canDifferentialDownload()) {
            differentialDownloadFailed = await this.differentialDownloadInstaller(zipFileInfo, downloadUpdateOptions, destinationFile, provider, CURRENT_MAC_APP_ZIP_FILE_NAME);
          }
          if (differentialDownloadFailed) {
            await this.httpExecutor.download(zipFileInfo.url, destinationFile, downloadOptions);
          }
        },
        done: (event) => {
          if (!downloadUpdateOptions.disableDifferentialDownload) {
            try {
              const cachedUpdateFilePath = path.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);
              (0, fs_1.copyFileSync)(event.downloadedFile, cachedUpdateFilePath);
            } catch (error2) {
              this._logger.warn(`Unable to copy file for caching for future differential downloads: ${error2.message}`);
            }
          }
          return this.updateDownloaded(zipFileInfo, event);
        }
      });
    }
    async updateDownloaded(zipFileInfo, event) {
      var _a;
      const downloadedFile = event.downloadedFile;
      const updateFileSize = (_a = zipFileInfo.info.size) !== null && _a !== void 0 ? _a : (await (0, fs_extra_1.stat)(downloadedFile)).size;
      const log2 = this._logger;
      const logContext = `fileToProxy=${zipFileInfo.url.href}`;
      this.closeServerIfExists();
      this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);
      this.server = (0, http_1.createServer)();
      this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);
      this.server.on("close", () => {
        log2.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);
      });
      const getServerUrl = (s) => {
        const address = s.address();
        if (typeof address === "string") {
          return address;
        }
        return `http://127.0.0.1:${address === null || address === void 0 ? void 0 : address.port}`;
      };
      return await new Promise((resolve, reject) => {
        const pass = (0, crypto_1.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
        const authInfo = Buffer.from(`autoupdater:${pass}`, "ascii");
        const fileUrl = `/${(0, crypto_1.randomBytes)(64).toString("hex")}.zip`;
        this.server.on("request", (request, response) => {
          const requestUrl = request.url;
          log2.info(`${requestUrl} requested`);
          if (requestUrl === "/") {
            if (!request.headers.authorization || request.headers.authorization.indexOf("Basic ") === -1) {
              response.statusCode = 401;
              response.statusMessage = "Invalid Authentication Credentials";
              response.end();
              log2.warn("No authenthication info");
              return;
            }
            const base64Credentials = request.headers.authorization.split(" ")[1];
            const credentials = Buffer.from(base64Credentials, "base64").toString("ascii");
            const [username, password] = credentials.split(":");
            if (username !== "autoupdater" || password !== pass) {
              response.statusCode = 401;
              response.statusMessage = "Invalid Authentication Credentials";
              response.end();
              log2.warn("Invalid authenthication credentials");
              return;
            }
            const data = Buffer.from(`{ "url": "${getServerUrl(this.server)}${fileUrl}" }`);
            response.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
            response.end(data);
            return;
          }
          if (!requestUrl.startsWith(fileUrl)) {
            log2.warn(`${requestUrl} requested, but not supported`);
            response.writeHead(404);
            response.end();
            return;
          }
          log2.info(`${fileUrl} requested by Squirrel.Mac, pipe ${downloadedFile}`);
          let errorOccurred = false;
          response.on("finish", () => {
            if (!errorOccurred) {
              this.nativeUpdater.removeListener("error", reject);
              resolve([]);
            }
          });
          const readStream = (0, fs_1.createReadStream)(downloadedFile);
          readStream.on("error", (error2) => {
            try {
              response.end();
            } catch (e) {
              log2.warn(`cannot end response: ${e}`);
            }
            errorOccurred = true;
            this.nativeUpdater.removeListener("error", reject);
            reject(new Error(`Cannot pipe "${downloadedFile}": ${error2}`));
          });
          response.writeHead(200, {
            "Content-Type": "application/zip",
            "Content-Length": updateFileSize
          });
          readStream.pipe(response);
        });
        this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${logContext})`);
        this.server.listen(0, "127.0.0.1", () => {
          this.debug(`Proxy server for native Squirrel.Mac is listening (address=${getServerUrl(this.server)}, ${logContext})`);
          this.nativeUpdater.setFeedURL({
            url: getServerUrl(this.server),
            headers: {
              "Cache-Control": "no-cache",
              Authorization: `Basic ${authInfo.toString("base64")}`
            }
          });
          this.dispatchUpdateDownloaded(event);
          if (this.autoInstallOnAppQuit) {
            this.nativeUpdater.once("error", reject);
            this.nativeUpdater.checkForUpdates();
          } else {
            resolve([]);
          }
        });
      });
    }
    quitAndInstall() {
      if (this.squirrelDownloadedUpdate) {
        this.nativeUpdater.quitAndInstall();
        this.closeServerIfExists();
      } else {
        this.nativeUpdater.on("update-downloaded", () => {
          this.nativeUpdater.quitAndInstall();
          this.closeServerIfExists();
        });
        if (!this.autoInstallOnAppQuit) {
          this.nativeUpdater.checkForUpdates();
        }
      }
    }
  };
  MacUpdater.MacUpdater = MacUpdater$1;
  return MacUpdater;
}
var NsisUpdater = {};
var windowsExecutableCodeSignatureVerifier = {};
var hasRequiredWindowsExecutableCodeSignatureVerifier;
function requireWindowsExecutableCodeSignatureVerifier() {
  if (hasRequiredWindowsExecutableCodeSignatureVerifier) return windowsExecutableCodeSignatureVerifier;
  hasRequiredWindowsExecutableCodeSignatureVerifier = 1;
  Object.defineProperty(windowsExecutableCodeSignatureVerifier, "__esModule", { value: true });
  windowsExecutableCodeSignatureVerifier.verifySignature = verifySignature;
  const builder_util_runtime_1 = requireOut();
  const child_process_1 = require$$1$8;
  const os = require$$2$1;
  const path = require$$1$1;
  function verifySignature(publisherNames, unescapedTempUpdateFile, logger) {
    return new Promise((resolve, reject) => {
      const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, "''");
      logger.info(`Verifying signature ${tempUpdateFile}`);
      (0, child_process_1.execFile)(`set "PSModulePath=" & chcp 65001 >NUL & powershell.exe`, ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${tempUpdateFile}' | ConvertTo-Json -Compress"`], {
        shell: true,
        timeout: 20 * 1e3
      }, (error2, stdout, stderr) => {
        var _a;
        try {
          if (error2 != null || stderr) {
            handleError(logger, error2, stderr, reject);
            resolve(null);
            return;
          }
          const data = parseOut(stdout);
          if (data.Status === 0) {
            try {
              const normlaizedUpdateFilePath = path.normalize(data.Path);
              const normalizedTempUpdateFile = path.normalize(unescapedTempUpdateFile);
              logger.info(`LiteralPath: ${normlaizedUpdateFilePath}. Update Path: ${normalizedTempUpdateFile}`);
              if (normlaizedUpdateFilePath !== normalizedTempUpdateFile) {
                handleError(logger, new Error(`LiteralPath of ${normlaizedUpdateFilePath} is different than ${normalizedTempUpdateFile}`), stderr, reject);
                resolve(null);
                return;
              }
            } catch (error3) {
              logger.warn(`Unable to verify LiteralPath of update asset due to missing data.Path. Skipping this step of validation. Message: ${(_a = error3.message) !== null && _a !== void 0 ? _a : error3.stack}`);
            }
            const subject = (0, builder_util_runtime_1.parseDn)(data.SignerCertificate.Subject);
            let match = false;
            for (const name of publisherNames) {
              const dn = (0, builder_util_runtime_1.parseDn)(name);
              if (dn.size) {
                const allKeys = Array.from(dn.keys());
                match = allKeys.every((key) => {
                  return dn.get(key) === subject.get(key);
                });
              } else if (name === subject.get("CN")) {
                logger.warn(`Signature validated using only CN ${name}. Please add your full Distinguished Name (DN) to publisherNames configuration`);
                match = true;
              }
              if (match) {
                resolve(null);
                return;
              }
            }
          }
          const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? void 0 : value, 2);
          logger.warn(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
          resolve(result);
        } catch (e) {
          handleError(logger, e, null, reject);
          resolve(null);
          return;
        }
      });
    });
  }
  function parseOut(out2) {
    const data = JSON.parse(out2);
    delete data.PrivateKey;
    delete data.IsOSBinary;
    delete data.SignatureType;
    const signerCertificate = data.SignerCertificate;
    if (signerCertificate != null) {
      delete signerCertificate.Archived;
      delete signerCertificate.Extensions;
      delete signerCertificate.Handle;
      delete signerCertificate.HasPrivateKey;
      delete signerCertificate.SubjectName;
    }
    return data;
  }
  function handleError(logger, error2, stderr, reject) {
    if (isOldWin6()) {
      logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2 || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
      return;
    }
    try {
      (0, child_process_1.execFileSync)("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
    } catch (testError) {
      logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
      return;
    }
    if (error2 != null) {
      reject(error2);
    }
    if (stderr) {
      reject(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${stderr}. Failing signature validation due to unknown stderr.`));
    }
  }
  function isOldWin6() {
    const winVersion = os.release();
    return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
  }
  return windowsExecutableCodeSignatureVerifier;
}
var hasRequiredNsisUpdater;
function requireNsisUpdater() {
  if (hasRequiredNsisUpdater) return NsisUpdater;
  hasRequiredNsisUpdater = 1;
  Object.defineProperty(NsisUpdater, "__esModule", { value: true });
  NsisUpdater.NsisUpdater = void 0;
  const builder_util_runtime_1 = requireOut();
  const path = require$$1$1;
  const BaseUpdater_1 = requireBaseUpdater();
  const FileWithEmbeddedBlockMapDifferentialDownloader_1 = requireFileWithEmbeddedBlockMapDifferentialDownloader();
  const main_1 = requireMain$1();
  const Provider_1 = requireProvider();
  const fs_extra_1 = /* @__PURE__ */ requireLib();
  const windowsExecutableCodeSignatureVerifier_1 = requireWindowsExecutableCodeSignatureVerifier();
  const url_1 = require$$4$2;
  let NsisUpdater$1 = class NsisUpdater extends BaseUpdater_1.BaseUpdater {
    constructor(options, app2) {
      super(options, app2);
      this._verifyUpdateCodeSignature = (publisherNames, unescapedTempUpdateFile) => (0, windowsExecutableCodeSignatureVerifier_1.verifySignature)(publisherNames, unescapedTempUpdateFile, this._logger);
    }
    /**
     * The verifyUpdateCodeSignature. You can pass [win-verify-signature](https://github.com/beyondkmp/win-verify-trust) or another custom verify function: ` (publisherName: string[], path: string) => Promise<string | null>`.
     * The default verify function uses [windowsExecutableCodeSignatureVerifier](https://github.com/electron-userland/electron-builder/blob/master/packages/electron-updater/src/windowsExecutableCodeSignatureVerifier.ts)
     */
    get verifyUpdateCodeSignature() {
      return this._verifyUpdateCodeSignature;
    }
    set verifyUpdateCodeSignature(value) {
      if (value) {
        this._verifyUpdateCodeSignature = value;
      }
    }
    /*** @private */
    doDownloadUpdate(downloadUpdateOptions) {
      const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
      const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "exe");
      return this.executeDownload({
        fileExtension: "exe",
        downloadUpdateOptions,
        fileInfo,
        task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {
          const packageInfo = fileInfo.packageInfo;
          const isWebInstaller = packageInfo != null && packageFile != null;
          if (isWebInstaller && downloadUpdateOptions.disableWebInstaller) {
            throw (0, builder_util_runtime_1.newError)(`Unable to download new version ${downloadUpdateOptions.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
          }
          if (!isWebInstaller && !downloadUpdateOptions.disableWebInstaller) {
            this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version.");
          }
          if (isWebInstaller || downloadUpdateOptions.disableDifferentialDownload || await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider, builder_util_runtime_1.CURRENT_APP_INSTALLER_FILE_NAME)) {
            await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions);
          }
          const signatureVerificationStatus = await this.verifySignature(destinationFile);
          if (signatureVerificationStatus != null) {
            await removeTempDirIfAny();
            throw (0, builder_util_runtime_1.newError)(`New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
          }
          if (isWebInstaller) {
            if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packageFile, provider)) {
              try {
                await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {
                  headers: downloadUpdateOptions.requestHeaders,
                  cancellationToken: downloadUpdateOptions.cancellationToken,
                  sha512: packageInfo.sha512
                });
              } catch (e) {
                try {
                  await (0, fs_extra_1.unlink)(packageFile);
                } catch (_ignored) {
                }
                throw e;
              }
            }
          }
        }
      });
    }
    // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
    // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
    // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
    async verifySignature(tempUpdateFile) {
      let publisherName;
      try {
        publisherName = (await this.configOnDisk.value).publisherName;
        if (publisherName == null) {
          return null;
        }
      } catch (e) {
        if (e.code === "ENOENT") {
          return null;
        }
        throw e;
      }
      return await this._verifyUpdateCodeSignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile);
    }
    doInstall(options) {
      const args = ["--updated"];
      if (options.isSilent) {
        args.push("/S");
      }
      if (options.isForceRunAfter) {
        args.push("--force-run");
      }
      if (this.installDirectory) {
        args.push(`/D=${this.installDirectory}`);
      }
      const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
      if (packagePath != null) {
        args.push(`--package-file=${packagePath}`);
      }
      const callUsingElevation = () => {
        this.spawnLog(path.join(process.resourcesPath, "elevate.exe"), [options.installerPath].concat(args)).catch((e) => this.dispatchError(e));
      };
      if (options.isAdminRightsRequired) {
        this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe");
        callUsingElevation();
        return true;
      }
      this.spawnLog(options.installerPath, args).catch((e) => {
        const errorCode2 = e.code;
        this._logger.info(`Cannot run installer: error code: ${errorCode2}, error message: "${e.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`);
        if (errorCode2 === "UNKNOWN" || errorCode2 === "EACCES") {
          callUsingElevation();
        } else if (errorCode2 === "ENOENT") {
          require$$1$7.shell.openPath(options.installerPath).catch((err) => this.dispatchError(err));
        } else {
          this.dispatchError(e);
        }
      });
      return true;
    }
    async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {
      if (packageInfo.blockMapSize == null) {
        return true;
      }
      try {
        const downloadOptions = {
          newUrl: new url_1.URL(packageInfo.path),
          oldFile: path.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),
          logger: this._logger,
          newFile: packagePath,
          requestHeaders: this.requestHeaders,
          isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
          cancellationToken: downloadUpdateOptions.cancellationToken
        };
        if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
        }
        await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();
      } catch (e) {
        this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
        return process.platform === "win32";
      }
      return false;
    }
  };
  NsisUpdater.NsisUpdater = NsisUpdater$1;
  return NsisUpdater;
}
var hasRequiredMain$1;
function requireMain$1() {
  if (hasRequiredMain$1) return main$2;
  hasRequiredMain$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.NsisUpdater = exports.MacUpdater = exports.RpmUpdater = exports.DebUpdater = exports.AppImageUpdater = exports.Provider = exports.CancellationToken = exports.NoOpLogger = exports.AppUpdater = exports.BaseUpdater = void 0;
    const builder_util_runtime_1 = requireOut();
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return builder_util_runtime_1.CancellationToken;
    } });
    const fs_extra_1 = /* @__PURE__ */ requireLib();
    const path = require$$1$1;
    var BaseUpdater_1 = requireBaseUpdater();
    Object.defineProperty(exports, "BaseUpdater", { enumerable: true, get: function() {
      return BaseUpdater_1.BaseUpdater;
    } });
    var AppUpdater_1 = requireAppUpdater();
    Object.defineProperty(exports, "AppUpdater", { enumerable: true, get: function() {
      return AppUpdater_1.AppUpdater;
    } });
    Object.defineProperty(exports, "NoOpLogger", { enumerable: true, get: function() {
      return AppUpdater_1.NoOpLogger;
    } });
    var Provider_1 = requireProvider();
    Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
      return Provider_1.Provider;
    } });
    var AppImageUpdater_1 = requireAppImageUpdater();
    Object.defineProperty(exports, "AppImageUpdater", { enumerable: true, get: function() {
      return AppImageUpdater_1.AppImageUpdater;
    } });
    var DebUpdater_1 = requireDebUpdater();
    Object.defineProperty(exports, "DebUpdater", { enumerable: true, get: function() {
      return DebUpdater_1.DebUpdater;
    } });
    var RpmUpdater_1 = requireRpmUpdater();
    Object.defineProperty(exports, "RpmUpdater", { enumerable: true, get: function() {
      return RpmUpdater_1.RpmUpdater;
    } });
    var MacUpdater_1 = requireMacUpdater();
    Object.defineProperty(exports, "MacUpdater", { enumerable: true, get: function() {
      return MacUpdater_1.MacUpdater;
    } });
    var NsisUpdater_1 = requireNsisUpdater();
    Object.defineProperty(exports, "NsisUpdater", { enumerable: true, get: function() {
      return NsisUpdater_1.NsisUpdater;
    } });
    let _autoUpdater;
    function doLoadAutoUpdater() {
      if (process.platform === "win32") {
        _autoUpdater = new (requireNsisUpdater()).NsisUpdater();
      } else if (process.platform === "darwin") {
        _autoUpdater = new (requireMacUpdater()).MacUpdater();
      } else {
        _autoUpdater = new (requireAppImageUpdater()).AppImageUpdater();
        try {
          const identity = path.join(process.resourcesPath, "package-type");
          if (!(0, fs_extra_1.existsSync)(identity)) {
            return _autoUpdater;
          }
          console.info("Checking for beta autoupdate feature for deb/rpm distributions");
          const fileType = (0, fs_extra_1.readFileSync)(identity).toString().trim();
          console.info("Found package-type:", fileType);
          switch (fileType) {
            case "deb":
              _autoUpdater = new (requireDebUpdater()).DebUpdater();
              break;
            case "rpm":
              _autoUpdater = new (requireRpmUpdater()).RpmUpdater();
              break;
            default:
              break;
          }
        } catch (error2) {
          console.warn("Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder", error2.message);
        }
      }
      return _autoUpdater;
    }
    Object.defineProperty(exports, "autoUpdater", {
      enumerable: true,
      get: () => {
        return _autoUpdater || doLoadAutoUpdater();
      }
    });
    exports.DOWNLOAD_PROGRESS = "download-progress";
    exports.UPDATE_DOWNLOADED = "update-downloaded";
    class UpdaterSignal {
      constructor(emitter) {
        this.emitter = emitter;
      }
      /**
       * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
       */
      login(handler) {
        addHandler(this.emitter, "login", handler);
      }
      progress(handler) {
        addHandler(this.emitter, exports.DOWNLOAD_PROGRESS, handler);
      }
      updateDownloaded(handler) {
        addHandler(this.emitter, exports.UPDATE_DOWNLOADED, handler);
      }
      updateCancelled(handler) {
        addHandler(this.emitter, "update-cancelled", handler);
      }
    }
    exports.UpdaterSignal = UpdaterSignal;
    function addHandler(emitter, event, handler) {
      {
        emitter.on(event, handler);
      }
    }
  })(main$2);
  return main$2;
}
var mainExports = requireMain$1();
const updater = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
var src = { exports: {} };
var electronLogPreload = { exports: {} };
var hasRequiredElectronLogPreload;
function requireElectronLogPreload() {
  if (hasRequiredElectronLogPreload) return electronLogPreload.exports;
  hasRequiredElectronLogPreload = 1;
  (function(module) {
    let electron = {};
    try {
      electron = require("electron");
    } catch (e) {
    }
    if (electron.ipcRenderer) {
      initialize2(electron);
    }
    {
      module.exports = initialize2;
    }
    function initialize2({ contextBridge, ipcRenderer }) {
      if (!ipcRenderer) {
        return;
      }
      ipcRenderer.on("__ELECTRON_LOG_IPC__", (_, message) => {
        window.postMessage({ cmd: "message", ...message });
      });
      ipcRenderer.invoke("__ELECTRON_LOG__", { cmd: "getOptions" }).catch((e) => console.error(new Error(
        `electron-log isn't initialized in the main process. Please call log.initialize() before. ${e.message}`
      )));
      const electronLog = {
        sendToMain(message) {
          try {
            ipcRenderer.send("__ELECTRON_LOG__", message);
          } catch (e) {
            console.error("electronLog.sendToMain ", e, "data:", message);
            ipcRenderer.send("__ELECTRON_LOG__", {
              cmd: "errorHandler",
              error: { message: e == null ? void 0 : e.message, stack: e == null ? void 0 : e.stack },
              errorName: "sendToMain"
            });
          }
        },
        log(...data) {
          electronLog.sendToMain({ data, level: "info" });
        }
      };
      for (const level of ["error", "warn", "info", "verbose", "debug", "silly"]) {
        electronLog[level] = (...data) => electronLog.sendToMain({
          data,
          level
        });
      }
      if (contextBridge && process.contextIsolated) {
        try {
          contextBridge.exposeInMainWorld("__electronLog", electronLog);
        } catch {
        }
      }
      if (typeof window === "object") {
        window.__electronLog = electronLog;
      } else {
        __electronLog = electronLog;
      }
    }
  })(electronLogPreload);
  return electronLogPreload.exports;
}
var renderer = { exports: {} };
var scope;
var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope) return scope;
  hasRequiredScope = 1;
  scope = scopeFactory;
  function scopeFactory(logger) {
    return Object.defineProperties(scope2, {
      defaultLabel: { value: "", writable: true },
      labelPadding: { value: true, writable: true },
      maxLabelLength: { value: 0, writable: true },
      labelLength: {
        get() {
          switch (typeof scope2.labelPadding) {
            case "boolean":
              return scope2.labelPadding ? scope2.maxLabelLength : 0;
            case "number":
              return scope2.labelPadding;
            default:
              return 0;
          }
        }
      }
    });
    function scope2(label) {
      scope2.maxLabelLength = Math.max(scope2.maxLabelLength, label.length);
      const newScope = {};
      for (const level of logger.levels) {
        newScope[level] = (...d) => logger.logData(d, { level, scope: label });
      }
      newScope.log = newScope.info;
      return newScope;
    }
  }
  return scope;
}
var Buffering_1;
var hasRequiredBuffering;
function requireBuffering() {
  if (hasRequiredBuffering) return Buffering_1;
  hasRequiredBuffering = 1;
  class Buffering {
    constructor({ processMessage }) {
      this.processMessage = processMessage;
      this.buffer = [];
      this.enabled = false;
      this.begin = this.begin.bind(this);
      this.commit = this.commit.bind(this);
      this.reject = this.reject.bind(this);
    }
    addMessage(message) {
      this.buffer.push(message);
    }
    begin() {
      this.enabled = [];
    }
    commit() {
      this.enabled = false;
      this.buffer.forEach((item) => this.processMessage(item));
      this.buffer = [];
    }
    reject() {
      this.enabled = false;
      this.buffer = [];
    }
  }
  Buffering_1 = Buffering;
  return Buffering_1;
}
var Logger_1;
var hasRequiredLogger;
function requireLogger() {
  if (hasRequiredLogger) return Logger_1;
  hasRequiredLogger = 1;
  const scopeFactory = requireScope();
  const Buffering = requireBuffering();
  const _Logger = class _Logger {
    constructor({
      allowUnknownLevel = false,
      dependencies = {},
      errorHandler,
      eventLogger,
      initializeFn,
      isDev: isDev2 = false,
      levels = ["error", "warn", "info", "verbose", "debug", "silly"],
      logId,
      transportFactories = {},
      variables
    } = {}) {
      __publicField(this, "dependencies", {});
      __publicField(this, "errorHandler", null);
      __publicField(this, "eventLogger", null);
      __publicField(this, "functions", {});
      __publicField(this, "hooks", []);
      __publicField(this, "isDev", false);
      __publicField(this, "levels", null);
      __publicField(this, "logId", null);
      __publicField(this, "scope", null);
      __publicField(this, "transports", {});
      __publicField(this, "variables", {});
      this.addLevel = this.addLevel.bind(this);
      this.create = this.create.bind(this);
      this.initialize = this.initialize.bind(this);
      this.logData = this.logData.bind(this);
      this.processMessage = this.processMessage.bind(this);
      this.allowUnknownLevel = allowUnknownLevel;
      this.buffering = new Buffering(this);
      this.dependencies = dependencies;
      this.initializeFn = initializeFn;
      this.isDev = isDev2;
      this.levels = levels;
      this.logId = logId;
      this.scope = scopeFactory(this);
      this.transportFactories = transportFactories;
      this.variables = variables || {};
      for (const name of this.levels) {
        this.addLevel(name, false);
      }
      this.log = this.info;
      this.functions.log = this.log;
      this.errorHandler = errorHandler;
      errorHandler == null ? void 0 : errorHandler.setOptions({ ...dependencies, logFn: this.error });
      this.eventLogger = eventLogger;
      eventLogger == null ? void 0 : eventLogger.setOptions({ ...dependencies, logger: this });
      for (const [name, factory] of Object.entries(transportFactories)) {
        this.transports[name] = factory(this, dependencies);
      }
      _Logger.instances[logId] = this;
    }
    static getInstance({ logId }) {
      return this.instances[logId] || this.instances.default;
    }
    addLevel(level, index = this.levels.length) {
      if (index !== false) {
        this.levels.splice(index, 0, level);
      }
      this[level] = (...args) => this.logData(args, { level });
      this.functions[level] = this[level];
    }
    catchErrors(options) {
      this.processMessage(
        {
          data: ["log.catchErrors is deprecated. Use log.errorHandler instead"],
          level: "warn"
        },
        { transports: ["console"] }
      );
      return this.errorHandler.startCatching(options);
    }
    create(options) {
      if (typeof options === "string") {
        options = { logId: options };
      }
      return new _Logger({
        dependencies: this.dependencies,
        errorHandler: this.errorHandler,
        initializeFn: this.initializeFn,
        isDev: this.isDev,
        transportFactories: this.transportFactories,
        variables: { ...this.variables },
        ...options
      });
    }
    compareLevels(passLevel, checkLevel, levels = this.levels) {
      const pass = levels.indexOf(passLevel);
      const check = levels.indexOf(checkLevel);
      if (check === -1 || pass === -1) {
        return true;
      }
      return check <= pass;
    }
    initialize(options = {}) {
      this.initializeFn({ logger: this, ...this.dependencies, ...options });
    }
    logData(data, options = {}) {
      if (this.buffering.enabled) {
        this.buffering.addMessage({ data, ...options });
      } else {
        this.processMessage({ data, ...options });
      }
    }
    processMessage(message, { transports = this.transports } = {}) {
      if (message.cmd === "errorHandler") {
        this.errorHandler.handle(message.error, {
          errorName: message.errorName,
          processType: "renderer",
          showDialog: Boolean(message.showDialog)
        });
        return;
      }
      let level = message.level;
      if (!this.allowUnknownLevel) {
        level = this.levels.includes(message.level) ? message.level : "info";
      }
      const normalizedMessage = {
        date: /* @__PURE__ */ new Date(),
        logId: this.logId,
        ...message,
        level,
        variables: {
          ...this.variables,
          ...message.variables
        }
      };
      for (const [transName, transFn] of this.transportEntries(transports)) {
        if (typeof transFn !== "function" || transFn.level === false) {
          continue;
        }
        if (!this.compareLevels(transFn.level, message.level)) {
          continue;
        }
        try {
          const transformedMsg = this.hooks.reduce((msg, hook) => {
            return msg ? hook(msg, transFn, transName) : msg;
          }, normalizedMessage);
          if (transformedMsg) {
            transFn({ ...transformedMsg, data: [...transformedMsg.data] });
          }
        } catch (e) {
          this.processInternalErrorFn(e);
        }
      }
    }
    processInternalErrorFn(_e) {
    }
    transportEntries(transports = this.transports) {
      const transportArray = Array.isArray(transports) ? transports : Object.entries(transports);
      return transportArray.map((item) => {
        switch (typeof item) {
          case "string":
            return this.transports[item] ? [item, this.transports[item]] : null;
          case "function":
            return [item.name, item];
          default:
            return Array.isArray(item) ? item : null;
        }
      }).filter(Boolean);
    }
  };
  __publicField(_Logger, "instances", {});
  let Logger = _Logger;
  Logger_1 = Logger;
  return Logger_1;
}
var RendererErrorHandler_1;
var hasRequiredRendererErrorHandler;
function requireRendererErrorHandler() {
  if (hasRequiredRendererErrorHandler) return RendererErrorHandler_1;
  hasRequiredRendererErrorHandler = 1;
  const consoleError = console.error;
  class RendererErrorHandler {
    constructor({ logFn = null } = {}) {
      __publicField(this, "logFn", null);
      __publicField(this, "onError", null);
      __publicField(this, "showDialog", false);
      __publicField(this, "preventDefault", true);
      this.handleError = this.handleError.bind(this);
      this.handleRejection = this.handleRejection.bind(this);
      this.startCatching = this.startCatching.bind(this);
      this.logFn = logFn;
    }
    handle(error2, {
      logFn = this.logFn,
      errorName = "",
      onError = this.onError,
      showDialog = this.showDialog
    } = {}) {
      try {
        if ((onError == null ? void 0 : onError({ error: error2, errorName, processType: "renderer" })) !== false) {
          logFn({ error: error2, errorName, showDialog });
        }
      } catch {
        consoleError(error2);
      }
    }
    setOptions({ logFn, onError, preventDefault, showDialog }) {
      if (typeof logFn === "function") {
        this.logFn = logFn;
      }
      if (typeof onError === "function") {
        this.onError = onError;
      }
      if (typeof preventDefault === "boolean") {
        this.preventDefault = preventDefault;
      }
      if (typeof showDialog === "boolean") {
        this.showDialog = showDialog;
      }
    }
    startCatching({ onError, showDialog } = {}) {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      this.setOptions({ onError, showDialog });
      window.addEventListener("error", (event) => {
        var _a;
        this.preventDefault && ((_a = event.preventDefault) == null ? void 0 : _a.call(event));
        this.handleError(event.error || event);
      });
      window.addEventListener("unhandledrejection", (event) => {
        var _a;
        this.preventDefault && ((_a = event.preventDefault) == null ? void 0 : _a.call(event));
        this.handleRejection(event.reason || event);
      });
    }
    handleError(error2) {
      this.handle(error2, { errorName: "Unhandled" });
    }
    handleRejection(reason) {
      const error2 = reason instanceof Error ? reason : new Error(JSON.stringify(reason));
      this.handle(error2, { errorName: "Unhandled rejection" });
    }
  }
  RendererErrorHandler_1 = RendererErrorHandler;
  return RendererErrorHandler_1;
}
var transform_1;
var hasRequiredTransform;
function requireTransform() {
  if (hasRequiredTransform) return transform_1;
  hasRequiredTransform = 1;
  transform_1 = { transform };
  function transform({
    logger,
    message,
    transport,
    initialData = (message == null ? void 0 : message.data) || [],
    transforms = transport == null ? void 0 : transport.transforms
  }) {
    return transforms.reduce((data, trans) => {
      if (typeof trans === "function") {
        return trans({ data, logger, message, transport });
      }
      return data;
    }, initialData);
  }
  return transform_1;
}
var console_1$1;
var hasRequiredConsole$1;
function requireConsole$1() {
  if (hasRequiredConsole$1) return console_1$1;
  hasRequiredConsole$1 = 1;
  const { transform } = requireTransform();
  console_1$1 = consoleTransportRendererFactory;
  const consoleMethods = {
    error: console.error,
    warn: console.warn,
    info: console.info,
    verbose: console.info,
    debug: console.debug,
    silly: console.debug,
    log: console.log
  };
  function consoleTransportRendererFactory(logger) {
    return Object.assign(transport, {
      format: "{h}:{i}:{s}.{ms}{scope}  {text}",
      transforms: [formatDataFn],
      writeFn({ message: { level, data } }) {
        const consoleLogFn = consoleMethods[level] || consoleMethods.info;
        setTimeout(() => consoleLogFn(...data));
      }
    });
    function transport(message) {
      transport.writeFn({
        message: { ...message, data: transform({ logger, message, transport }) }
      });
    }
  }
  function formatDataFn({
    data = [],
    logger = {},
    message = {},
    transport = {}
  }) {
    if (typeof transport.format === "function") {
      return transport.format({
        data,
        level: (message == null ? void 0 : message.level) || "info",
        logger,
        message,
        transport
      });
    }
    if (typeof transport.format !== "string") {
      return data;
    }
    data.unshift(transport.format);
    if (typeof data[1] === "string" && data[1].match(/%[1cdfiOos]/)) {
      data = [`${data[0]} ${data[1]}`, ...data.slice(2)];
    }
    const date = message.date || /* @__PURE__ */ new Date();
    data[0] = data[0].replace(/\{(\w+)}/g, (substring, name) => {
      var _a, _b;
      switch (name) {
        case "level":
          return message.level;
        case "logId":
          return message.logId;
        case "scope": {
          const scope2 = message.scope || ((_a = logger.scope) == null ? void 0 : _a.defaultLabel);
          return scope2 ? ` (${scope2})` : "";
        }
        case "text":
          return "";
        case "y":
          return date.getFullYear().toString(10);
        case "m":
          return (date.getMonth() + 1).toString(10).padStart(2, "0");
        case "d":
          return date.getDate().toString(10).padStart(2, "0");
        case "h":
          return date.getHours().toString(10).padStart(2, "0");
        case "i":
          return date.getMinutes().toString(10).padStart(2, "0");
        case "s":
          return date.getSeconds().toString(10).padStart(2, "0");
        case "ms":
          return date.getMilliseconds().toString(10).padStart(3, "0");
        case "iso":
          return date.toISOString();
        default:
          return ((_b = message.variables) == null ? void 0 : _b[name]) || substring;
      }
    }).trim();
    return data;
  }
  return console_1$1;
}
var ipc$1;
var hasRequiredIpc$1;
function requireIpc$1() {
  if (hasRequiredIpc$1) return ipc$1;
  hasRequiredIpc$1 = 1;
  const { transform } = requireTransform();
  ipc$1 = ipcTransportRendererFactory;
  const RESTRICTED_TYPES = /* @__PURE__ */ new Set([Promise, WeakMap, WeakSet]);
  function ipcTransportRendererFactory(logger) {
    return Object.assign(transport, {
      depth: 5,
      transforms: [serializeFn]
    });
    function transport(message) {
      if (!window.__electronLog) {
        logger.processMessage(
          {
            data: ["electron-log: logger isn't initialized in the main process"],
            level: "error"
          },
          { transports: ["console"] }
        );
        return;
      }
      try {
        const serialized = transform({
          initialData: message,
          logger,
          message,
          transport
        });
        __electronLog.sendToMain(serialized);
      } catch (e) {
        logger.transports.console({
          data: ["electronLog.transports.ipc", e, "data:", message.data],
          level: "error"
        });
      }
    }
  }
  function isPrimitive(value) {
    return Object(value) !== value;
  }
  function serializeFn({
    data,
    depth,
    seen = /* @__PURE__ */ new WeakSet(),
    transport = {}
  } = {}) {
    const actualDepth = depth || transport.depth || 5;
    if (seen.has(data)) {
      return "[Circular]";
    }
    if (actualDepth < 1) {
      if (isPrimitive(data)) {
        return data;
      }
      if (Array.isArray(data)) {
        return "[Array]";
      }
      return `[${typeof data}]`;
    }
    if (["function", "symbol"].includes(typeof data)) {
      return data.toString();
    }
    if (isPrimitive(data)) {
      return data;
    }
    if (RESTRICTED_TYPES.has(data.constructor)) {
      return `[${data.constructor.name}]`;
    }
    if (Array.isArray(data)) {
      return data.map((item) => serializeFn({
        data: item,
        depth: actualDepth - 1,
        seen
      }));
    }
    if (data instanceof Date) {
      return data.toISOString();
    }
    if (data instanceof Error) {
      return data.stack;
    }
    if (data instanceof Map) {
      return new Map(
        Array.from(data).map(([key, value]) => [
          serializeFn({ data: key, depth: actualDepth - 1, seen }),
          serializeFn({ data: value, depth: actualDepth - 1, seen })
        ])
      );
    }
    if (data instanceof Set) {
      return new Set(
        Array.from(data).map(
          (val) => serializeFn({ data: val, depth: actualDepth - 1, seen })
        )
      );
    }
    seen.add(data);
    return Object.fromEntries(
      Object.entries(data).map(
        ([key, value]) => [
          key,
          serializeFn({ data: value, depth: actualDepth - 1, seen })
        ]
      )
    );
  }
  return ipc$1;
}
var hasRequiredRenderer;
function requireRenderer() {
  if (hasRequiredRenderer) return renderer.exports;
  hasRequiredRenderer = 1;
  (function(module) {
    const Logger = requireLogger();
    const RendererErrorHandler = requireRendererErrorHandler();
    const transportConsole = requireConsole$1();
    const transportIpc = requireIpc$1();
    module.exports = createLogger();
    module.exports.Logger = Logger;
    module.exports.default = module.exports;
    function createLogger() {
      const logger = new Logger({
        allowUnknownLevel: true,
        errorHandler: new RendererErrorHandler(),
        initializeFn: () => {
        },
        logId: "default",
        transportFactories: {
          console: transportConsole,
          ipc: transportIpc
        },
        variables: {
          processType: "renderer"
        }
      });
      logger.errorHandler.setOptions({
        logFn({ error: error2, errorName, showDialog }) {
          logger.transports.console({
            data: [errorName, error2].filter(Boolean),
            level: "error"
          });
          logger.transports.ipc({
            cmd: "errorHandler",
            error: {
              cause: error2 == null ? void 0 : error2.cause,
              code: error2 == null ? void 0 : error2.code,
              name: error2 == null ? void 0 : error2.name,
              message: error2 == null ? void 0 : error2.message,
              stack: error2 == null ? void 0 : error2.stack
            },
            errorName,
            logId: logger.logId,
            showDialog
          });
        }
      });
      if (typeof window === "object") {
        window.addEventListener("message", (event) => {
          const { cmd, logId, ...message } = event.data || {};
          const instance = Logger.getInstance({ logId });
          if (cmd === "message") {
            instance.processMessage(message, { transports: ["console"] });
          }
        });
      }
      return new Proxy(logger, {
        get(target, prop) {
          if (typeof target[prop] !== "undefined") {
            return target[prop];
          }
          return (...data) => logger.logData(data, { level: prop });
        }
      });
    }
  })(renderer);
  return renderer.exports;
}
var packageJson;
var hasRequiredPackageJson;
function requirePackageJson() {
  if (hasRequiredPackageJson) return packageJson;
  hasRequiredPackageJson = 1;
  const fs2 = require$$1$2;
  const path = require$$1$1;
  packageJson = {
    findAndReadPackageJson,
    tryReadJsonAt
  };
  function findAndReadPackageJson() {
    return tryReadJsonAt(getMainModulePath()) || tryReadJsonAt(extractPathFromArgs()) || tryReadJsonAt(process.resourcesPath, "app.asar") || tryReadJsonAt(process.resourcesPath, "app") || tryReadJsonAt(process.cwd()) || { name: void 0, version: void 0 };
  }
  function tryReadJsonAt(...searchPaths) {
    if (!searchPaths[0]) {
      return void 0;
    }
    try {
      const searchPath = path.join(...searchPaths);
      const fileName = findUp("package.json", searchPath);
      if (!fileName) {
        return void 0;
      }
      const json2 = JSON.parse(fs2.readFileSync(fileName, "utf8"));
      const name = (json2 == null ? void 0 : json2.productName) || (json2 == null ? void 0 : json2.name);
      if (!name || name.toLowerCase() === "electron") {
        return void 0;
      }
      if (name) {
        return { name, version: json2 == null ? void 0 : json2.version };
      }
      return void 0;
    } catch (e) {
      return void 0;
    }
  }
  function findUp(fileName, cwd) {
    let currentPath = cwd;
    while (true) {
      const parsedPath = path.parse(currentPath);
      const root = parsedPath.root;
      const dir = parsedPath.dir;
      if (fs2.existsSync(path.join(currentPath, fileName))) {
        return path.resolve(path.join(currentPath, fileName));
      }
      if (currentPath === root) {
        return null;
      }
      currentPath = dir;
    }
  }
  function extractPathFromArgs() {
    const matchedArgs = process.argv.filter((arg) => {
      return arg.indexOf("--user-data-dir=") === 0;
    });
    if (matchedArgs.length === 0 || typeof matchedArgs[0] !== "string") {
      return null;
    }
    const userDataDir = matchedArgs[0];
    return userDataDir.replace("--user-data-dir=", "");
  }
  function getMainModulePath() {
    var _a;
    try {
      return (_a = require.main) == null ? void 0 : _a.filename;
    } catch {
      return void 0;
    }
  }
  return packageJson;
}
var NodeExternalApi_1;
var hasRequiredNodeExternalApi;
function requireNodeExternalApi() {
  if (hasRequiredNodeExternalApi) return NodeExternalApi_1;
  hasRequiredNodeExternalApi = 1;
  const childProcess = require$$1$8;
  const os = require$$2$1;
  const path = require$$1$1;
  const packageJson2 = requirePackageJson();
  class NodeExternalApi {
    constructor() {
      __publicField(this, "appName");
      __publicField(this, "appPackageJson");
      __publicField(this, "platform", process.platform);
    }
    getAppLogPath(appName = this.getAppName()) {
      if (this.platform === "darwin") {
        return path.join(this.getSystemPathHome(), "Library/Logs", appName);
      }
      return path.join(this.getAppUserDataPath(appName), "logs");
    }
    getAppName() {
      var _a;
      const appName = this.appName || ((_a = this.getAppPackageJson()) == null ? void 0 : _a.name);
      if (!appName) {
        throw new Error(
          "electron-log can't determine the app name. It tried these methods:\n1. Use `electron.app.name`\n2. Use productName or name from the nearest package.json`\nYou can also set it through log.transports.file.setAppName()"
        );
      }
      return appName;
    }
    /**
     * @private
     * @returns {undefined}
     */
    getAppPackageJson() {
      if (typeof this.appPackageJson !== "object") {
        this.appPackageJson = packageJson2.findAndReadPackageJson();
      }
      return this.appPackageJson;
    }
    getAppUserDataPath(appName = this.getAppName()) {
      return appName ? path.join(this.getSystemPathAppData(), appName) : void 0;
    }
    getAppVersion() {
      var _a;
      return (_a = this.getAppPackageJson()) == null ? void 0 : _a.version;
    }
    getElectronLogPath() {
      return this.getAppLogPath();
    }
    getMacOsVersion() {
      const release = Number(os.release().split(".")[0]);
      if (release <= 19) {
        return `10.${release - 4}`;
      }
      return release - 9;
    }
    /**
     * @protected
     * @returns {string}
     */
    getOsVersion() {
      let osName = os.type().replace("_", " ");
      let osVersion = os.release();
      if (osName === "Darwin") {
        osName = "macOS";
        osVersion = this.getMacOsVersion();
      }
      return `${osName} ${osVersion}`;
    }
    /**
     * @return {PathVariables}
     */
    getPathVariables() {
      const appName = this.getAppName();
      const appVersion = this.getAppVersion();
      const self2 = this;
      return {
        appData: this.getSystemPathAppData(),
        appName,
        appVersion,
        get electronDefaultDir() {
          return self2.getElectronLogPath();
        },
        home: this.getSystemPathHome(),
        libraryDefaultDir: this.getAppLogPath(appName),
        libraryTemplate: this.getAppLogPath("{appName}"),
        temp: this.getSystemPathTemp(),
        userData: this.getAppUserDataPath(appName)
      };
    }
    getSystemPathAppData() {
      const home = this.getSystemPathHome();
      switch (this.platform) {
        case "darwin": {
          return path.join(home, "Library/Application Support");
        }
        case "win32": {
          return process.env.APPDATA || path.join(home, "AppData/Roaming");
        }
        default: {
          return process.env.XDG_CONFIG_HOME || path.join(home, ".config");
        }
      }
    }
    getSystemPathHome() {
      var _a;
      return ((_a = os.homedir) == null ? void 0 : _a.call(os)) || process.env.HOME;
    }
    getSystemPathTemp() {
      return os.tmpdir();
    }
    getVersions() {
      return {
        app: `${this.getAppName()} ${this.getAppVersion()}`,
        electron: void 0,
        os: this.getOsVersion()
      };
    }
    isDev() {
      return process.env.NODE_ENV === "development" || process.env.ELECTRON_IS_DEV === "1";
    }
    isElectron() {
      return Boolean(process.versions.electron);
    }
    onAppEvent(_eventName, _handler) {
    }
    onAppReady(handler) {
      handler();
    }
    onEveryWebContentsEvent(eventName, handler) {
    }
    /**
     * Listen to async messages sent from opposite process
     * @param {string} channel
     * @param {function} listener
     */
    onIpc(channel, listener) {
    }
    onIpcInvoke(channel, listener) {
    }
    /**
     * @param {string} url
     * @param {Function} [logFunction]
     */
    openUrl(url, logFunction = console.error) {
      const startMap = { darwin: "open", win32: "start", linux: "xdg-open" };
      const start = startMap[process.platform] || "xdg-open";
      childProcess.exec(`${start} ${url}`, {}, (err) => {
        if (err) {
          logFunction(err);
        }
      });
    }
    setAppName(appName) {
      this.appName = appName;
    }
    setPlatform(platform) {
      this.platform = platform;
    }
    setPreloadFileForSessions({
      filePath,
      // eslint-disable-line no-unused-vars
      includeFutureSession = true,
      // eslint-disable-line no-unused-vars
      getSessions = () => []
      // eslint-disable-line no-unused-vars
    }) {
    }
    /**
     * Sent a message to opposite process
     * @param {string} channel
     * @param {any} message
     */
    sendIpc(channel, message) {
    }
    showErrorBox(title, message) {
    }
  }
  NodeExternalApi_1 = NodeExternalApi;
  return NodeExternalApi_1;
}
var ElectronExternalApi_1;
var hasRequiredElectronExternalApi;
function requireElectronExternalApi() {
  if (hasRequiredElectronExternalApi) return ElectronExternalApi_1;
  hasRequiredElectronExternalApi = 1;
  const path = require$$1$1;
  const NodeExternalApi = requireNodeExternalApi();
  class ElectronExternalApi extends NodeExternalApi {
    /**
     * @param {object} options
     * @param {typeof Electron} [options.electron]
     */
    constructor({ electron } = {}) {
      super();
      /**
       * @type {typeof Electron}
       */
      __publicField(this, "electron");
      this.electron = electron;
    }
    getAppName() {
      var _a, _b;
      let appName;
      try {
        appName = this.appName || ((_a = this.electron.app) == null ? void 0 : _a.name) || ((_b = this.electron.app) == null ? void 0 : _b.getName());
      } catch {
      }
      return appName || super.getAppName();
    }
    getAppUserDataPath(appName) {
      return this.getPath("userData") || super.getAppUserDataPath(appName);
    }
    getAppVersion() {
      var _a;
      let appVersion;
      try {
        appVersion = (_a = this.electron.app) == null ? void 0 : _a.getVersion();
      } catch {
      }
      return appVersion || super.getAppVersion();
    }
    getElectronLogPath() {
      return this.getPath("logs") || super.getElectronLogPath();
    }
    /**
     * @private
     * @param {any} name
     * @returns {string|undefined}
     */
    getPath(name) {
      var _a;
      try {
        return (_a = this.electron.app) == null ? void 0 : _a.getPath(name);
      } catch {
        return void 0;
      }
    }
    getVersions() {
      return {
        app: `${this.getAppName()} ${this.getAppVersion()}`,
        electron: `Electron ${process.versions.electron}`,
        os: this.getOsVersion()
      };
    }
    getSystemPathAppData() {
      return this.getPath("appData") || super.getSystemPathAppData();
    }
    isDev() {
      var _a;
      if (((_a = this.electron.app) == null ? void 0 : _a.isPackaged) !== void 0) {
        return !this.electron.app.isPackaged;
      }
      if (typeof process.execPath === "string") {
        const execFileName = path.basename(process.execPath).toLowerCase();
        return execFileName.startsWith("electron");
      }
      return super.isDev();
    }
    onAppEvent(eventName, handler) {
      var _a;
      (_a = this.electron.app) == null ? void 0 : _a.on(eventName, handler);
      return () => {
        var _a2;
        (_a2 = this.electron.app) == null ? void 0 : _a2.off(eventName, handler);
      };
    }
    onAppReady(handler) {
      var _a, _b, _c;
      if ((_a = this.electron.app) == null ? void 0 : _a.isReady()) {
        handler();
      } else if ((_b = this.electron.app) == null ? void 0 : _b.once) {
        (_c = this.electron.app) == null ? void 0 : _c.once("ready", handler);
      } else {
        handler();
      }
    }
    onEveryWebContentsEvent(eventName, handler) {
      var _a, _b, _c;
      (_b = (_a = this.electron.webContents) == null ? void 0 : _a.getAllWebContents()) == null ? void 0 : _b.forEach((webContents) => {
        webContents.on(eventName, handler);
      });
      (_c = this.electron.app) == null ? void 0 : _c.on("web-contents-created", onWebContentsCreated);
      return () => {
        var _a2, _b2;
        (_a2 = this.electron.webContents) == null ? void 0 : _a2.getAllWebContents().forEach((webContents) => {
          webContents.off(eventName, handler);
        });
        (_b2 = this.electron.app) == null ? void 0 : _b2.off("web-contents-created", onWebContentsCreated);
      };
      function onWebContentsCreated(_, webContents) {
        webContents.on(eventName, handler);
      }
    }
    /**
     * Listen to async messages sent from opposite process
     * @param {string} channel
     * @param {function} listener
     */
    onIpc(channel, listener) {
      var _a;
      (_a = this.electron.ipcMain) == null ? void 0 : _a.on(channel, listener);
    }
    onIpcInvoke(channel, listener) {
      var _a, _b;
      (_b = (_a = this.electron.ipcMain) == null ? void 0 : _a.handle) == null ? void 0 : _b.call(_a, channel, listener);
    }
    /**
     * @param {string} url
     * @param {Function} [logFunction]
     */
    openUrl(url, logFunction = console.error) {
      var _a;
      (_a = this.electron.shell) == null ? void 0 : _a.openExternal(url).catch(logFunction);
    }
    setPreloadFileForSessions({
      filePath,
      includeFutureSession = true,
      getSessions = () => {
        var _a;
        return [(_a = this.electron.session) == null ? void 0 : _a.defaultSession];
      }
    }) {
      for (const session of getSessions().filter(Boolean)) {
        setPreload(session);
      }
      if (includeFutureSession) {
        this.onAppEvent("session-created", (session) => {
          setPreload(session);
        });
      }
      function setPreload(session) {
        if (typeof session.registerPreloadScript === "function") {
          session.registerPreloadScript({
            filePath,
            id: "electron-log-preload",
            type: "frame"
          });
        } else {
          session.setPreloads([...session.getPreloads(), filePath]);
        }
      }
    }
    /**
     * Sent a message to opposite process
     * @param {string} channel
     * @param {any} message
     */
    sendIpc(channel, message) {
      var _a, _b;
      (_b = (_a = this.electron.BrowserWindow) == null ? void 0 : _a.getAllWindows()) == null ? void 0 : _b.forEach((wnd) => {
        var _a2, _b2;
        if (((_a2 = wnd.webContents) == null ? void 0 : _a2.isDestroyed()) === false && ((_b2 = wnd.webContents) == null ? void 0 : _b2.isCrashed()) === false) {
          wnd.webContents.send(channel, message);
        }
      });
    }
    showErrorBox(title, message) {
      var _a;
      (_a = this.electron.dialog) == null ? void 0 : _a.showErrorBox(title, message);
    }
  }
  ElectronExternalApi_1 = ElectronExternalApi;
  return ElectronExternalApi_1;
}
var initialize;
var hasRequiredInitialize;
function requireInitialize() {
  if (hasRequiredInitialize) return initialize;
  hasRequiredInitialize = 1;
  const fs2 = require$$1$2;
  const os = require$$2$1;
  const path = require$$1$1;
  const preloadInitializeFn = requireElectronLogPreload();
  initialize = {
    initialize({
      externalApi,
      getSessions,
      includeFutureSession,
      logger,
      preload = true,
      spyRendererConsole = false
    }) {
      externalApi.onAppReady(() => {
        try {
          if (preload) {
            initializePreload({
              externalApi,
              getSessions,
              includeFutureSession,
              preloadOption: preload
            });
          }
          if (spyRendererConsole) {
            initializeSpyRendererConsole({ externalApi, logger });
          }
        } catch (err) {
          logger.warn(err);
        }
      });
    }
  };
  function initializePreload({
    externalApi,
    getSessions,
    includeFutureSession,
    preloadOption
  }) {
    let preloadPath2 = typeof preloadOption === "string" ? preloadOption : void 0;
    try {
      preloadPath2 = path.resolve(
        __dirname,
        "../renderer/electron-log-preload.js"
      );
    } catch {
    }
    if (!preloadPath2 || !fs2.existsSync(preloadPath2)) {
      preloadPath2 = path.join(
        externalApi.getAppUserDataPath() || os.tmpdir(),
        "electron-log-preload.js"
      );
      const preloadCode = `
      try {
        (${preloadInitializeFn.toString()})(require('electron'));
      } catch(e) {
        console.error(e);
      }
    `;
      fs2.writeFileSync(preloadPath2, preloadCode, "utf8");
    }
    externalApi.setPreloadFileForSessions({
      filePath: preloadPath2,
      includeFutureSession,
      getSessions
    });
  }
  function initializeSpyRendererConsole({ externalApi, logger }) {
    const levels = ["verbose", "info", "warning", "error"];
    externalApi.onEveryWebContentsEvent(
      "console-message",
      (event, level, message) => {
        logger.processMessage({
          data: [message],
          level: levels[level],
          variables: { processType: "renderer" }
        });
      }
    );
  }
  return initialize;
}
var ErrorHandler_1;
var hasRequiredErrorHandler;
function requireErrorHandler() {
  if (hasRequiredErrorHandler) return ErrorHandler_1;
  hasRequiredErrorHandler = 1;
  class ErrorHandler {
    constructor({
      externalApi,
      logFn = void 0,
      onError = void 0,
      showDialog = void 0
    } = {}) {
      __publicField(this, "externalApi");
      __publicField(this, "isActive", false);
      __publicField(this, "logFn");
      __publicField(this, "onError");
      __publicField(this, "showDialog", true);
      this.createIssue = this.createIssue.bind(this);
      this.handleError = this.handleError.bind(this);
      this.handleRejection = this.handleRejection.bind(this);
      this.setOptions({ externalApi, logFn, onError, showDialog });
      this.startCatching = this.startCatching.bind(this);
      this.stopCatching = this.stopCatching.bind(this);
    }
    handle(error2, {
      logFn = this.logFn,
      onError = this.onError,
      processType = "browser",
      showDialog = this.showDialog,
      errorName = ""
    } = {}) {
      var _a;
      error2 = normalizeError(error2);
      try {
        if (typeof onError === "function") {
          const versions = ((_a = this.externalApi) == null ? void 0 : _a.getVersions()) || {};
          const createIssue = this.createIssue;
          const result = onError({
            createIssue,
            error: error2,
            errorName,
            processType,
            versions
          });
          if (result === false) {
            return;
          }
        }
        errorName ? logFn(errorName, error2) : logFn(error2);
        if (showDialog && !errorName.includes("rejection") && this.externalApi) {
          this.externalApi.showErrorBox(
            `A JavaScript error occurred in the ${processType} process`,
            error2.stack
          );
        }
      } catch {
        console.error(error2);
      }
    }
    setOptions({ externalApi, logFn, onError, showDialog }) {
      if (typeof externalApi === "object") {
        this.externalApi = externalApi;
      }
      if (typeof logFn === "function") {
        this.logFn = logFn;
      }
      if (typeof onError === "function") {
        this.onError = onError;
      }
      if (typeof showDialog === "boolean") {
        this.showDialog = showDialog;
      }
    }
    startCatching({ onError, showDialog } = {}) {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      this.setOptions({ onError, showDialog });
      process.on("uncaughtException", this.handleError);
      process.on("unhandledRejection", this.handleRejection);
    }
    stopCatching() {
      this.isActive = false;
      process.removeListener("uncaughtException", this.handleError);
      process.removeListener("unhandledRejection", this.handleRejection);
    }
    createIssue(pageUrl, queryParams) {
      var _a;
      (_a = this.externalApi) == null ? void 0 : _a.openUrl(
        `${pageUrl}?${new URLSearchParams(queryParams).toString()}`
      );
    }
    handleError(error2) {
      this.handle(error2, { errorName: "Unhandled" });
    }
    handleRejection(reason) {
      const error2 = reason instanceof Error ? reason : new Error(JSON.stringify(reason));
      this.handle(error2, { errorName: "Unhandled rejection" });
    }
  }
  function normalizeError(e) {
    if (e instanceof Error) {
      return e;
    }
    if (e && typeof e === "object") {
      if (e.message) {
        return Object.assign(new Error(e.message), e);
      }
      try {
        return new Error(JSON.stringify(e));
      } catch (serErr) {
        return new Error(`Couldn't normalize error ${String(e)}: ${serErr}`);
      }
    }
    return new Error(`Can't normalize error ${String(e)}`);
  }
  ErrorHandler_1 = ErrorHandler;
  return ErrorHandler_1;
}
var EventLogger_1;
var hasRequiredEventLogger;
function requireEventLogger() {
  if (hasRequiredEventLogger) return EventLogger_1;
  hasRequiredEventLogger = 1;
  class EventLogger {
    constructor(options = {}) {
      __publicField(this, "disposers", []);
      __publicField(this, "format", "{eventSource}#{eventName}:");
      __publicField(this, "formatters", {
        app: {
          "certificate-error": ({ args }) => {
            return this.arrayToObject(args.slice(1, 4), [
              "url",
              "error",
              "certificate"
            ]);
          },
          "child-process-gone": ({ args }) => {
            return args.length === 1 ? args[0] : args;
          },
          "render-process-gone": ({ args: [webContents, details] }) => {
            return details && typeof details === "object" ? { ...details, ...this.getWebContentsDetails(webContents) } : [];
          }
        },
        webContents: {
          "console-message": ({ args: [level, message, line, sourceId] }) => {
            if (level < 3) {
              return void 0;
            }
            return { message, source: `${sourceId}:${line}` };
          },
          "did-fail-load": ({ args }) => {
            return this.arrayToObject(args, [
              "errorCode",
              "errorDescription",
              "validatedURL",
              "isMainFrame",
              "frameProcessId",
              "frameRoutingId"
            ]);
          },
          "did-fail-provisional-load": ({ args }) => {
            return this.arrayToObject(args, [
              "errorCode",
              "errorDescription",
              "validatedURL",
              "isMainFrame",
              "frameProcessId",
              "frameRoutingId"
            ]);
          },
          "plugin-crashed": ({ args }) => {
            return this.arrayToObject(args, ["name", "version"]);
          },
          "preload-error": ({ args }) => {
            return this.arrayToObject(args, ["preloadPath", "error"]);
          }
        }
      });
      __publicField(this, "events", {
        app: {
          "certificate-error": true,
          "child-process-gone": true,
          "render-process-gone": true
        },
        webContents: {
          // 'console-message': true,
          "did-fail-load": true,
          "did-fail-provisional-load": true,
          "plugin-crashed": true,
          "preload-error": true,
          "unresponsive": true
        }
      });
      __publicField(this, "externalApi");
      __publicField(this, "level", "error");
      __publicField(this, "scope", "");
      this.setOptions(options);
    }
    setOptions({
      events,
      externalApi,
      level,
      logger,
      format: format2,
      formatters,
      scope: scope2
    }) {
      if (typeof events === "object") {
        this.events = events;
      }
      if (typeof externalApi === "object") {
        this.externalApi = externalApi;
      }
      if (typeof level === "string") {
        this.level = level;
      }
      if (typeof logger === "object") {
        this.logger = logger;
      }
      if (typeof format2 === "string" || typeof format2 === "function") {
        this.format = format2;
      }
      if (typeof formatters === "object") {
        this.formatters = formatters;
      }
      if (typeof scope2 === "string") {
        this.scope = scope2;
      }
    }
    startLogging(options = {}) {
      this.setOptions(options);
      this.disposeListeners();
      for (const eventName of this.getEventNames(this.events.app)) {
        this.disposers.push(
          this.externalApi.onAppEvent(eventName, (...handlerArgs) => {
            this.handleEvent({ eventSource: "app", eventName, handlerArgs });
          })
        );
      }
      for (const eventName of this.getEventNames(this.events.webContents)) {
        this.disposers.push(
          this.externalApi.onEveryWebContentsEvent(
            eventName,
            (...handlerArgs) => {
              this.handleEvent(
                { eventSource: "webContents", eventName, handlerArgs }
              );
            }
          )
        );
      }
    }
    stopLogging() {
      this.disposeListeners();
    }
    arrayToObject(array, fieldNames) {
      const obj = {};
      fieldNames.forEach((fieldName, index) => {
        obj[fieldName] = array[index];
      });
      if (array.length > fieldNames.length) {
        obj.unknownArgs = array.slice(fieldNames.length);
      }
      return obj;
    }
    disposeListeners() {
      this.disposers.forEach((disposer) => disposer());
      this.disposers = [];
    }
    formatEventLog({ eventName, eventSource, handlerArgs }) {
      var _a;
      const [event, ...args] = handlerArgs;
      if (typeof this.format === "function") {
        return this.format({ args, event, eventName, eventSource });
      }
      const formatter = (_a = this.formatters[eventSource]) == null ? void 0 : _a[eventName];
      let formattedArgs = args;
      if (typeof formatter === "function") {
        formattedArgs = formatter({ args, event, eventName, eventSource });
      }
      if (!formattedArgs) {
        return void 0;
      }
      const eventData = {};
      if (Array.isArray(formattedArgs)) {
        eventData.args = formattedArgs;
      } else if (typeof formattedArgs === "object") {
        Object.assign(eventData, formattedArgs);
      }
      if (eventSource === "webContents") {
        Object.assign(eventData, this.getWebContentsDetails(event == null ? void 0 : event.sender));
      }
      const title = this.format.replace("{eventSource}", eventSource === "app" ? "App" : "WebContents").replace("{eventName}", eventName);
      return [title, eventData];
    }
    getEventNames(eventMap) {
      if (!eventMap || typeof eventMap !== "object") {
        return [];
      }
      return Object.entries(eventMap).filter(([_, listen]) => listen).map(([eventName]) => eventName);
    }
    getWebContentsDetails(webContents) {
      if (!(webContents == null ? void 0 : webContents.loadURL)) {
        return {};
      }
      try {
        return {
          webContents: {
            id: webContents.id,
            url: webContents.getURL()
          }
        };
      } catch {
        return {};
      }
    }
    handleEvent({ eventName, eventSource, handlerArgs }) {
      var _a;
      const log2 = this.formatEventLog({ eventName, eventSource, handlerArgs });
      if (log2) {
        const logFns = this.scope ? this.logger.scope(this.scope) : this.logger;
        (_a = logFns == null ? void 0 : logFns[this.level]) == null ? void 0 : _a.call(logFns, ...log2);
      }
    }
  }
  EventLogger_1 = EventLogger;
  return EventLogger_1;
}
var format;
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format;
  hasRequiredFormat = 1;
  const { transform } = requireTransform();
  format = {
    concatFirstStringElements,
    formatScope,
    formatText,
    formatVariables,
    timeZoneFromOffset,
    format({ message, logger, transport, data = message == null ? void 0 : message.data }) {
      switch (typeof transport.format) {
        case "string": {
          return transform({
            message,
            logger,
            transforms: [formatVariables, formatScope, formatText],
            transport,
            initialData: [transport.format, ...data]
          });
        }
        case "function": {
          return transport.format({
            data,
            level: (message == null ? void 0 : message.level) || "info",
            logger,
            message,
            transport
          });
        }
        default: {
          return data;
        }
      }
    }
  };
  function concatFirstStringElements({ data }) {
    if (typeof data[0] !== "string" || typeof data[1] !== "string") {
      return data;
    }
    if (data[0].match(/%[1cdfiOos]/)) {
      return data;
    }
    return [`${data[0]} ${data[1]}`, ...data.slice(2)];
  }
  function timeZoneFromOffset(minutesOffset) {
    const minutesPositive = Math.abs(minutesOffset);
    const sign = minutesOffset > 0 ? "-" : "+";
    const hours = Math.floor(minutesPositive / 60).toString().padStart(2, "0");
    const minutes = (minutesPositive % 60).toString().padStart(2, "0");
    return `${sign}${hours}:${minutes}`;
  }
  function formatScope({ data, logger, message }) {
    const { defaultLabel, labelLength } = (logger == null ? void 0 : logger.scope) || {};
    const template = data[0];
    let label = message.scope;
    if (!label) {
      label = defaultLabel;
    }
    let scopeText;
    if (label === "") {
      scopeText = labelLength > 0 ? "".padEnd(labelLength + 3) : "";
    } else if (typeof label === "string") {
      scopeText = ` (${label})`.padEnd(labelLength + 3);
    } else {
      scopeText = "";
    }
    data[0] = template.replace("{scope}", scopeText);
    return data;
  }
  function formatVariables({ data, message }) {
    let template = data[0];
    if (typeof template !== "string") {
      return data;
    }
    template = template.replace("{level}]", `${message.level}]`.padEnd(6, " "));
    const date = message.date || /* @__PURE__ */ new Date();
    data[0] = template.replace(/\{(\w+)}/g, (substring, name) => {
      var _a;
      switch (name) {
        case "level":
          return message.level || "info";
        case "logId":
          return message.logId;
        case "y":
          return date.getFullYear().toString(10);
        case "m":
          return (date.getMonth() + 1).toString(10).padStart(2, "0");
        case "d":
          return date.getDate().toString(10).padStart(2, "0");
        case "h":
          return date.getHours().toString(10).padStart(2, "0");
        case "i":
          return date.getMinutes().toString(10).padStart(2, "0");
        case "s":
          return date.getSeconds().toString(10).padStart(2, "0");
        case "ms":
          return date.getMilliseconds().toString(10).padStart(3, "0");
        case "z":
          return timeZoneFromOffset(date.getTimezoneOffset());
        case "iso":
          return date.toISOString();
        default: {
          return ((_a = message.variables) == null ? void 0 : _a[name]) || substring;
        }
      }
    }).trim();
    return data;
  }
  function formatText({ data }) {
    const template = data[0];
    if (typeof template !== "string") {
      return data;
    }
    const textTplPosition = template.lastIndexOf("{text}");
    if (textTplPosition === template.length - 6) {
      data[0] = template.replace(/\s?{text}/, "");
      if (data[0] === "") {
        data.shift();
      }
      return data;
    }
    const templatePieces = template.split("{text}");
    let result = [];
    if (templatePieces[0] !== "") {
      result.push(templatePieces[0]);
    }
    result = result.concat(data.slice(1));
    if (templatePieces[1] !== "") {
      result.push(templatePieces[1]);
    }
    return result;
  }
  return format;
}
var object = { exports: {} };
var hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object.exports;
  hasRequiredObject = 1;
  (function(module) {
    const util2 = require$$1$6;
    module.exports = {
      serialize,
      maxDepth({ data, transport, depth = (transport == null ? void 0 : transport.depth) ?? 6 }) {
        if (!data) {
          return data;
        }
        if (depth < 1) {
          if (Array.isArray(data)) return "[array]";
          if (typeof data === "object" && data) return "[object]";
          return data;
        }
        if (Array.isArray(data)) {
          return data.map((child) => module.exports.maxDepth({
            data: child,
            depth: depth - 1
          }));
        }
        if (typeof data !== "object") {
          return data;
        }
        if (data && typeof data.toISOString === "function") {
          return data;
        }
        if (data === null) {
          return null;
        }
        if (data instanceof Error) {
          return data;
        }
        const newJson = {};
        for (const i in data) {
          if (!Object.prototype.hasOwnProperty.call(data, i)) continue;
          newJson[i] = module.exports.maxDepth({
            data: data[i],
            depth: depth - 1
          });
        }
        return newJson;
      },
      toJSON({ data }) {
        return JSON.parse(JSON.stringify(data, createSerializer()));
      },
      toString({ data, transport }) {
        const inspectOptions = (transport == null ? void 0 : transport.inspectOptions) || {};
        const simplifiedData = data.map((item) => {
          if (item === void 0) {
            return void 0;
          }
          try {
            const str2 = JSON.stringify(item, createSerializer(), "  ");
            return str2 === void 0 ? void 0 : JSON.parse(str2);
          } catch (e) {
            return item;
          }
        });
        return util2.formatWithOptions(inspectOptions, ...simplifiedData);
      }
    };
    function createSerializer(options = {}) {
      const seen = /* @__PURE__ */ new WeakSet();
      return function(key, value) {
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) {
            return void 0;
          }
          seen.add(value);
        }
        return serialize(key, value, options);
      };
    }
    function serialize(key, value, options = {}) {
      const serializeMapAndSet = (options == null ? void 0 : options.serializeMapAndSet) !== false;
      if (value instanceof Error) {
        return value.stack;
      }
      if (!value) {
        return value;
      }
      if (typeof value === "function") {
        return `[function] ${value.toString()}`;
      }
      if (value instanceof Date) {
        return value.toISOString();
      }
      if (serializeMapAndSet && value instanceof Map && Object.fromEntries) {
        return Object.fromEntries(value);
      }
      if (serializeMapAndSet && value instanceof Set && Array.from) {
        return Array.from(value);
      }
      return value;
    }
  })(object);
  return object.exports;
}
var style;
var hasRequiredStyle;
function requireStyle() {
  if (hasRequiredStyle) return style;
  hasRequiredStyle = 1;
  style = {
    transformStyles,
    applyAnsiStyles({ data }) {
      return transformStyles(data, styleToAnsi, resetAnsiStyle);
    },
    removeStyles({ data }) {
      return transformStyles(data, () => "");
    }
  };
  const ANSI_COLORS = {
    unset: "\x1B[0m",
    black: "\x1B[30m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    white: "\x1B[37m"
  };
  function styleToAnsi(style2) {
    const color = style2.replace(/color:\s*(\w+).*/, "$1").toLowerCase();
    return ANSI_COLORS[color] || "";
  }
  function resetAnsiStyle(string) {
    return string + ANSI_COLORS.unset;
  }
  function transformStyles(data, onStyleFound, onStyleApplied) {
    const foundStyles = {};
    return data.reduce((result, item, index, array) => {
      if (foundStyles[index]) {
        return result;
      }
      if (typeof item === "string") {
        let valueIndex = index;
        let styleApplied = false;
        item = item.replace(/%[1cdfiOos]/g, (match) => {
          valueIndex += 1;
          if (match !== "%c") {
            return match;
          }
          const style2 = array[valueIndex];
          if (typeof style2 === "string") {
            foundStyles[valueIndex] = true;
            styleApplied = true;
            return onStyleFound(style2, item);
          }
          return match;
        });
        if (styleApplied && onStyleApplied) {
          item = onStyleApplied(item);
        }
      }
      result.push(item);
      return result;
    }, []);
  }
  return style;
}
var console_1;
var hasRequiredConsole;
function requireConsole() {
  if (hasRequiredConsole) return console_1;
  hasRequiredConsole = 1;
  const {
    concatFirstStringElements,
    format: format2
  } = requireFormat();
  const { maxDepth, toJSON } = requireObject();
  const {
    applyAnsiStyles,
    removeStyles
  } = requireStyle();
  const { transform } = requireTransform();
  const consoleMethods = {
    error: console.error,
    warn: console.warn,
    info: console.info,
    verbose: console.info,
    debug: console.debug,
    silly: console.debug,
    log: console.log
  };
  console_1 = consoleTransportFactory;
  const separator = process.platform === "win32" ? ">" : "";
  const DEFAULT_FORMAT = `%c{h}:{i}:{s}.{ms}{scope}%c ${separator} {text}`;
  Object.assign(consoleTransportFactory, {
    DEFAULT_FORMAT
  });
  function consoleTransportFactory(logger) {
    return Object.assign(transport, {
      format: DEFAULT_FORMAT,
      level: "silly",
      transforms: [
        addTemplateColors,
        format2,
        formatStyles,
        concatFirstStringElements,
        maxDepth,
        toJSON
      ],
      useStyles: process.env.FORCE_STYLES,
      writeFn({ message }) {
        const consoleLogFn = consoleMethods[message.level] || consoleMethods.info;
        consoleLogFn(...message.data);
      }
    });
    function transport(message) {
      const data = transform({ logger, message, transport });
      transport.writeFn({
        message: { ...message, data }
      });
    }
  }
  function addTemplateColors({ data, message, transport }) {
    if (transport.format !== DEFAULT_FORMAT) {
      return data;
    }
    return [`color:${levelToStyle(message.level)}`, "color:unset", ...data];
  }
  function canUseStyles(useStyleValue, level) {
    if (typeof useStyleValue === "boolean") {
      return useStyleValue;
    }
    const useStderr = level === "error" || level === "warn";
    const stream2 = useStderr ? process.stderr : process.stdout;
    return stream2 && stream2.isTTY;
  }
  function formatStyles(args) {
    const { message, transport } = args;
    const useStyles = canUseStyles(transport.useStyles, message.level);
    const nextTransform = useStyles ? applyAnsiStyles : removeStyles;
    return nextTransform(args);
  }
  function levelToStyle(level) {
    const map2 = { error: "red", warn: "yellow", info: "cyan", default: "unset" };
    return map2[level] || map2.default;
  }
  return console_1;
}
var File_1;
var hasRequiredFile$1;
function requireFile$1() {
  if (hasRequiredFile$1) return File_1;
  hasRequiredFile$1 = 1;
  const EventEmitter = require$$0$3;
  const fs2 = require$$1$2;
  const os = require$$2$1;
  class File extends EventEmitter {
    constructor({
      path,
      writeOptions = { encoding: "utf8", flag: "a", mode: 438 },
      writeAsync = false
    }) {
      super();
      __publicField(this, "asyncWriteQueue", []);
      __publicField(this, "bytesWritten", 0);
      __publicField(this, "hasActiveAsyncWriting", false);
      __publicField(this, "path", null);
      __publicField(this, "initialSize");
      __publicField(this, "writeOptions", null);
      __publicField(this, "writeAsync", false);
      this.path = path;
      this.writeOptions = writeOptions;
      this.writeAsync = writeAsync;
    }
    get size() {
      return this.getSize();
    }
    clear() {
      try {
        fs2.writeFileSync(this.path, "", {
          mode: this.writeOptions.mode,
          flag: "w"
        });
        this.reset();
        return true;
      } catch (e) {
        if (e.code === "ENOENT") {
          return true;
        }
        this.emit("error", e, this);
        return false;
      }
    }
    crop(bytesAfter) {
      try {
        const content = readFileSyncFromEnd(this.path, bytesAfter || 4096);
        this.clear();
        this.writeLine(`[log cropped]${os.EOL}${content}`);
      } catch (e) {
        this.emit(
          "error",
          new Error(`Couldn't crop file ${this.path}. ${e.message}`),
          this
        );
      }
    }
    getSize() {
      if (this.initialSize === void 0) {
        try {
          const stats = fs2.statSync(this.path);
          this.initialSize = stats.size;
        } catch (e) {
          this.initialSize = 0;
        }
      }
      return this.initialSize + this.bytesWritten;
    }
    increaseBytesWrittenCounter(text) {
      this.bytesWritten += Buffer.byteLength(text, this.writeOptions.encoding);
    }
    isNull() {
      return false;
    }
    nextAsyncWrite() {
      const file2 = this;
      if (this.hasActiveAsyncWriting || this.asyncWriteQueue.length === 0) {
        return;
      }
      const text = this.asyncWriteQueue.join("");
      this.asyncWriteQueue = [];
      this.hasActiveAsyncWriting = true;
      fs2.writeFile(this.path, text, this.writeOptions, (e) => {
        file2.hasActiveAsyncWriting = false;
        if (e) {
          file2.emit(
            "error",
            new Error(`Couldn't write to ${file2.path}. ${e.message}`),
            this
          );
        } else {
          file2.increaseBytesWrittenCounter(text);
        }
        file2.nextAsyncWrite();
      });
    }
    reset() {
      this.initialSize = void 0;
      this.bytesWritten = 0;
    }
    toString() {
      return this.path;
    }
    writeLine(text) {
      text += os.EOL;
      if (this.writeAsync) {
        this.asyncWriteQueue.push(text);
        this.nextAsyncWrite();
        return;
      }
      try {
        fs2.writeFileSync(this.path, text, this.writeOptions);
        this.increaseBytesWrittenCounter(text);
      } catch (e) {
        this.emit(
          "error",
          new Error(`Couldn't write to ${this.path}. ${e.message}`),
          this
        );
      }
    }
  }
  File_1 = File;
  function readFileSyncFromEnd(filePath, bytesCount) {
    const buffer = Buffer.alloc(bytesCount);
    const stats = fs2.statSync(filePath);
    const readLength = Math.min(stats.size, bytesCount);
    const offset = Math.max(0, stats.size - bytesCount);
    const fd = fs2.openSync(filePath, "r");
    const totalBytes = fs2.readSync(fd, buffer, 0, readLength, offset);
    fs2.closeSync(fd);
    return buffer.toString("utf8", 0, totalBytes);
  }
  return File_1;
}
var NullFile_1;
var hasRequiredNullFile;
function requireNullFile() {
  if (hasRequiredNullFile) return NullFile_1;
  hasRequiredNullFile = 1;
  const File = requireFile$1();
  class NullFile extends File {
    clear() {
    }
    crop() {
    }
    getSize() {
      return 0;
    }
    isNull() {
      return true;
    }
    writeLine() {
    }
  }
  NullFile_1 = NullFile;
  return NullFile_1;
}
var FileRegistry_1;
var hasRequiredFileRegistry;
function requireFileRegistry() {
  if (hasRequiredFileRegistry) return FileRegistry_1;
  hasRequiredFileRegistry = 1;
  const EventEmitter = require$$0$3;
  const fs2 = require$$1$2;
  const path = require$$1$1;
  const File = requireFile$1();
  const NullFile = requireNullFile();
  class FileRegistry extends EventEmitter {
    constructor() {
      super();
      __publicField(this, "store", {});
      this.emitError = this.emitError.bind(this);
    }
    /**
     * Provide a File object corresponding to the filePath
     * @param {string} filePath
     * @param {WriteOptions} [writeOptions]
     * @param {boolean} [writeAsync]
     * @return {File}
     */
    provide({ filePath, writeOptions = {}, writeAsync = false }) {
      let file2;
      try {
        filePath = path.resolve(filePath);
        if (this.store[filePath]) {
          return this.store[filePath];
        }
        file2 = this.createFile({ filePath, writeOptions, writeAsync });
      } catch (e) {
        file2 = new NullFile({ path: filePath });
        this.emitError(e, file2);
      }
      file2.on("error", this.emitError);
      this.store[filePath] = file2;
      return file2;
    }
    /**
     * @param {string} filePath
     * @param {WriteOptions} writeOptions
     * @param {boolean} async
     * @return {File}
     * @private
     */
    createFile({ filePath, writeOptions, writeAsync }) {
      this.testFileWriting({ filePath, writeOptions });
      return new File({ path: filePath, writeOptions, writeAsync });
    }
    /**
     * @param {Error} error
     * @param {File} file
     * @private
     */
    emitError(error2, file2) {
      this.emit("error", error2, file2);
    }
    /**
     * @param {string} filePath
     * @param {WriteOptions} writeOptions
     * @private
     */
    testFileWriting({ filePath, writeOptions }) {
      fs2.mkdirSync(path.dirname(filePath), { recursive: true });
      fs2.writeFileSync(filePath, "", { flag: "a", mode: writeOptions.mode });
    }
  }
  FileRegistry_1 = FileRegistry;
  return FileRegistry_1;
}
var file;
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile) return file;
  hasRequiredFile = 1;
  const fs2 = require$$1$2;
  const os = require$$2$1;
  const path = require$$1$1;
  const FileRegistry = requireFileRegistry();
  const { transform } = requireTransform();
  const { removeStyles } = requireStyle();
  const {
    format: format2,
    concatFirstStringElements
  } = requireFormat();
  const { toString } = requireObject();
  file = fileTransportFactory;
  const globalRegistry = new FileRegistry();
  function fileTransportFactory(logger, { registry = globalRegistry, externalApi } = {}) {
    let pathVariables;
    if (registry.listenerCount("error") < 1) {
      registry.on("error", (e, file2) => {
        logConsole(`Can't write to ${file2}`, e);
      });
    }
    return Object.assign(transport, {
      fileName: getDefaultFileName(logger.variables.processType),
      format: "[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}]{scope} {text}",
      getFile,
      inspectOptions: { depth: 5 },
      level: "silly",
      maxSize: 1024 ** 2,
      readAllLogs,
      sync: true,
      transforms: [removeStyles, format2, concatFirstStringElements, toString],
      writeOptions: { flag: "a", mode: 438, encoding: "utf8" },
      archiveLogFn(file2) {
        const oldPath = file2.toString();
        const inf = path.parse(oldPath);
        try {
          fs2.renameSync(oldPath, path.join(inf.dir, `${inf.name}.old${inf.ext}`));
        } catch (e) {
          logConsole("Could not rotate log", e);
          const quarterOfMaxSize = Math.round(transport.maxSize / 4);
          file2.crop(Math.min(quarterOfMaxSize, 256 * 1024));
        }
      },
      resolvePathFn(vars) {
        return path.join(vars.libraryDefaultDir, vars.fileName);
      },
      setAppName(name) {
        logger.dependencies.externalApi.setAppName(name);
      }
    });
    function transport(message) {
      const file2 = getFile(message);
      const needLogRotation = transport.maxSize > 0 && file2.size > transport.maxSize;
      if (needLogRotation) {
        transport.archiveLogFn(file2);
        file2.reset();
      }
      const content = transform({ logger, message, transport });
      file2.writeLine(content);
    }
    function initializeOnFirstAccess() {
      if (pathVariables) {
        return;
      }
      pathVariables = Object.create(
        Object.prototype,
        {
          ...Object.getOwnPropertyDescriptors(
            externalApi.getPathVariables()
          ),
          fileName: {
            get() {
              return transport.fileName;
            },
            enumerable: true
          }
        }
      );
      if (typeof transport.archiveLog === "function") {
        transport.archiveLogFn = transport.archiveLog;
        logConsole("archiveLog is deprecated. Use archiveLogFn instead");
      }
      if (typeof transport.resolvePath === "function") {
        transport.resolvePathFn = transport.resolvePath;
        logConsole("resolvePath is deprecated. Use resolvePathFn instead");
      }
    }
    function logConsole(message, error2 = null, level = "error") {
      const data = [`electron-log.transports.file: ${message}`];
      if (error2) {
        data.push(error2);
      }
      logger.transports.console({ data, date: /* @__PURE__ */ new Date(), level });
    }
    function getFile(msg) {
      initializeOnFirstAccess();
      const filePath = transport.resolvePathFn(pathVariables, msg);
      return registry.provide({
        filePath,
        writeAsync: !transport.sync,
        writeOptions: transport.writeOptions
      });
    }
    function readAllLogs({ fileFilter = (f) => f.endsWith(".log") } = {}) {
      initializeOnFirstAccess();
      const logsPath = path.dirname(transport.resolvePathFn(pathVariables));
      if (!fs2.existsSync(logsPath)) {
        return [];
      }
      return fs2.readdirSync(logsPath).map((fileName) => path.join(logsPath, fileName)).filter(fileFilter).map((logPath) => {
        try {
          return {
            path: logPath,
            lines: fs2.readFileSync(logPath, "utf8").split(os.EOL)
          };
        } catch {
          return null;
        }
      }).filter(Boolean);
    }
  }
  function getDefaultFileName(processType = process.type) {
    switch (processType) {
      case "renderer":
        return "renderer.log";
      case "worker":
        return "worker.log";
      default:
        return "main.log";
    }
  }
  return file;
}
var ipc;
var hasRequiredIpc;
function requireIpc() {
  if (hasRequiredIpc) return ipc;
  hasRequiredIpc = 1;
  const { maxDepth, toJSON } = requireObject();
  const { transform } = requireTransform();
  ipc = ipcTransportFactory;
  function ipcTransportFactory(logger, { externalApi }) {
    Object.assign(transport, {
      depth: 3,
      eventId: "__ELECTRON_LOG_IPC__",
      level: logger.isDev ? "silly" : false,
      transforms: [toJSON, maxDepth]
    });
    return (externalApi == null ? void 0 : externalApi.isElectron()) ? transport : void 0;
    function transport(message) {
      var _a;
      if (((_a = message == null ? void 0 : message.variables) == null ? void 0 : _a.processType) === "renderer") {
        return;
      }
      externalApi == null ? void 0 : externalApi.sendIpc(transport.eventId, {
        ...message,
        data: transform({ logger, message, transport })
      });
    }
  }
  return ipc;
}
var remote;
var hasRequiredRemote;
function requireRemote() {
  if (hasRequiredRemote) return remote;
  hasRequiredRemote = 1;
  const http = require$$4$3;
  const https = require$$1$9;
  const { transform } = requireTransform();
  const { removeStyles } = requireStyle();
  const { toJSON, maxDepth } = requireObject();
  remote = remoteTransportFactory;
  function remoteTransportFactory(logger) {
    return Object.assign(transport, {
      client: { name: "electron-application" },
      depth: 6,
      level: false,
      requestOptions: {},
      transforms: [removeStyles, toJSON, maxDepth],
      makeBodyFn({ message }) {
        return JSON.stringify({
          client: transport.client,
          data: message.data,
          date: message.date.getTime(),
          level: message.level,
          scope: message.scope,
          variables: message.variables
        });
      },
      processErrorFn({ error: error2 }) {
        logger.processMessage(
          {
            data: [`electron-log: can't POST ${transport.url}`, error2],
            level: "warn"
          },
          { transports: ["console", "file"] }
        );
      },
      sendRequestFn({ serverUrl, requestOptions, body }) {
        const httpTransport = serverUrl.startsWith("https:") ? https : http;
        const request = httpTransport.request(serverUrl, {
          method: "POST",
          ...requestOptions,
          headers: {
            "Content-Type": "application/json",
            "Content-Length": body.length,
            ...requestOptions.headers
          }
        });
        request.write(body);
        request.end();
        return request;
      }
    });
    function transport(message) {
      if (!transport.url) {
        return;
      }
      const body = transport.makeBodyFn({
        logger,
        message: { ...message, data: transform({ logger, message, transport }) },
        transport
      });
      const request = transport.sendRequestFn({
        serverUrl: transport.url,
        requestOptions: transport.requestOptions,
        body: Buffer.from(body, "utf8")
      });
      request.on("error", (error2) => transport.processErrorFn({
        error: error2,
        logger,
        message,
        request,
        transport
      }));
    }
  }
  return remote;
}
var createDefaultLogger_1;
var hasRequiredCreateDefaultLogger;
function requireCreateDefaultLogger() {
  if (hasRequiredCreateDefaultLogger) return createDefaultLogger_1;
  hasRequiredCreateDefaultLogger = 1;
  const Logger = requireLogger();
  const ErrorHandler = requireErrorHandler();
  const EventLogger = requireEventLogger();
  const transportConsole = requireConsole();
  const transportFile = requireFile();
  const transportIpc = requireIpc();
  const transportRemote = requireRemote();
  createDefaultLogger_1 = createDefaultLogger;
  function createDefaultLogger({ dependencies, initializeFn }) {
    var _a;
    const defaultLogger = new Logger({
      dependencies,
      errorHandler: new ErrorHandler(),
      eventLogger: new EventLogger(),
      initializeFn,
      isDev: (_a = dependencies.externalApi) == null ? void 0 : _a.isDev(),
      logId: "default",
      transportFactories: {
        console: transportConsole,
        file: transportFile,
        ipc: transportIpc,
        remote: transportRemote
      },
      variables: {
        processType: "main"
      }
    });
    defaultLogger.default = defaultLogger;
    defaultLogger.Logger = Logger;
    defaultLogger.processInternalErrorFn = (e) => {
      defaultLogger.transports.console.writeFn({
        message: {
          data: ["Unhandled electron-log error", e],
          level: "error"
        }
      });
    };
    return defaultLogger;
  }
  return createDefaultLogger_1;
}
var main;
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main;
  hasRequiredMain = 1;
  const electron = require$$1$7;
  const ElectronExternalApi = requireElectronExternalApi();
  const { initialize: initialize2 } = requireInitialize();
  const createDefaultLogger = requireCreateDefaultLogger();
  const externalApi = new ElectronExternalApi({ electron });
  const defaultLogger = createDefaultLogger({
    dependencies: { externalApi },
    initializeFn: initialize2
  });
  main = defaultLogger;
  externalApi.onIpc("__ELECTRON_LOG__", (_, message) => {
    if (message.scope) {
      defaultLogger.Logger.getInstance(message).scope(message.scope);
    }
    const date = new Date(message.date);
    processMessage({
      ...message,
      date: date.getTime() ? date : /* @__PURE__ */ new Date()
    });
  });
  externalApi.onIpcInvoke("__ELECTRON_LOG__", (_, { cmd = "", logId }) => {
    switch (cmd) {
      case "getOptions": {
        const logger = defaultLogger.Logger.getInstance({ logId });
        return {
          levels: logger.levels,
          logId
        };
      }
      default: {
        processMessage({ data: [`Unknown cmd '${cmd}'`], level: "error" });
        return {};
      }
    }
  });
  function processMessage(message) {
    var _a;
    (_a = defaultLogger.Logger.getInstance(message)) == null ? void 0 : _a.processMessage(message);
  }
  return main;
}
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  const NodeExternalApi = requireNodeExternalApi();
  const createDefaultLogger = requireCreateDefaultLogger();
  const externalApi = new NodeExternalApi();
  const defaultLogger = createDefaultLogger({
    dependencies: { externalApi }
  });
  node = defaultLogger;
  return node;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  const isRenderer = typeof process === "undefined" || (process.type === "renderer" || process.type === "worker");
  const isMain = typeof process === "object" && process.type === "browser";
  if (isRenderer) {
    requireElectronLogPreload();
    src.exports = requireRenderer();
  } else if (isMain) {
    src.exports = requireMain();
  } else {
    src.exports = requireNode();
  }
  return src.exports;
}
var srcExports = requireSrc();
const log = /* @__PURE__ */ getDefaultExportFromCjs(srcExports);
const { autoUpdater } = updater;
const __filename = fileURLToPath(import.meta.url);
const __dirname$1 = require$$1$1.dirname(__filename);
const isDev = !app.isPackaged;
const preloadPath = isDev ? "../preload/preload.js" : "preload.mjs";
const renderPath = isDev ? "../renderer/index.html" : "renderer/index.html";
const envPath = isDev ? "../../.env.prod" : ".env.prod";
mainExports$1.config({ path: require$$1$1.join(__dirname$1, envPath) });
async function createWindow() {
  const win = new BrowserWindow({
    width: 1024,
    minWidth: 475,
    height: 768,
    minHeight: 400,
    webPreferences: {
      preload: require$$1$1.join(__dirname$1, preloadPath),
      contextIsolation: true,
      nodeIntegration: false,
      devTools: true,
      webSecurity: true
    },
    frame: false
  });
  if (isDev) {
    await win.loadURL(`${process.env.VITE_APP_URL}:${process.env.VITE_APP_PORT}`);
    win.webContents.openDevTools();
  } else {
    await win.loadFile(require$$1$1.join(__dirname$1, renderPath));
  }
  ipcMain.on("max-window", () => {
    win.maximize();
  });
  ipcMain.on("unmax-window", () => {
    win.unmaximize();
  });
  ipcMain.on("min-window", () => {
    win.minimize();
  });
  return win;
}
ipcMain.handle("getData:date", async (e, data) => {
  console.log(data);
  const queryStr = `
    with staticViwers as (
      select ts.NAME, count(vs.ID) as STATIC_VIWERS, tb.BROADCAST_DATE from tb_daily_view_scores vs
      left join tb_users tu on vs.USER_ID = tu.ID
      left join tb_broadcasts tb on vs.BROADCAST_ID = tb.ID
      left join tb_streamers ts on ts.ID = tb.STREAMER_ID
      where tb.BROADCAST_DATE = '${data}' and vs.TOTAL_VIEW_TIME > (tb.DURATION/2) 
      group by ts.NAME
    )
    select ts.NAME, count(vs.ID) as VIWERS, sv.static_viwers as STATIC_VIWERS, tb.BROADCAST_DATE from tb_daily_view_scores vs
    left join tb_users tu on vs.USER_ID = tu.ID
    left join tb_broadcasts tb on vs.BROADCAST_ID = tb.ID
    left join tb_streamers ts on ts.ID = tb.STREAMER_ID
    left join staticViwers sv on sv.NAME = ts.NAME
    where tb.BROADCAST_DATE = '${data}'
    group by ts.NAME;
  `;
  const result = await query(queryStr);
  return result;
});
app.on("ready", async () => {
  await createWindow();
  log.info(process.env);
  log.info(process.env.GH_TOKEN);
  autoUpdater.on("checking-for-update", () => {
    var _a;
    log.info("  ...");
    (_a = BrowserWindow.getAllWindows()[0]) == null ? void 0 : _a.webContents.send("update:checking");
  });
  autoUpdater.on("update-available", (info) => {
    var _a;
    log.info(" .");
    (_a = BrowserWindow.getAllWindows()[0]) == null ? void 0 : _a.webContents.send("update:available");
  });
  autoUpdater.on("update-not-available", (info) => {
    var _a;
    log.info(" .");
    (_a = BrowserWindow.getAllWindows()[0]) == null ? void 0 : _a.webContents.send("update:not-available");
  });
  autoUpdater.on("error", (err) => {
    var _a;
    log.info(" .  : " + err);
    (_a = BrowserWindow.getAllWindows()[0]) == null ? void 0 : _a.webContents.send("update:error", err);
  });
  autoUpdater.on("download-progress", (progressObj) => {
    var _a;
    let log_message = " : " + progressObj.bytesPerSecond;
    log_message = log_message + " -  " + progressObj.percent + "%";
    log_message = log_message + " (" + progressObj.transferred + "/" + progressObj.total + ")";
    (_a = BrowserWindow.getAllWindows()[0]) == null ? void 0 : _a.webContents.send("update:progress", progressObj);
    log.info(log_message);
  });
  autoUpdater.on("update-downloaded", (info) => {
    var _a;
    log.info(" .");
    (_a = BrowserWindow.getAllWindows()[0]) == null ? void 0 : _a.webContents.send("update:downloaded");
  });
  autoUpdater.checkForUpdates();
});
app.on("window-all-closed", () => {
  app.quit();
});
